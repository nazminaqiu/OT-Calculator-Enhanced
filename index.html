<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced OT Calculator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-indigo: #6366f1; --dark-indigo: #4f46e5; --light-indigo: #e0e7ff; --lightest-indigo: #c7d2fe;
            --danger-red: #ef4444; --dark-red: #dc2626; --success-green: #10b981; --info-blue: #3b82f6;
            --warning-orange: #f59e0b; --gray-900: #1f2937; --gray-800: #374151; --gray-700: #4b5563;
            --gray-600: #6b7280; --gray-500: #9ca3af; --gray-400: #d1d5db; --gray-300: #e5e7eb;
            --gray-200: #f3f4f6; --gray-100: #f9fafb; --gray-50: #f9fafb;
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--gray-200); display: flex; justify-content: center; align-items: flex-start; min-height: 100vh; padding: 20px; box-sizing: border-box; }
        .main-wrapper { display: flex; flex-direction: column; gap: 25px; max-width: 1200px; width: 100%; }
        @media (min-width: 1024px) { .main-wrapper { flex-direction: row; align-items: flex-start; } }
        .form-content { background-color: #fff; padding: 30px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); flex-grow: 1; width: 100%; }
        @media (min-width: 1024px) { .form-content { min-width: 600px; } }
        .summary-sidebar { background-color: #fff; padding: 25px; border-radius: 15px; box-shadow: 0 10px 25px rgba(0,0,0,0.1); position: sticky; top: 20px; align-self: flex-start; width: 100%; min-width: 300px; flex-shrink: 0; }
        @media (min-width: 1024px) { .summary-sidebar { width: 350px; } }
        .input-group label { font-weight: 600; color: var(--gray-800); margin-bottom: 8px; display: block; }
        .input-group input, .input-group select { width: 100%; padding: 12px; border: 1px solid var(--gray-400); border-radius: 8px; font-size: 1rem; color: var(--gray-700); transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out; }
        .input-group input:focus, .input-group select:focus { outline: 0; border-color: var(--primary-indigo); box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); }
        .input-group select:disabled { background-color: var(--gray-200); cursor: not-allowed; }
        .btn { padding: 12px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        .btn-primary { background-color: var(--primary-indigo); color: #fff; }
        .btn-primary:hover { background-color: var(--dark-indigo); transform: translateY(-1px); }
        .btn-secondary { background-color: var(--light-indigo); color: var(--dark-indigo); }
        .btn-secondary:hover { background-color: var(--lightest-indigo); transform: translateY(-1px); }
        .btn-danger { background-color: var(--danger-red); color: #fff; }
        .btn-danger:hover { background-color: var(--dark-red); transform: translateY(-1px); }
        .results-section h3 { font-size: 1.5rem; font-weight: 700; color: var(--gray-900); margin-bottom: 15px; }
        .results-section p { font-size: 1.1rem; margin-bottom: 8px; color: var(--gray-800); }
        .results-section p strong { color: var(--gray-900); }
        .message-box { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: #fff; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); z-index: 1000; text-align: center; min-width: 300px; max-width: 90%; border: 1px solid var(--gray-400); opacity: 0; transform: translate(-50%, -50%) scale(0.9); transition: opacity 0.3s ease-out, transform 0.3s ease-out; }
        .message-box.show { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .message-box h4 { font-size: 1.5rem; font-weight: 700; color: var(--gray-900); margin-bottom: 15px; }
        .message-box p { font-size: 1.1rem; color: var(--gray-700); margin-bottom: 25px; }
        .message-box-buttons { display: flex; justify-content: center; gap: 15px; }
        .message-box button { background-color: var(--primary-indigo); color: #fff; padding: 10px 20px; border-radius: 8px; font-weight: 600; cursor: pointer; transition: background-color 0.2s ease-in-out; }
        .message-box button:hover { background-color: var(--dark-indigo); }
        .message-box .btn-cancel { background-color: var(--gray-300); color: var(--gray-700); }
        .message-box .btn-cancel:hover { background-color: var(--gray-400); }
        .manual-entry-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; transition: opacity 0.3s ease-out; }
        .manual-entry-modal.show { opacity: 1; }
        .manual-entry-modal-content { background-color: #fff; padding: 30px; border-radius: 15px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); text-align: center; min-width: 350px; max-width: 90%; border: 1px solid var(--gray-400); transform: scale(0.9); transition: transform 0.3s ease-out; }
        .manual-entry-modal.show .manual-entry-modal-content { transform: scale(1); }
        .manual-entry-modal-content h4 { font-size: 1.5rem; font-weight: 700; color: var(--gray-900); margin-bottom: 15px; }
        .manual-entry-modal-content .input-group { margin-bottom: 20px; }
        .manual-entry-modal-content .modal-buttons { display: flex; justify-content: center; gap: 15px; }
        .export-choice-modal .modal-buttons { flex-direction: column; }
        .export-choice-modal .modal-buttons button { width: 100%; }
        @media (max-width: 768px) { .form-content, .summary-sidebar { padding: 20px; } }
        .loading-indicator { margin-left: 10px; font-size: 0.9em; color: var(--primary-indigo); font-weight: 500; }
        #userIdDisplay { font-size: 0.8em; color: var(--gray-600); text-align: right; margin-top: -15px; margin-bottom: 15px; word-break: break-all; }
        .summary-inline-group { display: flex; flex-wrap: wrap; gap: 10px; font-size: 1rem; color: var(--gray-800); margin-bottom: 8px; }
        .summary-inline-group strong { display: block; width: 100%; margin-bottom: 4px; }
        .summary-inline-item { display: inline-block; padding: 4px 8px; background-color: var(--light-indigo); border-radius: 6px; color: var(--dark-indigo); font-weight: 500; }
        .collapsible-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 10px 0; border-bottom: 1px solid #cbd5e0; margin-bottom: 15px; }
        .collapsible-header h3 { margin-bottom: 0; }
        .collapsible-content { overflow: hidden; transition: max-height 0.3s ease-out; }
        .collapsible-content.collapsed { max-height: 0 !important; }
        .collapsible-icon { transition: transform 0.3s ease-out; }
        .collapsible-icon.rotated { transform: rotate(90deg); }
        .input-error { border-color: var(--danger-red); box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2); }
        .error-message { color: var(--danger-red); font-size: 0.85rem; margin-top: 4px; }
        .status-message { margin-left: 10px; font-size: 0.9em; font-weight: 500; opacity: 0; transition: opacity 0.3s ease-in-out; }
        .status-message.show { opacity: 1; }
        .status-message.loading { color: var(--primary-indigo); }
        .status-message.success { color: var(--success-green); }
        .status-message.error { color: var(--danger-red); }
        .input-with-clear { position: relative; display: flex; align-items: center; }
        .input-with-clear input { padding-right: 36px; }
        .clear-input-btn { position: absolute; right: 8px; background: 0 0; border: none; cursor: pointer; color: var(--gray-500); padding: 4px; border-radius: 50%; transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out; display: flex; align-items: center; justify-content: center; }
        .clear-input-btn:hover { background-color: var(--gray-300); color: var(--gray-700); }
        .allocation-choice-modal .modal-buttons button { width: 100%; }
        .allocation-choice-modal .modal-buttons { flex-direction: column; }
        .toggle-switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; -webkit-transition: .4s; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; -webkit-transition: .4s; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-indigo); }
        input:focus + .slider { box-shadow: 0 0 1px var(--primary-indigo); }
        input:checked + .slider:before { -webkit-transform: translateX(26px); -ms-transform: translateX(26px); transform: translateX(26px); }
        #toastContainer { position: fixed; bottom: 1rem; right: 1rem; z-index: 2000; display: flex; flex-direction: column; gap: 0.5rem; max-width: 300px; }
        .toast { background-color: #333; color: #fff; padding: 0.75rem 1rem; border-radius: 0.5rem; box-shadow: 0 4px 12px rgba(0,0,0,0.2); opacity: 0; transform: translateY(20px); transition: opacity 0.3s ease-out, transform 0.3s ease-out; }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.info { background-color: var(--info-blue); }
        .toast.success { background-color: var(--success-green); }
        .toast.error { background-color: var(--danger-red); }
        .toast.warning { background-color: var(--warning-orange); }
        #loadingOverlay { transition: opacity .3s ease-in-out; }
        .loader { border-top-color: var(--primary-indigo); animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .tooltip-container { position: relative; display: inline-flex; align-items: center; margin-left: 0.5rem; cursor: help; }
        .tooltip-content { position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%) translateY(-0.5rem); background-color: #333; color: #fff; padding: 0.5rem 0.75rem; border-radius: 0.375rem; font-size: 0.875rem; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s ease-out, transform 0.2s ease-out; z-index: 10; }
        .tooltip-container:hover .tooltip-content { opacity: 1; transform: translateX(-50%) translateY(-1rem); }
        .chart-container { position: relative; width: 100%; height: 256px; display: flex; align-items: center; justify-content: center; background-color: var(--gray-50); border-radius: 8px; overflow: hidden; }
        .chart-placeholder { color: var(--gray-500); font-style: italic; text-align: center; padding: 1rem; }
        .progress-bar-container { margin-top: 1.5rem; }
        .progress-bar-label { display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; font-weight: 500; color: var(--gray-700); margin-bottom: 0.5rem; }
        .progress-bar { width: 100%; height: 12px; background-color: var(--gray-200); border-radius: 9999px; overflow: hidden; }
        .progress-bar-fill { height: 100%; width: 0; border-radius: 9999px; transition: width 0.5s ease-out, background-color 0.5s ease-out; }
        .calendar-container { margin-top: 1rem; }
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }
        .calendar-header h4 { font-size: 1.25rem; font-weight: 700; color: var(--gray-800); }
        .calendar-nav button { background: 0 0; border: none; cursor: pointer; padding: 0.5rem; border-radius: 50%; transition: background-color 0.2s; }
        .calendar-nav button:hover { background-color: var(--gray-200); }
        .calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px; }
        .calendar-day-name { text-align: center; font-size: 0.8rem; font-weight: 600; color: var(--gray-500); padding-bottom: 0.5rem; }
        .calendar-day { position: relative; text-align: center; padding: 0.5rem 0; border-radius: 8px; cursor: pointer; transition: background-color .2s, border-color .2s; border: 2px solid transparent; }
        .calendar-day:not(.disabled):hover { background-color: var(--light-indigo); }
        .calendar-day.today { border-color: var(--primary-indigo); }
        .calendar-day.has-ot { background-color: var(--primary-indigo); color: #fff; font-weight: 600; }
        .calendar-day.has-ot:hover { background-color: var(--dark-indigo); }
        .calendar-day.disabled { color: var(--gray-400); cursor: not-allowed; }
        .calendar-day .ot-hours { position: absolute; bottom: 2px; right: 4px; font-size: 0.7rem; font-weight: 700; opacity: 0.8; }
        .wizard-step { display: none; }
        .wizard-step.active { display: block; }
        .wizard-progress { display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1.5rem; }
        .wizard-progress-dot { width: 12px; height: 12px; border-radius: 50%; background-color: var(--gray-300); transition: background-color .3s; }
        .wizard-progress-dot.active { background-color: var(--primary-indigo); }
    </style>
</head>
<body>

<div class="main-wrapper">
    <!-- Form Content -->
    <div class="form-content">
        <div class="flex justify-between items-center mb-6">
            <h2 class="text-3xl font-extrabold text-gray-900">Enhanced OT Calculator</h2>
            <button id="quickSetupBtn" class="btn btn-secondary" aria-label="Open Quick Setup">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0L8 7.48l-4.73.34c-1.61.12-2.27 2.23-1.09 3.33l3.64 3.28-1.11 4.86c-.33 1.45 1.25 2.58 2.6 1.86L10 17.6l4.7 2.87c1.35.72 2.93-.41 2.6-1.86l-1.11-4.86 3.64-3.28c1.18-1.1.52-3.21-1.09-3.33L12 7.48l-.51-4.31z" clip-rule="evenodd" /></svg>
                Quick Setup
            </button>
        </div>
        <div id="userIdDisplay" class="hidden"></div>

        <!-- How to Use Section -->
        <div class="bg-blue-50 p-6 rounded-xl border border-blue-200 mb-6">
            <div class="collapsible-header" data-target="howToUseContent">
                <h3 class="text-xl font-bold text-blue-800">How to Use This Calculator</h3>
                <svg class="collapsible-icon h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                </svg>
            </div>
            <div id="howToUseContent" class="collapsible-content">
                <ul class="list-disc list-inside text-gray-700 space-y-2">
                    <li><strong>1. Employee Settings:</strong> Enter your basic monthly salary. Optionally, set a target OT pay and/or min/max total hours.</li>
                    <li><strong>2. OT Planning Date Range:</strong> Define the period for which you want to calculate or plan your overtime.</li>
                    <li><strong>3. Public Holiday Management:</strong> Add any public holidays within your planning range.</li>
                    <li><strong>4. OT Multiplier Settings:</strong> Adjust the overtime rates. Note: Rest Day (Sunday) pay is now automatically split for the first 8 hours and after.</li>
                    <li><strong>5. Daily Overtime Entries:</strong>
                        <ul class="list-circle list-inside ml-4 mt-1 space-y-1">
                            <li>Use the <strong>Interactive Calendar</strong> to manage your schedule. Click on a day to add or edit OT hours.</li>
                            <li><strong>Allocation Strategy:</strong> Choose how hours are allocated.
                                <ul>
                                    <li><strong>Target-Driven:</strong> Automatically selected when you have a "Target OT Pay". This now treats your target as a <strong>minimum</strong>. Choose a sub-strategy:
                                        <ul class="list-square list-inside ml-4">
                                            <li><strong>Balanced:</strong> Uses a human-like, randomized approach to meet your target.</li>
                                            <li><strong>Fastest Path:</strong> Prioritizes high-pay days to meet your target with fewer hours.</li>
                                            <li><strong>Cheapest Path:</strong> Prioritizes low-pay days to maximize hours for a given target.</li>
                                        </ul>
                                    </li>
                                    <li><strong>Workload-Driven:</strong> Automatically selected when you have no target. Allocates hours based on a "Workload Preset".</li>
                                </ul>
                            </li>
                            <li>The logic now ensures your <strong>Min Total OT Hours</strong> target is met if possible, after the pay target is secured.</li>
                            <li>Click "Auto Allocate Hours" to generate entries based on your chosen strategy.</li>
                        </ul>
                    </li>
                </ul>
            </div>
        </div>

        <!-- Employee Settings -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Employee Settings</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                <div class="input-group">
                    <label for="basicSalary">Basic Monthly Salary (RM)</label>
                    <div class="input-with-clear">
                        <input type="number" id="basicSalary" value="3700.00" min="0" step="0.01" class="shadow-sm">
                        <button type="button" class="clear-input-btn" aria-label="Clear Basic Monthly Salary">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                        </button>
                    </div>
                </div>
                <div class="input-group">
                    <label for="targetOTPaySelect">Target OT Pay (RM) (Optional)</label>
                    <select id="targetOTPaySelect" class="shadow-sm mb-2">
                        <option value="">No Target</option>
                        <option value="custom">Other (Enter Manually)</option>
                    </select>
                    <div class="input-with-clear">
                        <input type="number" id="customTargetOTPayInput" class="shadow-sm hidden" placeholder="Enter custom target pay">
                        <button type="button" class="clear-input-btn hidden" id="clearCustomTargetOTPayBtn" aria-label="Clear Custom Target OT Pay">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                        </button>
                    </div>
                </div>
                <div class="input-group">
                    <label for="minTotalOTHours">Min Total OT Hours (Optional)
                        <span class="tooltip-container">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                            <span class="tooltip-content">The minimum total OT hours to aim for.</span>
                        </span>
                    </label>
                    <div class="input-with-clear">
                        <input type="number" id="minTotalOTHours" min="0" step="0.5" class="shadow-sm" placeholder="e.g., 140">
                        <button type="button" class="clear-input-btn" id="clearMinTotalOTHoursBtn" aria-label="Clear Min Total OT Hours">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                        </button>
                    </div>
                    <div id="minMaxHoursError" class="error-message"></div>
                </div>
                <div class="input-group">
                    <label for="maxTotalOTHours">Max Total OT Hours (Optional)
                        <span class="tooltip-container">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                            <span class="tooltip-content">The maximum total OT hours not to exceed.</span>
                        </span>
                    </label>
                    <div class="input-with-clear">
                        <input type="number" id="maxTotalOTHours" min="0" step="0.5" class="shadow-sm" placeholder="e.g., 150">
                        <button type="button" class="clear-input-btn" id="clearMaxTotalOTHoursBtn" aria-label="Clear Max Total OT Hours">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                        </button>
                    </div>
                </div>
            </div>
            <div class="mt-6">
                <label class="block text-xl font-bold text-gray-800 mb-3">Auto-Allocate to:</label>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="flex items-center"><input type="checkbox" id="allocateWorkingDay" class="h-5 w-5 text-primary-indigo rounded border-gray-300 focus:ring-primary-indigo" checked><label for="allocateWorkingDay" class="ml-2 text-gray-700 font-medium">Working Day</label></div>
                    <div class="flex items-center"><input type="checkbox" id="allocateOffDay" class="h-5 w-5 text-primary-indigo rounded border-gray-300 focus:ring-primary-indigo" checked><label for="allocateOffDay" class="ml-2 text-gray-700 font-medium">Off Day</label></div>
                    <div class="flex items-center"><input type="checkbox" id="allocateRestDay" class="h-5 w-5 text-primary-indigo rounded border-gray-300 focus:ring-primary-indigo" checked><label for="allocateRestDay" class="ml-2 text-gray-700 font-medium">Rest Day</label></div>
                    <div class="flex items-center"><input type="checkbox" id="allocatePublicHoliday" class="h-5 w-5 text-primary-indigo rounded border-gray-300 focus:ring-primary-indigo" checked><label for="allocatePublicHoliday" class="ml-2 text-gray-700 font-medium">Public Holiday</label></div>
                </div>
            </div>
            <p class="text-sm text-gray-600 mt-4">Working Schedule: 5 days/week, Saturday: Off Day, Sunday: Rest Day. For payroll, employer uses 26 working days monthly.</p>
        </div>

        <!-- OT Planning Date Range -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
            <h3 class="text-xl font-bold text-gray-800 mb-4">OT Planning Date Range</h3>
            <div class="input-group">
                <label for="dateRangeInput">Select Date Range</label>
                <div class="flex items-center gap-2">
                    <input id="dateRangeInput" class="shadow-sm flex-grow" placeholder="Click to select date range" readonly>
                    <button type="button" id="setThisMonthBtn" class="btn btn-secondary p-2" aria-label="Set date range to this month">This Month</button>
                </div>
                <div id="dateRangeError" class="error-message"></div>
            </div>
        </div>

        <!-- Public Holiday Management -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
            <div class="collapsible-header" data-target="publicHolidaysContent">
                <h3 class="text-xl font-bold text-gray-800">Public Holiday Management</h3>
                <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
            </div>
            <div id="publicHolidaysContent" class="collapsible-content">
                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <div class="input-group flex-grow">
                        <label for="publicHolidayDate">Add Public Holiday Date</label>
                        <div class="flex items-center gap-2">
                            <input type="date" id="publicHolidayDate" class="shadow-sm flex-grow">
                            <button type="button" id="setPublicHolidayTodayBtn" class="btn btn-secondary p-2" aria-label="Set public holiday date to today">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" /></svg>
                            </button>
                        </div>
                    </div>
                    <button id="addPublicHolidayDateBtn" class="btn btn-secondary mt-auto" aria-label="Add public holiday">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                        Add Holiday
                    </button>
                </div>
                <ul id="publicHolidaysList" class="list-disc list-inside ml-4 text-gray-700"></ul>
            </div>
        </div>

        <!-- OT Multiplier Settings -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
            <div class="collapsible-header" data-target="otMultiplierContent">
                <h3 class="text-xl font-bold text-gray-800">OT Multiplier Settings</h3>
                <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
            </div>
            <div id="otMultiplierContent" class="collapsible-content">
                <div id="otMultiplierInputs" class="grid grid-cols-1 md:grid-cols-2 gap-5 mb-4"></div>
                <button id="resetMultipliersBtn" class="btn btn-secondary" aria-label="Reset OT multipliers to default">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.118a1 1 0 01-.293.707l-2.118 2.118A1 1 0 012 8v8a2 2 0 002 2h12a2 2 0 002-2V8a1 1 0 01-.293-.707l-2.118-2.118A1 1 0 0115 5.118V3a1 1 0 011-1h-2a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H4zm2 5V4h8v3H6zm-2 4h12V9H4v2zm0 2h12v3H4v-3z" clip-rule="evenodd" /></svg>
                    Reset to Default Multipliers
                </button>
            </div>
        </div>

        <!-- Daily Overtime Entries -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Daily Overtime Entries</h3>
            <div class="input-group mb-4">
                <label for="allocationStrategy">Allocation Strategy
                    <span class="tooltip-container">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                        <span class="tooltip-content">This is set automatically based on Target OT Pay.</span>
                    </span>
                </label>
                <select id="allocationStrategy" class="shadow-sm" aria-describedby="allocationStrategyDescription">
                    <option value="Target-Driven">Target-Driven (using Workload Presets)</option>
                    <option value="Workload-Driven">Workload-Driven (Fill All Days)</option>
                </select>
                <p id="allocationStrategyDescription" class="text-sm text-gray-600 mt-2"></p>
            </div>
            <div id="targetDrivenStrategyGroup" class="input-group mb-4 hidden">
                <label for="targetAllocationStrategy">Target-Driven Strategy
                    <span class="tooltip-container">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                        <span class="tooltip-content">Choose how to meet your OT pay target.</span>
                    </span>
                </label>
                <select id="targetAllocationStrategy" class="shadow-sm" aria-describedby="targetAllocationStrategyDescription">
                    <option value="Balanced">Balanced (Human-like)</option>
                    <option value="Fastest Path">Fastest Path (Fewest Hours)</option>
                    <option value="Cheapest Path">Cheapest Path (Most Hours)</option>
                </select>
                <p id="targetAllocationStrategyDescription" class="text-sm text-gray-600 mt-2"></p>
            </div>
            <div id="workloadPresetGroup" class="input-group mb-4">
                <label for="workloadPreset">Workload Preset for Auto Allocation
                    <span class="tooltip-container">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/></svg>
                        <span class="tooltip-content">Defines min/max hours for different day types.</span>
                    </span>
                </label>
                <select id="workloadPreset" class="shadow-sm" aria-describedby="workloadPresetDescription">
                    <option value="Moderate Workload">Moderate Workload</option>
                    <option value="Light Workload">Light Workload</option>
                    <option value="Heavy Workload">Heavy Workload</option>
                </select>
                <p id="workloadPresetDescription" class="text-sm text-gray-600 mt-2"></p>
            </div>
            <div id="workloadPresetDetails" class="text-sm text-gray-700 mb-4 p-3 bg-gray-100 rounded-md border border-gray-200"></div>
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <button id="autoAllocateBtn" class="btn btn-secondary flex-grow" aria-label="Auto allocate hours">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M17.293 3.293a1 1 0 011.414 0l-2.293 2.293a1 1 0 01-1.414-1.414l2.293-2.293zM9 12a3 3 0 100-6 3 3 0 000 6z"/><path fill-rule="evenodd" d="M15.293 10.293a1 1 0 010 1.414l-2.293 2.293a1 1 0 01-1.414-1.414l2.293-2.293a1 1 0 011.414 0zM4.707 4.707a1 1 0 010 1.414L2.414 8.414a1 1 0 01-1.414-1.414L3.293 4.707a1 1 0 011.414 0zM12 9a3 3 0 10-6 0 3 3 0 006 0z" clip-rule="evenodd" /></svg>
                    Auto Allocate Hours
                    <span id="autoAllocateLoading" class="loading-indicator hidden" aria-live="polite">Allocating...</span>
                </button>
                <button id="clearAllEntriesBtn" class="btn btn-danger flex-grow" aria-label="Clear all OT entries">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" /></svg>
                    Clear All Entries
                </button>
            </div>
            <!-- [NEW] Hour Adjustment Buttons -->
            <div class="flex flex-col sm:flex-row gap-4 mb-4">
                <button id="addHourBtn" class="btn btn-secondary flex-grow" aria-label="Add 0.5 hour">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" /></svg>
                    Add 0.5 Hour
                </button>
                <button id="reduceHourBtn" class="btn btn-secondary flex-grow" aria-label="Reduce 0.5 hour">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 10a1 1 0 011-1h8a1 1 0 110 2H6a1 1 0 01-1-1z" clip-rule="evenodd" /></svg>
                    Reduce 0.5 Hour
                </button>
            </div>
            <div id="calendarContainer" class="calendar-container"></div>
            <div class="flex flex-col sm:flex-row gap-4 mt-4">
                <button id="saveDataBtn" class="btn btn-primary flex-grow" aria-label="Save current data">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M7 3a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1V4a1 1 0 00-1-1H7z"/><path fill-rule="evenodd" d="M18 8H2a2 2 0 00-2 2v8a2 2 0 002 2h16a2 2 0 002-2v-8a2 2 0 00-2-2zM4 13a1 1 0 011-1h10a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3z" clip-rule="evenodd" /></svg>
                    Save Data
                    <span id="saveDataStatus" class="status-message" aria-live="polite"></span>
                </button>
                <button id="loadDataBtn" class="btn btn-secondary flex-grow" aria-label="Load saved data">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" /></svg>
                    Load Data
                    <span id="loadDataStatus" class="status-message" aria-live="polite"></span>
                </button>
            </div>
        </div>

        <!-- Firebase Toggle -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mt-6 flex items-center justify-between">
            <label for="firebaseToggle" class="text-xl font-bold text-gray-800 cursor-pointer">Enable Firebase (Save/Load)</label>
            <label class="toggle-switch">
                <input type="checkbox" id="firebaseToggle">
                <span class="slider"></span>
            </label>
        </div>
        <p id="firebaseStatusMessage" class="text-sm text-gray-600 mt-2 text-center"></p>

        <button id="resetAndReallocateBtn" class="btn btn-danger w-full mt-4" aria-label="Reset all and re-allocate">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.118a1 1 0 01-.293.707l-2.118 2.118A1 1 0 012 8v8a2 2 0 002 2h12a2 2 0 002-2V8a1 1 0 01-.293-.707l-2.118-2.118A1 1 0 0115 5.118V3a1 1 0 011-1h-2a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H4zm2 5V4h8v3H6zm-2 4h12V9H4v2zm0 2h12v3H4v-3z" clip-rule="evenodd" /></svg>
            Reset & Re-allocate All
        </button>
    </div>

    <!-- Summary Sidebar -->
    <div class="summary-sidebar">
        <div id="results" class="results-section">
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Calculation Summary</h3>
            <div id="payProgressContainer" class="progress-bar-container hidden">
                <div class="progress-bar-label"><span>Pay Target Progress</span><span id="payPercentage">0%</span></div>
                <div class="progress-bar"><div id="payProgressBar" class="progress-bar-fill"></div></div>
            </div>
            <div id="hoursProgressContainer" class="progress-bar-container hidden">
                <div class="progress-bar-label"><span>Hours Progress</span><span id="hoursPercentage">0%</span></div>
                <div class="progress-bar"><div id="hoursProgressBar" class="progress-bar-fill"></div></div>
            </div>
            <p class="text-xl font-bold text-gray-900 mt-6">Combined OT Pay: <span id="combinedOTPay" class="text-indigo-600">RM 0.00</span></p>
            <p class="text-xl font-bold text-gray-900 mt-2">Target OT Pay: <span id="targetOTPayDisplay" class="text-green-600">RM 0.00</span></p>
            <p class="text-xl font-bold mt-2">Difference from Target: <span id="differenceFromTarget">RM 0.00</span></p>
            <p class="text-xl font-bold mt-2">Total Monthly OT Hours: <span id="totalMonthlyOTHoursDisplay">0.0 hours</span></p>
            <p class="text-xl font-bold mt-2">Total OT Hours Range: <span id="totalOTHoursRangeDisplay">N/A</span></p>
            <p class="text-xl font-bold text-gray-900 mt-2">Expected Salary Pay: <span id="expectedSalaryPayDisplay" class="text-indigo-600">RM 0.00</span></p>
            <h4 class="text-lg font-bold text-gray-800 mt-6 mb-2">OT Pay Distribution</h4>
            <div class="chart-container">
                <canvas id="otDistributionChart" class="w-full h-full"></canvas>
                <p id="chartPlaceholder" class="chart-placeholder absolute hidden">No OT data to display. Add entries and calculate!</p>
            </div>
            <div class="summary-inline-group mt-6"><strong>Total OT Hours by Type:</strong><span id="totalHoursByType" class="text-gray-700"></span></div>
            <div class="summary-inline-group"><strong>Total Pay per OT Category:</strong><span id="totalPayByCategory" class="text-gray-700"></span></div>
            <p class="text-base font-bold text-gray-900 mt-2">Allocation Strategy: <span id="allocationStrategySummary" class="text-gray-700"></span></p>
            <button id="exportSummaryBtn" class="btn btn-secondary mt-6" aria-label="Export OT summary">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l2.293-2.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>
                Export Summary
            </button>
        </div>
    </div>
</div>

<!-- Modals and Overlays -->
<div id="messageBox" class="message-box hidden" role="dialog" aria-modal="true" aria-labelledby="messageBoxTitle" aria-describedby="messageBoxContent">
    <h4 id="messageBoxTitle"></h4>
    <p id="messageBoxContent"></p>
    <div class="message-box-buttons">
        <button id="messageBoxCancelBtn" class="btn btn-cancel hidden">Cancel</button>
        <button id="messageBoxConfirmBtn" class="hidden">Confirm</button>
        <button id="messageBoxCloseBtn">OK</button>
    </div>
</div>

<div id="addDetailedOTEntryModal" class="manual-entry-modal hidden" role="dialog" aria-modal="true" aria-labelledby="detailedEntryModalTitle">
    <div class="manual-entry-modal-content">
        <h4 id="detailedEntryModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Add/Edit OT Entry</h4>
        <div class="input-group"><label for="detailedEntryDate">Date</label><input type="date" id="detailedEntryDate" class="shadow-sm" readonly></div>
        <div class="input-group">
            <label for="detailedEntryHours">Hours</label>
            <input type="number" id="detailedEntryHours" value="2.0" min="0" step="0.5" class="shadow-sm">
            <div id="detailedEntryHoursError" class="error-message text-left"></div>
        </div>
        <div class="input-group">
            <label for="detailedEntryStartTime">Start Time</label>
            <input type="time" id="detailedEntryStartTime" value="18:00" class="shadow-sm">
            <div id="detailedEntryStartTimeError" class="error-message text-left"></div>
        </div>
        <div class="input-group">
            <label for="detailedEntryEndTime">End Time (Calculated)</label>
            <input type="time" id="detailedEntryEndTime" class="shadow-sm" readonly>
        </div>
        <div class="modal-buttons">
            <button id="removeDetailedEntryBtn" class="btn btn-danger hidden">Remove</button>
            <button id="cancelDetailedEntryBtn" class="btn btn-secondary">Cancel</button>
            <button id="confirmDetailedEntryBtn" class="btn btn-primary">Save</button>
        </div>
    </div>
</div>

<div id="allocationChoiceModal" class="manual-entry-modal hidden allocation-choice-modal" role="dialog" aria-modal="true" aria-labelledby="allocationChoiceModalTitle">
    <div class="manual-entry-modal-content">
        <h4 id="allocationChoiceModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Auto-Allocation Options</h4>
        <p class="text-gray-700 mb-6">How would you like to allocate overtime hours?</p>
        <div class="modal-buttons">
            <button id="clearAndAllocateBtn" class="btn btn-danger">Auto Allocate</button>
            <button id="fillRemainingBtn" class="btn btn-primary mt-4">Fill Remaining Hours</button>
            <button id="cancelAllocationChoiceBtn" class="btn btn-secondary mt-4">Cancel</button>
        </div>
    </div>
</div>

<!-- [NEW] Export Choice Modal -->
<div id="exportChoiceModal" class="manual-entry-modal hidden export-choice-modal" role="dialog" aria-modal="true" aria-labelledby="exportChoiceModalTitle">
    <div class="manual-entry-modal-content">
        <h4 id="exportChoiceModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Choose Export Format</h4>
        <p class="text-gray-700 mb-6">Select how you would like to export your OT summary.</p>
        <div class="modal-buttons">
            <button id="exportTxtBtn" class="btn btn-secondary">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 4a2 2 0 012-2h8a2 2 0 012 2v12a1 1 0 110 2h-3a1 1 0 01-1-1v-2a1 1 0 00-1-1H9a1 1 0 00-1 1v2a1 1 0 01-1 1H5a1 1 0 110-2V4zm3 1a1 1 0 011-1h2a1 1 0 110 2H8a1 1 0 01-1-1z" clip-rule="evenodd" /></svg>
                Text Summary (.txt)
            </button>
            <button id="exportCsvBtn" class="btn btn-secondary mt-4">
                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M2 5a2 2 0 012-2h12a2 2 0 012 2v10a2 2 0 01-2 2H4a2 2 0 01-2-2V5zm3 1a1 1 0 000 2h8a1 1 0 100-2H5zM5 9a1 1 0 000 2h2a1 1 0 100-2H5z" /></svg>
                CSV File (.csv)
            </button>
            <button id="exportHtmlBtn" class="btn btn-secondary mt-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5 4V3a2 2 0 012-2h6a2 2 0 012 2v1h-1.5a.5.5 0 000 1H15v2H5V5h1.5a.5.5 0 000-1H5zm9 3H6a1 1 0 00-1 1v6a1 1 0 001 1h8a1 1 0 001-1V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>
                Printable Report
            </button>
            <button id="cancelExportChoiceBtn" class="btn btn-secondary mt-8">Cancel</button>
        </div>
    </div>
</div>


<div id="wizardModal" class="manual-entry-modal hidden" role="dialog" aria-modal="true" aria-labelledby="wizardTitle">
    <div class="manual-entry-modal-content" style="max-width:500px">
        <h4 id="wizardTitle" class="text-2xl font-bold text-gray-900 mb-2">Quick Setup</h4>
        <p class="text-gray-600 mb-6">Let's get your calculator configured in a few steps.</p>
        <div class="wizard-progress">
            <div class="wizard-progress-dot active" data-step="1"></div>
            <div class="wizard-progress-dot" data-step="2"></div>
            <div class="wizard-progress-dot" data-step="3"></div>
        </div>
        <div id="wizardStep1" class="wizard-step active">
            <h5 class="text-xl font-semibold text-gray-800 mb-4">Step 1: Your Salary</h5>
            <div class="input-group text-left">
                <label for="wizardBasicSalary">Basic Monthly Salary (RM)</label>
                <input type="number" id="wizardBasicSalary" value="3700.00" min="0" step="0.01" class="shadow-sm">
                <div id="wizardSalaryError" class="error-message"></div>
            </div>
        </div>
        <div id="wizardStep2" class="wizard-step">
            <h5 class="text-xl font-semibold text-gray-800 mb-4">Step 2: Your Goals (Optional)</h5>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-left">
                <div class="input-group">
                    <label for="wizardTargetOTPaySelect">Target OT Pay (RM)</label>
                    <select id="wizardTargetOTPaySelect" class="shadow-sm mb-2"></select>
                    <div class="input-with-clear">
                        <input type="number" id="wizardCustomTargetOTPayInput" class="shadow-sm hidden" placeholder="Enter custom target pay">
                        <button type="button" class="clear-input-btn hidden" id="clearWizardCustomTargetOTPayBtn" aria-label="Clear Custom Target OT Pay">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                        </button>
                    </div>
                </div>
                <div class="input-group">
                    <label for="wizardMinHours">Min Total Hours</label>
                    <input type="number" id="wizardMinHours" min="0" step="0.5" class="shadow-sm" placeholder="e.g., 140">
                </div>
            </div>
            <div class="input-group text-left mt-4">
                <label for="wizardMaxHours">Max Total Hours</label>
                <input type="number" id="wizardMaxHours" min="0" step="0.5" class="shadow-sm" placeholder="e.g., 150">
                <div id="wizardHoursError" class="error-message"></div>
            </div>
        </div>
        <div id="wizardStep3" class="wizard-step">
            <h5 class="text-xl font-semibold text-gray-800 mb-4">Step 3: Planning Period</h5>
            <div class="input-group">
                <label for="wizardDateRange">Select Date Range</label>
                <input id="wizardDateRange" class="shadow-sm" placeholder="Click to select date range" readonly>
                <div id="wizardDateError" class="error-message text-left"></div>
            </div>
        </div>
        <div class="modal-buttons mt-8">
            <button id="wizardPrevBtn" class="btn btn-secondary hidden">Previous</button>
            <button id="wizardNextBtn" class="btn btn-primary">Next</button>
            <button id="wizardFinishBtn" class="btn btn-primary hidden">Finish</button>
        </div>
    </div>
</div>

<div id="loadingOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-[3000] hidden">
    <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-16 w-16"></div>
</div>

<div id="toastContainer"></div>

<script type="module">
    // Firebase Imports
    import { initializeApp as initializeFirebaseApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- CONFIGURATION ---
    const DEFAULT_OT_MULTIPLIERS = {
        "Normal OT (Weekdays)": 1.5,
        "Off Day (Saturday)": 1.5,
        "Rest Day (Sunday)": 0.5,
        "Rest Day (Sunday) - After 8h": 2.0,
        "Public Holiday": 2.0,
    };
    const DISPLAYABLE_OT_TYPES = ["Normal OT (Weekdays)", "Off Day (Saturday)", "Rest Day (Sunday)", "Public Holiday"];
    const PREDEFINED_TARGET_PAYS = [1000, 2000, 3000, 4000, 5000];
    const CONFIG = {
        WORKING_DAYS_MONTHLY: 26,
        STANDARD_WORK_HOURS_DAILY: 8,
        MAX_DAILY_OT_HOURS: 8,
        ALLOCATION_PRECISION: 0.01,
        OT_MULTIPLIERS: { ...DEFAULT_OT_MULTIPLIERS },
        WORKLOAD_PRESETS: {
            "Light Workload": {
                "Normal OT (Weekdays)": { minHours: 1, maxHours: 4 },
                "Off Day (Saturday)": { minHours: 2, maxHours: 5 },
                "Rest Day (Sunday)": { minHours: 2, maxHours: 6 },
                "Public Holiday": { minHours: 4, maxHours: 8 },
            },
            "Moderate Workload": {
                "Normal OT (Weekdays)": { minHours: 2, maxHours: 6 },
                "Off Day (Saturday)": { minHours: 3, maxHours: 8 },
                "Rest Day (Sunday)": { minHours: 4, maxHours: 8 },
                "Public Holiday": { minHours: 5, maxHours: 8 },
            },
            "Heavy Workload": {
                "Normal OT (Weekdays)": { minHours: 3, maxHours: 8 },
                "Off Day (Saturday)": { minHours: 5, maxHours: 8 },
                "Rest Day (Sunday)": { minHours: 6, maxHours: 8 },
                "Public Holiday": { minHours: 6, maxHours: 8 },
            },
        }
    };

    // --- GLOBAL STATE ---
    let db, auth, userId, isAuthReady = false;
    let isFirebaseEnabled = JSON.parse(localStorage.getItem("isFirebaseEnabled") || "true");
    let otEntries = [];
    let publicHolidays = [];
    let nextEntryId = 0;
    let currentAllocationStrategy = 'Target-Driven';
    let currentCalendarDate = new Date();
    let otDistributionChart = null;
    let wizardStep = 1;
    let mainDatePicker, wizardDatePicker, detailedEntryTimePicker;

    // --- DOM ELEMENT SELECTORS ---
    const DOMElements = {
        // Main Inputs
        basicSalaryInput: document.getElementById('basicSalary'),
        clearBasicSalaryBtn: document.querySelector('[aria-label="Clear Basic Monthly Salary"]'),
        targetOTPaySelect: document.getElementById('targetOTPaySelect'),
        customTargetOTPayInput: document.getElementById('customTargetOTPayInput'),
        clearCustomTargetOTPayBtn: document.getElementById('clearCustomTargetOTPayBtn'),
        minTotalOTHoursInput: document.getElementById('minTotalOTHours'),
        clearMinTotalOTHoursBtn: document.getElementById('clearMinTotalOTHoursBtn'),
        maxTotalOTHoursInput: document.getElementById('maxTotalOTHours'),
        clearMaxTotalOTHoursBtn: document.getElementById('clearMaxTotalOTHoursBtn'),
        minMaxHoursError: document.getElementById('minMaxHoursError'),
        dateRangeInput: document.getElementById('dateRangeInput'),
        dateRangeError: document.getElementById('dateRangeError'),
        setThisMonthBtn: document.getElementById('setThisMonthBtn'),
        publicHolidayDateInput: document.getElementById('publicHolidayDate'),
        setPublicHolidayTodayBtn: document.getElementById('setPublicHolidayTodayBtn'),
        addPublicHolidayDateBtn: document.getElementById('addPublicHolidayDateBtn'),
        publicHolidaysList: document.getElementById('publicHolidaysList'),
        otMultiplierInputsContainer: document.getElementById('otMultiplierInputs'),
        resetMultipliersBtn: document.getElementById('resetMultipliersBtn'),
        
        // Allocation
        allocationStrategySelect: document.getElementById('allocationStrategy'),
        allocationStrategyDescription: document.getElementById('allocationStrategyDescription'),
        targetDrivenStrategyGroup: document.getElementById('targetDrivenStrategyGroup'),
        targetAllocationStrategySelect: document.getElementById('targetAllocationStrategy'),
        targetAllocationStrategyDescription: document.getElementById('targetAllocationStrategyDescription'),
        workloadPresetSelect: document.getElementById('workloadPreset'),
        workloadPresetGroup: document.getElementById('workloadPresetGroup'),
        workloadPresetDescription: document.getElementById('workloadPresetDescription'),
        workloadPresetDetails: document.getElementById('workloadPresetDetails'),
        autoAllocateBtn: document.getElementById('autoAllocateBtn'),
        autoAllocateLoading: document.getElementById('autoAllocateLoading'),
        clearAllEntriesBtn: document.getElementById('clearAllEntriesBtn'),
        resetAndReallocateBtn: document.getElementById('resetAndReallocateBtn'),
        addHourBtn: document.getElementById('addHourBtn'),
        reduceHourBtn: document.getElementById('reduceHourBtn'),
        allocateCheckboxes: {
            workingDay: document.getElementById('allocateWorkingDay'),
            offDay: document.getElementById('allocateOffDay'),
            restDay: document.getElementById('allocateRestDay'),
            publicHoliday: document.getElementById('allocatePublicHoliday'),
        },

        // Calendar
        calendarContainer: document.getElementById('calendarContainer'),

        // Firebase & Data
        firebaseToggle: document.getElementById('firebaseToggle'),
        firebaseStatusMessage: document.getElementById('firebaseStatusMessage'),
        saveDataBtn: document.getElementById('saveDataBtn'),
        saveDataStatus: document.getElementById('saveDataStatus'),
        loadDataBtn: document.getElementById('loadDataBtn'),
        loadDataStatus: document.getElementById('loadDataStatus'),
        userIdDisplay: document.getElementById('userIdDisplay'),

        // Summary Sidebar
        resultsContainer: document.getElementById('results'),
        totalHoursByType: document.getElementById('totalHoursByType'),
        totalPayByCategory: document.getElementById('totalPayByCategory'),
        combinedOTPay: document.getElementById('combinedOTPay'),
        targetOTPayDisplay: document.getElementById('targetOTPayDisplay'),
        differenceFromTarget: document.getElementById('differenceFromTarget'),
        totalMonthlyOTHoursDisplay: document.getElementById('totalMonthlyOTHoursDisplay'),
        totalOTHoursRangeDisplay: document.getElementById('totalOTHoursRangeDisplay'),
        expectedSalaryPayDisplay: document.getElementById('expectedSalaryPayDisplay'),
        allocationStrategySummary: document.getElementById('allocationStrategySummary'),
        exportSummaryBtn: document.getElementById('exportSummaryBtn'),
        chartPlaceholder: document.getElementById('chartPlaceholder'),
        payProgress: {
            container: document.getElementById('payProgressContainer'),
            percentage: document.getElementById('payPercentage'),
            bar: document.getElementById('payProgressBar'),
        },
        hoursProgress: {
            container: document.getElementById('hoursProgressContainer'),
            percentage: document.getElementById('hoursPercentage'),
            bar: document.getElementById('hoursProgressBar'),
        },

        // Modals
        messageBox: {
            container: document.getElementById('messageBox'),
            title: document.getElementById('messageBoxTitle'),
            content: document.getElementById('messageBoxContent'),
            closeBtn: document.getElementById('messageBoxCloseBtn'),
            confirmBtn: document.getElementById('messageBoxConfirmBtn'),
            cancelBtn: document.getElementById('messageBoxCancelBtn'),
        },
        detailedEntryModal: {
            container: document.getElementById('addDetailedOTEntryModal'),
            title: document.getElementById('detailedEntryModalTitle'),
            dateInput: document.getElementById('detailedEntryDate'),
            hoursInput: document.getElementById('detailedEntryHours'),
            hoursError: document.getElementById('detailedEntryHoursError'),
            startTimeInput: document.getElementById('detailedEntryStartTime'),
            endTimeInput: document.getElementById('detailedEntryEndTime'),
            confirmBtn: document.getElementById('confirmDetailedEntryBtn'),
            cancelBtn: document.getElementById('cancelDetailedEntryBtn'),
            removeBtn: document.getElementById('removeDetailedEntryBtn'),
        },
        allocationChoiceModal: {
            container: document.getElementById('allocationChoiceModal'),
            clearAndAllocateBtn: document.getElementById('clearAndAllocateBtn'),
            fillRemainingBtn: document.getElementById('fillRemainingBtn'),
            cancelBtn: document.getElementById('cancelAllocationChoiceBtn'),
        },
        exportChoiceModal: {
            container: document.getElementById('exportChoiceModal'),
            exportTxtBtn: document.getElementById('exportTxtBtn'),
            exportCsvBtn: document.getElementById('exportCsvBtn'),
            exportHtmlBtn: document.getElementById('exportHtmlBtn'),
            cancelBtn: document.getElementById('cancelExportChoiceBtn'),
        },
        wizardModal: {
            container: document.getElementById('wizardModal'),
            basicSalaryInput: document.getElementById('wizardBasicSalary'),
            salaryError: document.getElementById('wizardSalaryError'),
            targetOTPaySelect: document.getElementById('wizardTargetOTPaySelect'),
            customTargetOTPayInput: document.getElementById('wizardCustomTargetOTPayInput'),
            clearCustomTargetOTPayBtn: document.getElementById('clearWizardCustomTargetOTPayBtn'),
            minHoursInput: document.getElementById('wizardMinHours'),
            maxHoursInput: document.getElementById('wizardMaxHours'),
            hoursError: document.getElementById('wizardHoursError'),
            dateRangeInput: document.getElementById('wizardDateRange'),
            dateError: document.getElementById('wizardDateError'),
            prevBtn: document.getElementById('wizardPrevBtn'),
            nextBtn: document.getElementById('wizardNextBtn'),
            finishBtn: document.getElementById('wizardFinishBtn'),
        },

        // Other UI
        loadingOverlay: document.getElementById('loadingOverlay'),
        toastContainer: document.getElementById('toastContainer'),
        collapsible: {
            howToUse: document.getElementById('howToUseContent'),
            publicHolidays: document.getElementById('publicHolidaysContent'),
            otMultiplier: document.getElementById('otMultiplierContent'),
        },
        quickSetupBtn: document.getElementById('quickSetupBtn'),
    };
    
    // --- UTILITY FUNCTIONS ---
    
    /** Debounce function to limit the rate at which a function gets called. */
    const debounce = (func, delay) => {
        let timeout;
        return function(...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), delay);
        };
    };

    /** Awaitable timeout */
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

    /** Show a custom modal message box. */
    function showMessageBox(title, content, type = 'info', onConfirm = null) {
        const { container, title: titleEl, content: contentEl, closeBtn, confirmBtn, cancelBtn } = DOMElements.messageBox;
        if (type === 'info') {
            showToast(content, 'info');
            return;
        }
        titleEl.textContent = title;
        contentEl.textContent = content;
        closeBtn.classList.add('hidden');
        confirmBtn.classList.add('hidden');
        cancelBtn.classList.add('hidden');

        if (type === 'confirm') {
            confirmBtn.onclick = () => { hideMessageBox(); if (onConfirm) onConfirm(); window.lastFocusedElement?.focus(); };
            cancelBtn.onclick = () => { hideMessageBox(); window.lastFocusedElement?.focus(); };
            confirmBtn.classList.remove('hidden');
            cancelBtn.classList.remove('hidden');
        } else {
            closeBtn.onclick = () => { hideMessageBox(); window.lastFocusedElement?.focus(); };
            closeBtn.classList.remove('hidden');
        }
        
        container.classList.remove('hidden');
        container.classList.add('show');
        window.lastFocusedElement = document.activeElement;
        confirmBtn.focus();
    }

    /** Hide the custom modal message box. */
    function hideMessageBox() {
        DOMElements.messageBox.container.classList.add('hidden');
        DOMElements.messageBox.container.classList.remove('show');
    }

    /** Show a toast notification. */
    function showToast(message, type = 'info', duration = 3000) {
        const toast = document.createElement('div');
        toast.classList.add('toast', type);
        toast.textContent = message;
        DOMElements.toastContainer.appendChild(toast);
        requestAnimationFrame(() => {
            toast.classList.add('show');
        });
        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove(), { once: true });
        }, duration);
    }
    
    /** Show or hide the main loading overlay. */
    function toggleLoadingOverlay(show) {
        if (show) {
            DOMElements.loadingOverlay.classList.remove('hidden');
            DOMElements.loadingOverlay.style.opacity = '0';
            requestAnimationFrame(() => {
                DOMElements.loadingOverlay.style.opacity = '1';
            });
        } else {
            DOMElements.loadingOverlay.style.opacity = '0';
            DOMElements.loadingOverlay.addEventListener('transitionend', function handler() {
                DOMElements.loadingOverlay.classList.add('hidden');
                DOMElements.loadingOverlay.removeEventListener('transitionend', handler);
            }, { once: true });
        }
    }

    /** Update status message for async operations like save/load. */
    function updateStatusMessage(element, message, type) {
        element.textContent = message;
        element.className = `status-message show ${type}`;
        element.setAttribute('aria-live', 'polite');
        if (type !== 'loading') {
            setTimeout(() => {
                element.classList.remove('show');
                element.removeAttribute('aria-live');
            }, 2000);
        }
    }

    // --- CORE LOGIC FUNCTIONS ---

    /** Get the target OT pay value from the form. */
    function getTargetOTPay() {
        const { targetOTPaySelect, customTargetOTPayInput } = DOMElements;
        if (targetOTPaySelect.value === 'custom') {
            const customValue = parseFloat(customTargetOTPayInput.value);
            return isNaN(customValue) ? null : customValue;
        }
        return targetOTPaySelect.value === '' ? null : parseFloat(targetOTPaySelect.value);
    }

    /** Get min/max hour values from the form. */
    function getMinMaxHours() {
        const { minTotalOTHoursInput, maxTotalOTHoursInput } = DOMElements;
        const minHours = parseFloat(minTotalOTHoursInput.value);
        const maxHours = parseFloat(maxTotalOTHoursInput.value);
        return {
            minHours: isNaN(minHours) ? null : minHours,
            maxHours: isNaN(maxHours) ? null : maxHours
        };
    }
    
    /** Validate that min hours is not greater than max hours. */
    function validateHourInputs() {
        const { minHours, maxHours } = getMinMaxHours();
        const { minMaxHoursError, minTotalOTHoursInput, maxTotalOTHoursInput } = DOMElements;
        minMaxHoursError.textContent = '';
        minTotalOTHoursInput.classList.remove('input-error');
        maxTotalOTHoursInput.classList.remove('input-error');
        if (minHours !== null && maxHours !== null && minHours > maxHours) {
            minMaxHoursError.textContent = 'Min hours cannot be greater than Max hours.';
            minTotalOTHoursInput.classList.add('input-error');
            maxTotalOTHoursInput.classList.add('input-error');
            return false;
        }
        return true;
    }

    /** Calculate the hourly rate based on basic salary. */
    function calculateHourlyRate(basicSalary) {
        if (basicSalary <= 0) return 0;
        return basicSalary / CONFIG.WORKING_DAYS_MONTHLY / CONFIG.STANDARD_WORK_HOURS_DAILY;
    }

    /** Calculate OT pay for a given number of hours and day type. */
    function calculateOTPay(hourlyRate, hours, dayType, dateStr) {
        let totalPay = 0;
        const finalDayType = isPublicHoliday(dateStr) ? "Public Holiday" : dayType;

        if (finalDayType === "Rest Day (Sunday)") {
            const normalRate = CONFIG.OT_MULTIPLIERS["Rest Day (Sunday)"];
            const excessRate = CONFIG.OT_MULTIPLIERS["Rest Day (Sunday) - After 8h"];
            if (hours <= 8) {
                totalPay = hourlyRate * normalRate * hours;
            } else {
                totalPay = (hourlyRate * normalRate * 8) + (hourlyRate * excessRate * (hours - 8));
            }
        } else {
            const multiplier = CONFIG.OT_MULTIPLIERS[finalDayType];
            if (typeof multiplier === 'undefined') {
                console.warn(`Unknown OT type or multiplier for type: ${finalDayType}`);
                return 0;
            }
            totalPay = hourlyRate * multiplier * hours;
        }
        return totalPay;
    }

    /** Format a number as currency. */
    const formatCurrency = (amount) => `RM ${amount.toFixed(2)}`;

    /** Calculate end time based on start time and duration. */
    function calculateEndTime(startTime, durationHours) {
        if (!startTime) return '';
        const [hours, minutes] = startTime.split(':').map(Number);
        let totalMinutes = (hours * 60) + minutes + (durationHours * 60);
        let endHours = Math.floor(totalMinutes / 60) % 24;
        let endMinutes = Math.round(totalMinutes % 60);
        if (endMinutes === 60) {
            endMinutes = 0;
            endHours = (endHours + 1) % 24;
        }
        return `${String(endHours).padStart(2, '0')}:${String(endMinutes).padStart(2, '0')}`;
    }
    
    /** Set a default start/end time for a new entry. */
    function setDefaultTime(entry) {
        const randomHour = Math.floor(Math.random() * 4) + 18; // 6 PM to 9 PM
        const randomMinuteOptions = [0, 15, 30, 45];
        const randomMinute = randomMinuteOptions[Math.floor(Math.random() * randomMinuteOptions.length)];
        const startTime = `${String(randomHour).padStart(2, '0')}:${String(randomMinute).padStart(2, '0')}`;
        entry.startTime = startTime;
        entry.endTime = calculateEndTime(entry.startTime, entry.hours);
    }
    
    /** Clear all OT entries from the state. */
    function clearAllEntries() {
        otEntries = [];
        nextEntryId = 0;
        renderCalendar();
    }
    
    /** Determine the type of day (Weekday, Off Day, Rest Day, etc.). */
    function getDayType(dateStr) {
        if (isPublicHoliday(dateStr)) return "Public Holiday";
        const date = new Date(dateStr);
        switch (date.getDay()) {
            case 0: return "Rest Day (Sunday)";
            case 6: return "Off Day (Saturday)";
            default: return "Normal OT (Weekdays)";
        }
    }

    /** Render the interactive calendar. */
    function renderCalendar() {
        const year = currentCalendarDate.getFullYear();
        const month = currentCalendarDate.getMonth();
        const firstDayOfMonth = new Date(year, month, 1).getDay();
        const daysInMonth = new Date(year, month + 1, 0).getDate();
        const today = new Date();
        const todayStr = (today.getFullYear() === year && today.getMonth() === month) ? formatDate(today) : null;

        let html = `
            <div class="calendar-header">
                <button id="prevMonthBtn" class="calendar-nav" aria-label="Previous month"><svg class="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                <h4>${currentCalendarDate.toLocaleString('default', { month: 'long' })} ${year}</h4>
                <button id="nextMonthBtn" class="calendar-nav" aria-label="Next month"><svg class="h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></button>
            </div>
            <div class="calendar-grid">
                ${["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"].map(day => `<div class="calendar-day-name">${day}</div>`).join('')}
        `;
        for (let i = 0; i < firstDayOfMonth; i++) {
            html += '<div class="calendar-day disabled"></div>';
        }
        for (let day = 1; day <= daysInMonth; day++) {
            const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const entry = otEntries.find(e => e.date === dateStr);
            let classes = 'calendar-day';
            if (dateStr === todayStr) classes += ' today';
            if (entry) classes += ' has-ot';
            html += `
                <div class="${classes}" data-date="${dateStr}">
                    <span>${day}</span>
                    ${entry ? `<span class="ot-hours">${entry.hours.toFixed(1)}h</span>` : ''}
                </div>
            `;
        }
        html += '</div>';
        DOMElements.calendarContainer.innerHTML = html;

        // Add event listeners after rendering
        document.getElementById('prevMonthBtn').addEventListener('click', () => { currentCalendarDate.setMonth(currentCalendarDate.getMonth() - 1); renderCalendar(); });
        document.getElementById('nextMonthBtn').addEventListener('click', () => { currentCalendarDate.setMonth(currentCalendarDate.getMonth() + 1); renderCalendar(); });
        DOMElements.calendarContainer.querySelector('.calendar-grid').addEventListener('click', (e) => {
            const dayElement = e.target.closest('.calendar-day');
            if (dayElement && !dayElement.classList.contains('disabled')) {
                openDetailedEntryModal(dayElement.dataset.date);
            }
        });
    }

    /** Confirm before clearing all entries. */
    function confirmClearAllEntries() {
        showMessageBox(
            'Confirm Clear All',
            'Are you sure you want to clear all daily OT entries? This action cannot be undone.',
            'confirm',
            () => {
                clearAllEntries();
                showToast('All entries cleared!', 'success');
                updateAllCalculations();
            }
        );
    }
    
    /** The main calculation and UI update function. */
    function updateAllCalculations() {
        const basicSalary = parseFloat(DOMElements.basicSalaryInput.value);
        const targetOTPay = getTargetOTPay();
        const { minHours, maxHours } = getMinMaxHours();
        const selectedDates = mainDatePicker.selectedDates;
        const startDateStr = selectedDates[0] ? formatDate(selectedDates[0]) : '';
        const endDateStr = selectedDates[1] ? formatDate(selectedDates[1]) : '';

        // Reset summary if salary is invalid
        if (isNaN(basicSalary) || basicSalary <= 0) {
            DOMElements.totalHoursByType.innerHTML = '';
            DOMElements.totalPayByCategory.innerHTML = '';
            DOMElements.combinedOTPay.textContent = formatCurrency(0);
            DOMElements.totalMonthlyOTHoursDisplay.textContent = '0.0 hours';
            DOMElements.expectedSalaryPayDisplay.textContent = formatCurrency(0);
            DOMElements.targetOTPayDisplay.textContent = 'N/A (No target set)';
            DOMElements.targetOTPayDisplay.classList.remove('text-green-600');
            DOMElements.targetOTPayDisplay.classList.add('text-gray-600');
            DOMElements.differenceFromTarget.textContent = 'N/A (No target set)';
            DOMElements.differenceFromTarget.classList.remove('text-green-600', 'text-red-600');
            DOMElements.differenceFromTarget.classList.add('text-gray-600');
            DOMElements.allocationStrategySummary.textContent = currentAllocationStrategy;
            DOMElements.totalOTHoursRangeDisplay.textContent = 'N/A';
            DOMElements.totalOTHoursRangeDisplay.classList.remove('text-green-600', 'text-red-600', 'text-orange-600');
            DOMElements.totalOTHoursRangeDisplay.classList.add('text-gray-600');
            renderDistributionChart([], []);
            updateProgressBars(0, 0, null, null, null);
            return;
        }

        const hourlyRate = calculateHourlyRate(basicSalary);
        let totalHoursByType = {};
        let totalPayByCategory = {};
        let totalCombinedOTPay = 0;
        let totalMonthlyOTHours = 0;
        DISPLAYABLE_OT_TYPES.forEach(type => {
            totalHoursByType[type] = 0;
            totalPayByCategory[type] = 0;
        });

        // Filter entries by date range for calculation
        otEntries.forEach(entry => {
            const entryDate = new Date(entry.date);
            const startDate = startDateStr ? new Date(startDateStr) : null;
            const endDate = endDateStr ? new Date(endDateStr) : null;

            if (startDate && endDate) {
                entryDate.setHours(0, 0, 0, 0);
                startDate.setHours(0, 0, 0, 0);
                endDate.setHours(0, 0, 0, 0);
                if (entryDate < startDate || entryDate > endDate) return;
            }

            const hours = parseFloat(entry.hours);
            if (isNaN(hours) || hours <= 0) return;

            const dayType = getDayType(entry.date);
            const pay = calculateOTPay(hourlyRate, hours, entry.type, entry.date);
            
            totalHoursByType[dayType] += hours;
            totalPayByCategory[dayType] += pay;
            totalCombinedOTPay += pay;
            totalMonthlyOTHours += hours;
        });

        const expectedSalary = basicSalary + totalCombinedOTPay;

        // Update Summary UI
        let hoursHtml = [];
        DISPLAYABLE_OT_TYPES.forEach(type => {
            if (totalHoursByType[type] > 0) {
                hoursHtml.push(`<span class="summary-inline-item">${type}: ${totalHoursByType[type].toFixed(1)}h</span>`);
            }
        });
        DOMElements.totalHoursByType.innerHTML = hoursHtml.join('');

        let payHtml = [];
        let chartLabels = [];
        let chartData = [];
        DISPLAYABLE_OT_TYPES.forEach(type => {
            if (totalPayByCategory[type] > 0) {
                payHtml.push(`<span class="summary-inline-item">${type}: ${formatCurrency(totalPayByCategory[type])}</span>`);
                chartLabels.push(type);
                chartData.push(totalPayByCategory[type]);
            }
        });
        DOMElements.totalPayByCategory.innerHTML = payHtml.join('');
        renderDistributionChart(chartLabels, chartData, ["#6366f1", "#ef4444", "#f59e0b", "#10b981", "#3b82f6"]);

        DOMElements.combinedOTPay.textContent = formatCurrency(totalCombinedOTPay);
        DOMElements.totalMonthlyOTHoursDisplay.textContent = `${totalMonthlyOTHours.toFixed(1)} hours`;
        DOMElements.expectedSalaryPayDisplay.textContent = formatCurrency(expectedSalary);
        DOMElements.allocationStrategySummary.textContent = currentAllocationStrategy;
        if (currentAllocationStrategy === 'Target-Driven') {
            const subStrategy = DOMElements.targetAllocationStrategySelect.options[DOMElements.targetAllocationStrategySelect.selectedIndex].text;
            DOMElements.allocationStrategySummary.textContent += ` (${subStrategy})`;
        }

        // Update Target-related UI
        if (targetOTPay === null || targetOTPay <= 0) {
            DOMElements.targetOTPayDisplay.textContent = 'N/A (No target set)';
            DOMElements.targetOTPayDisplay.classList.remove('text-green-600');
            DOMElements.targetOTPayDisplay.classList.add('text-gray-600');
            DOMElements.differenceFromTarget.textContent = 'N/A (No target set)';
            DOMElements.differenceFromTarget.classList.remove('text-green-600', 'text-red-600');
            DOMElements.differenceFromTarget.classList.add('text-gray-600');
        } else {
            DOMElements.targetOTPayDisplay.textContent = formatCurrency(targetOTPay);
            DOMElements.targetOTPayDisplay.classList.remove('text-gray-600');
            DOMElements.targetOTPayDisplay.classList.add('text-green-600');
            const difference = totalCombinedOTPay - targetOTPay;
            DOMElements.differenceFromTarget.textContent = formatCurrency(difference);
            if (difference >= 0) {
                DOMElements.differenceFromTarget.classList.remove('text-red-600', 'text-gray-600');
                DOMElements.differenceFromTarget.classList.add('text-green-600');
            } else {
                DOMElements.differenceFromTarget.classList.remove('text-green-600', 'text-gray-600');
                DOMElements.differenceFromTarget.classList.add('text-red-600');
            }
        }
        
        // Update Min/Max Hours UI
        DOMElements.totalOTHoursRangeDisplay.classList.remove('text-green-600', 'text-red-600', 'text-orange-600', 'text-gray-600');
        if (minHours !== null && maxHours !== null) {
            DOMElements.totalOTHoursRangeDisplay.textContent = `${minHours.toFixed(1)}h - ${maxHours.toFixed(1)}h`;
            if (totalMonthlyOTHours >= minHours && totalMonthlyOTHours <= maxHours) DOMElements.totalOTHoursRangeDisplay.classList.add('text-green-600');
            else if (totalMonthlyOTHours < minHours) DOMElements.totalOTHoursRangeDisplay.classList.add('text-orange-600');
            else DOMElements.totalOTHoursRangeDisplay.classList.add('text-red-600');
        } else if (minHours !== null) {
            DOMElements.totalOTHoursRangeDisplay.textContent = `Min: ${minHours.toFixed(1)}h`;
            if (totalMonthlyOTHours >= minHours) DOMElements.totalOTHoursRangeDisplay.classList.add('text-green-600');
            else DOMElements.totalOTHoursRangeDisplay.classList.add('text-orange-600');
        } else if (maxHours !== null) {
            DOMElements.totalOTHoursRangeDisplay.textContent = `Max: ${maxHours.toFixed(1)}h`;
            if (totalMonthlyOTHours <= maxHours) DOMElements.totalOTHoursRangeDisplay.classList.add('text-green-600');
            else DOMElements.totalOTHoursRangeDisplay.classList.add('text-red-600');
        } else {
            DOMElements.totalOTHoursRangeDisplay.textContent = 'N/A';
            DOMElements.totalOTHoursRangeDisplay.classList.add('text-gray-600');
        }

        updateProgressBars(totalCombinedOTPay, totalMonthlyOTHours, targetOTPay, minHours, maxHours);
    }
    
    /** Update the progress bars for pay and hours. */
    function updateProgressBars(currentPay, currentHours, targetPay, minHours, maxHours) {
        const { payProgress, hoursProgress } = DOMElements;

        // Pay Progress Bar
        if (targetPay !== null && targetPay > 0) {
            payProgress.container.classList.remove('hidden');
            const percentage = Math.min((currentPay / targetPay) * 100, 100);
            payProgress.percentage.textContent = `${Math.round(percentage)}%`;
            payProgress.bar.style.width = `${percentage}%`;
            payProgress.bar.style.backgroundColor = percentage >= 100 ? 'var(--success-green)' : 'var(--primary-indigo)';
        } else {
            payProgress.container.classList.add('hidden');
        }

        // Hours Progress Bar
        if (minHours !== null || maxHours !== null) {
            hoursProgress.container.classList.remove('hidden');
            let percentage = 0;
            let barColor = 'var(--primary-indigo)';

            if (minHours !== null && maxHours !== null) {
                if (currentHours < minHours) {
                    percentage = (currentHours / minHours) * 50;
                    barColor = 'var(--warning-orange)';
                } else {
                    percentage = 50 + ((currentHours - minHours) / (maxHours - minHours)) * 50;
                    barColor = 'var(--success-green)';
                }
            } else if (minHours !== null) {
                percentage = (currentHours / minHours) * 100;
                barColor = currentHours >= minHours ? 'var(--success-green)' : 'var(--warning-orange)';
            } else if (maxHours !== null) {
                percentage = (currentHours / maxHours) * 100;
                barColor = 'var(--primary-indigo)';
            }
            if (maxHours !== null && currentHours > maxHours) {
                percentage = 100;
                barColor = 'var(--danger-red)';
            }
            percentage = Math.max(0, Math.min(percentage, 100));
            hoursProgress.percentage.textContent = `${currentHours.toFixed(1)}h`;
            hoursProgress.bar.style.width = `${percentage}%`;
            hoursProgress.bar.style.backgroundColor = barColor;
        } else {
            hoursProgress.container.classList.add('hidden');
        }
    }

    /** Render the pie chart for OT distribution. */
    function renderDistributionChart(labels, data, colors) {
        const ctx = document.getElementById('otDistributionChart').getContext('2d');
        if (data.length === 0 || data.every(item => item === 0)) {
            if (otDistributionChart) {
                otDistributionChart.destroy();
                otDistributionChart = null;
            }
            DOMElements.chartPlaceholder.classList.remove('hidden');
            return;
        }
        DOMElements.chartPlaceholder.classList.add('hidden');

        if (otDistributionChart) {
            otDistributionChart.data.labels = labels;
            otDistributionChart.data.datasets[0].data = data;
            otDistributionChart.data.datasets[0].backgroundColor = colors;
            otDistributionChart.update();
        } else {
            otDistributionChart = new Chart(ctx, {
                type: 'pie',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'OT Pay (RM)',
                        data: data,
                        backgroundColor: colors,
                        hoverOffset: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'right', labels: { font: { family: 'Inter' } } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) label += ': ';
                                    if (context.parsed !== null) label += formatCurrency(context.parsed);
                                    return label;
                                }
                            },
                            bodyFont: { family: 'Inter' },
                            titleFont: { family: 'Inter' }
                        }
                    }
                }
            });
        }
    }
    
    /**
     * [ENHANCEMENT] Generate a random but realistic number of OT hours based on workload presets.
     * @param {string} dayType - The type of day (e.g., "Normal OT (Weekdays)").
     * @param {string} workloadPresetName - The name of the selected workload preset.
     * @returns {number} A random number of hours.
     */
    function getRandomHours(dayType, workloadPresetName) {
        const preset = CONFIG.WORKLOAD_PRESETS[workloadPresetName];
        const dayConfig = preset[dayType];

        if (!dayConfig) {
            // Fallback for day types not in preset (e.g., Public Holiday might not be in all)
            const rand = Math.random();
            if (rand < 0.30) return 2.0;
            if (rand < 0.55) return 4.0;
            if (rand < 0.70) return 1.0;
            return 3.0;
        }
        
        const { minHours, maxHours } = dayConfig;
        // Generate a random number between min and max, in 0.5 increments
        const range = (maxHours - minHours) * 2; // Number of half-hour slots
        const randomSlot = Math.floor(Math.random() * (range + 1));
        return minHours + (randomSlot / 2);
    }

    /** Add or update an OT entry. */
    function addOrUpdateEntry(date, hoursToAdd, dayType) {
        const existingEntryIndex = otEntries.findIndex(e => e.date === date);
        const hours = parseFloat(hoursToAdd.toFixed(1));

        if (hours <= CONFIG.ALLOCATION_PRECISION && existingEntryIndex === -1) {
            return; // Don't add entries with zero or negligible hours
        }

        if (existingEntryIndex !== -1) {
            otEntries[existingEntryIndex].hours += hours;
            otEntries[existingEntryIndex].endTime = calculateEndTime(otEntries[existingEntryIndex].startTime, otEntries[existingEntryIndex].hours);
        } else {
            const newEntry = {
                id: `ot-entry-${nextEntryId++}`,
                date: date,
                hours: hours,
                type: dayType,
                startTime: '',
                endTime: '',
                isNew: true
            };
            setDefaultTime(newEntry);
            otEntries.push(newEntry);
        }
    }

    /** Sort entries and resolve time overlaps. */
    function finalizeAndSortEntries() {
        otEntries.sort((a, b) => {
            const dateA = new Date(a.date);
            const dateB = new Date(b.date);
            if (dateA - dateB !== 0) return dateA - dateB;
            return parseInt(a.id.split('-')[2]) - parseInt(b.id.split('-')[2]);
        });
        
        let lastEndTimeByDate = {};
        otEntries.forEach(entry => {
            if (!entry.startTime || !entry.endTime) {
                setDefaultTime(entry, lastEndTimeByDate[entry.date] || null);
            }
            lastEndTimeByDate[entry.date] = entry.endTime;
        });
    }
    
    /** Update the UI based on the selected workload preset. */
    function updateWorkloadPresetUI() {
        const presetName = DOMElements.workloadPresetSelect.value;
        const presetDetails = CONFIG.WORKLOAD_PRESETS[presetName];
        let detailsHtml = `<strong>${presetName} Details:</strong><ul class="list-disc list-inside ml-4">`;
        DISPLAYABLE_OT_TYPES.forEach(type => {
            const config = presetDetails[type];
            if (config) {
                detailsHtml += `<li>${type}: ${config.minHours.toFixed(1)} - ${config.maxHours.toFixed(1)} hours</li>`;
            }
        });
        detailsHtml += '</ul>';
        DOMElements.workloadPresetDetails.innerHTML = detailsHtml;
        DOMElements.workloadPresetDescription.textContent = "This preset suggests daily OT hours for different day types to guide auto-allocation.";
    }

    /** Update the UI based on the main allocation strategy (Target vs Workload). */
    function updateAllocationStrategyUI() {
        const targetPay = getTargetOTPay();
        const isTargetDriven = targetPay !== null && targetPay > 0;
        
        DOMElements.allocationStrategySelect.value = isTargetDriven ? 'Target-Driven' : 'Workload-Driven';
        currentAllocationStrategy = DOMElements.allocationStrategySelect.value;
        DOMElements.allocationStrategySelect.disabled = true; // Always disable, driven by target pay

        if (isTargetDriven) {
            DOMElements.allocationStrategyDescription.textContent = 'The calculator will allocate hours to reach your "Target OT Pay".';
            DOMElements.targetDrivenStrategyGroup.classList.remove('hidden');
            DOMElements.workloadPresetGroup.classList.add('hidden');
            DOMElements.workloadPresetDetails.classList.add('hidden');
            updateTargetSubStrategyUI();
        } else {
            DOMElements.allocationStrategyDescription.textContent = 'Hours will be allocated for all days in your range according to the "Workload Preset".';
            DOMElements.targetDrivenStrategyGroup.classList.add('hidden');
            DOMElements.workloadPresetGroup.classList.remove('hidden');
            DOMElements.workloadPresetDetails.classList.remove('hidden');
        }
        updateAllCalculations();
    }
    
    /** Update the description for the selected target-driven sub-strategy. */
    function updateTargetSubStrategyUI() {
        const strategy = DOMElements.targetAllocationStrategySelect.value;
        let description = '';
        if (strategy === 'Balanced') {
            description = 'Randomly allocates hours across available days to meet the target.';
        } else if (strategy === 'Fastest Path') {
            description = 'Prioritizes high-pay days (e.g., Public Holidays) to reach the target with minimum hours.';
        } else if (strategy === 'Cheapest Path') {
            description = 'Prioritizes low-pay days (e.g., Weekdays) to maximize hours for the target.';
        }
        DOMElements.targetAllocationStrategyDescription.textContent = description;
    }
    
    /** Update the public holiday date picker's min/max based on the main date range. */
    function updatePublicHolidayPickerRange() {
        if (DOMElements.publicHolidayDateInput._flatpickr) {
            const selectedDates = mainDatePicker.selectedDates;
            const minDate = selectedDates[0] ? formatDate(selectedDates[0]) : undefined;
            const maxDate = selectedDates[1] ? formatDate(selectedDates[1]) : undefined;
            DOMElements.publicHolidayDateInput._flatpickr.set('minDate', minDate);
            DOMElements.publicHolidayDateInput._flatpickr.set('maxDate', maxDate);
            DOMElements.publicHolidayDateInput._flatpickr.redraw();
        }
    }

    /** Add a new public holiday. */
    function addPublicHoliday() {
        const dateStr = DOMElements.publicHolidayDateInput.value;
        const selectedDates = mainDatePicker.selectedDates;
        const startDateStr = selectedDates[0] ? formatDate(selectedDates[0]) : '';
        const endDateStr = selectedDates[1] ? formatDate(selectedDates[1]) : '';

        if (!dateStr) {
            return showToast('Please select a date for the public holiday.', 'error');
        }
        if (!startDateStr || !endDateStr || new Date(dateStr) < new Date(startDateStr) || new Date(dateStr) > new Date(endDateStr)) {
            return showToast('Public Holiday date must be within the OT Planning Date Range.', 'error');
        }
        if (publicHolidays.includes(dateStr)) {
            return showToast(`${dateStr} is already in the public holidays list.`, 'warning');
        }

        publicHolidays.push(dateStr);
        publicHolidays.sort();
        renderPublicHolidaysList();
        
        // Open the collapsible section if it's closed
        const header = document.querySelector('.collapsible-header[data-target="publicHolidaysContent"]');
        const icon = header ? header.querySelector('.collapsible-icon') : null;
        if (DOMElements.collapsible.publicHolidays.classList.contains('collapsed')) {
            toggleCollapsible(DOMElements.collapsible.publicHolidays, icon, true);
        }
        
        renderCalendar();
        updateAllCalculations();
        showToast('Public Holiday added successfully!', 'success');
    }

    /** Render the list of added public holidays. */
    function renderPublicHolidaysList() {
        const { publicHolidaysList } = DOMElements;
        publicHolidaysList.innerHTML = '';
        if (publicHolidays.length > 0) {
            publicHolidays.forEach(date => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center py-1';
                li.innerHTML = `
                    <span>${date}</span>
                    <button type="button" class="text-red-500 hover:text-red-700 ml-4" data-date="${date}" aria-label="Remove public holiday ${date}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" /></svg>
                    </button>
                `;
                publicHolidaysList.appendChild(li);
                li.querySelector('button').addEventListener('click', (e) => {
                    const dateToRemove = e.currentTarget.dataset.date;
                    showMessageBox(
                        'Confirm Removal',
                        `Are you sure you want to remove ${dateToRemove} from public holidays?`,
                        'confirm',
                        () => {
                            publicHolidays = publicHolidays.filter(d => d !== dateToRemove);
                            renderPublicHolidaysList();
                            renderCalendar();
                            updateAllCalculations();
                            showToast('Holiday Removed', 'success');
                        }
                    );
                });
            });
        } else {
            publicHolidaysList.innerHTML = '<li class="text-gray-500">No public holidays added yet.</li>';
        }
    }

    /** Check if a date is a public holiday. */
    const isPublicHoliday = (dateStr) => publicHolidays.includes(dateStr);

    /** Render the OT multiplier input fields. */
    function renderMultiplierInputs() {
        const { otMultiplierInputsContainer } = DOMElements;
        otMultiplierInputsContainer.innerHTML = '';
        DISPLAYABLE_OT_TYPES.forEach(type => {
            const div = document.createElement('div');
            div.className = 'input-group';
            const id = `multiplier-${type.replace(/[^A-Za-z0-9]/g, '')}`;
            div.innerHTML = `
                <label for="${id}">${type} Multiplier</label>
                <input type="number" id="${id}" value="${(CONFIG.OT_MULTIPLIERS[type] || 0).toFixed(2)}" min="0" step="0.1" class="shadow-sm">
            `;
            otMultiplierInputsContainer.appendChild(div);
            div.querySelector('input').addEventListener('input', debounce((e) => {
                const value = parseFloat(e.target.value);
                if (!isNaN(value) && value >= 0) {
                    CONFIG.OT_MULTIPLIERS[type] = value;
                    updateAllCalculations();
                }
            }, 150));
        });
    }

    /** Confirm before resetting multipliers to default. */
    function confirmResetMultipliers() {
        showMessageBox(
            'Confirm Reset Multipliers',
            'Are you sure you want to reset all OT multipliers to their default values?',
            'confirm',
            () => {
                Object.assign(CONFIG.OT_MULTIPLIERS, DEFAULT_OT_MULTIPLIERS);
                renderMultiplierInputs();
                showToast('OT multipliers have been reset to their default values.', 'success');
                updateAllCalculations();
            }
        );
    }
    
    // --- AUTO-ALLOCATION LOGIC (REFACTORED) ---

    /** [ENHANCEMENT] Checks if the user's goals are theoretically possible before allocation. */
    function preAllocationSanityCheck(context) {
        const { targetOTPay, maxHours, hourlyRate, availableDays } = context;

        if (targetOTPay === null || maxHours === null) {
            return; // No check needed if targets aren't set
        }

        // Simulate "Fastest Path" to find max possible pay within hour limit
        const daysByPayRate = [...availableDays].sort((a, b) => {
            const payA = calculateOTPay(hourlyRate, 1, getDayType(a.date), a.date);
            const payB = calculateOTPay(hourlyRate, 1, getDayType(b.date), b.date);
            return payB - payA;
        });

        let simulatedPay = 0;
        let simulatedHours = 0;
        for (const day of daysByPayRate) {
            const remainingHoursAllowed = maxHours - simulatedHours;
            if (remainingHoursAllowed <= 0) break;

            const hoursToAdd = Math.min(CONFIG.MAX_DAILY_OT_HOURS, remainingHoursAllowed);
            simulatedPay += calculateOTPay(hourlyRate, hoursToAdd, getDayType(day.date), day.date);
            simulatedHours += hoursToAdd;
        }

        if (targetOTPay > simulatedPay) {
            showToast(
                `Warning: Your pay target of ${formatCurrency(targetOTPay)} may be unreachable. The maximum possible pay with your settings is approx. ${formatCurrency(simulatedPay)}.`,
                'warning',
                6000
            );
        }
    }

    /** [REFACTORED] Handles the "Target-Driven" allocation strategy. */
    async function allocateForTargetPay(context) {
        const { hourlyRate, subStrategy } = context;
        let { payToReach, availableDays } = context;

        if (payToReach <= CONFIG.ALLOCATION_PRECISION) {
            showToast('Target OT pay has already been met with existing entries.', 'info');
            return;
        }

        if (subStrategy === 'Balanced') {
            availableDays = availableDays.sort(() => Math.random() - 0.5);
        } else {
            availableDays.sort((a, b) => {
                const multiplierA = CONFIG.OT_MULTIPLIERS[getDayType(a.date)];
                const multiplierB = CONFIG.OT_MULTIPLIERS[getDayType(b.date)];
                return subStrategy === 'Fastest Path' ? multiplierB - multiplierA : multiplierA - multiplierB;
            });
        }
        
        let iterations = 0;
        const maxIterations = availableDays.length * 20;
        while (payToReach > CONFIG.ALLOCATION_PRECISION && iterations < maxIterations && availableDays.length > 0) {
            iterations++;
            const dayIndex = (subStrategy === 'Balanced') ? Math.floor(Math.random() * availableDays.length) : 0;
            const day = availableDays[dayIndex];
            const dayType = getDayType(day.date);
            const existingHours = context.hoursByDate[day.date] || 0;
            
            let hoursLimit = CONFIG.MAX_DAILY_OT_HOURS - existingHours;
            if (context.maxHours !== null) {
                hoursLimit = Math.min(hoursLimit, context.maxHours - context.currentHours);
            }
            if (hoursLimit <= 0) {
                availableDays.splice(dayIndex, 1);
                continue;
            }

            let hoursToAdd = getRandomHours(dayType, context.workloadPreset); // Enhanced random hours
            hoursToAdd = Math.min(hoursToAdd, hoursLimit);
            
            let payForHours = calculateOTPay(hourlyRate, existingHours + hoursToAdd, dayType, day.date) - calculateOTPay(hourlyRate, existingHours, dayType, day.date);

            // [ENHANCEMENT] More precise adjustment to not overshoot the target
            if (payForHours > payToReach) {
                // Estimate pay per half-hour to make a more intelligent adjustment
                const payPerHalfHour = calculateOTPay(hourlyRate, existingHours + 0.5, dayType, day.date) - calculateOTPay(hourlyRate, existingHours, dayType, day.date);
                if (payPerHalfHour > 0) {
                    const overshootAmount = payForHours - payToReach;
                    const halfHoursToRemove = Math.floor(overshootAmount / payPerHalfHour);
                    hoursToAdd -= halfHoursToRemove * 0.5;
                }
                // Final check, reduce by one more if still over
                hoursToAdd = Math.max(0.5, hoursToAdd);
                payForHours = calculateOTPay(hourlyRate, existingHours + hoursToAdd, dayType, day.date) - calculateOTPay(hourlyRate, existingHours, dayType, day.date);
                if(payForHours > payToReach) {
                    hoursToAdd -= 0.5;
                }
            }


            if (hoursToAdd > 0) {
                payForHours = calculateOTPay(hourlyRate, existingHours + hoursToAdd, dayType, day.date) - calculateOTPay(hourlyRate, existingHours, dayType, day.date);
                addOrUpdateEntry(day.date, hoursToAdd, dayType);
                context.currentPay += payForHours;
                context.currentHours += hoursToAdd;
                context.hoursByDate[day.date] = (context.hoursByDate[day.date] || 0) + hoursToAdd;
                payToReach = context.targetOTPay - context.currentPay;
            }
            
            if (subStrategy !== 'Balanced') {
                availableDays.shift();
            }
            await sleep(0);
        }

        if (context.currentPay < context.targetOTPay) {
             showToast(`Target was not fully met (${formatCurrency(context.currentPay)}).`, 'warning');
        } else {
            showToast('Overtime hours allocated to meet your target.', 'success');
        }
    }

    /** [REFACTORED] Handles the "Workload-Driven" allocation strategy. */
    async function allocateForWorkload(context) {
        let { availableDays } = context;
        availableDays = availableDays.sort(() => Math.random() - 0.5);

        for (const day of availableDays) {
            if (context.maxHours !== null && context.currentHours >= context.maxHours - CONFIG.ALLOCATION_PRECISION) {
                showToast(`Max Total OT Hours (${context.maxHours.toFixed(1)}h) reached.`, 'info');
                break;
            }
            const existingHours = context.hoursByDate[day.date] || 0;
            const hoursLimit = CONFIG.MAX_DAILY_OT_HOURS - existingHours;
            const dayType = getDayType(day.date);
            
            if (hoursLimit <= 0) continue;
            
            let hoursToAdd = getRandomHours(dayType, context.workloadPreset); // Enhanced random hours
            hoursToAdd = Math.min(hoursToAdd, hoursLimit);
            if (context.maxHours !== null) {
                hoursToAdd = Math.min(hoursToAdd, context.maxHours - context.currentHours);
            }

            if (hoursToAdd > CONFIG.ALLOCATION_PRECISION) {
                addOrUpdateEntry(day.date, hoursToAdd, dayType);
                context.currentHours += hoursToAdd;
                context.hoursByDate[day.date] = (context.hoursByDate[day.date] || 0) + hoursToAdd;
            }
            await sleep(0);
        }
        showToast('Overtime hours allocated based on workload preset.', 'success');
    }

    /** [REFACTORED] Ensures the minimum hour requirement is met after primary allocation. */
    async function ensureMinimumHours(context) {
        if (context.minHours === null || context.currentHours >= context.minHours) return;

        showToast(`Topping up hours to meet minimum of ${context.minHours}h...`, 'info');
        await sleep(10);
        let topUpDays = context.getAvailableDays().filter(d => (context.hoursByDate[d.date] || 0) < CONFIG.MAX_DAILY_OT_HOURS);
        topUpDays.sort((a, b) => CONFIG.OT_MULTIPLIERS[getDayType(a.date)] - CONFIG.OT_MULTIPLIERS[getDayType(b.date)]); // Cheapest first

        let topUpIterations = 0;
        const maxTopUpIterations = topUpDays.length * 20; // Increased iterations
        while (context.currentHours < context.minHours && topUpIterations < maxTopUpIterations && topUpDays.length > 0) {
            topUpIterations++;
            const day = topUpDays[0];
            if ((context.hoursByDate[day.date] || 0) >= CONFIG.MAX_DAILY_OT_HOURS) {
                topUpDays.shift();
                continue;
            }
            const hoursToAdd = 0.5;
            addOrUpdateEntry(day.date, hoursToAdd, getDayType(day.date));
            context.currentHours += hoursToAdd;
            context.hoursByDate[day.date] = (context.hoursByDate[day.date] || 0) + hoursToAdd;
            topUpDays.push(topUpDays.shift()); // Rotate
            await sleep(0);
        }
        if (context.currentHours < context.minHours) {
            showToast(`Could not meet minimum hour target. Reached ${context.currentHours.toFixed(1)}h.`, 'warning');
        }
    }
    
    /** [REFACTORED] Main function to auto-allocate OT hours based on strategy. */
    async function runAutoAllocation(clearExistingInRange) {
        toggleLoadingOverlay(true);
        DOMElements.autoAllocateLoading.classList.remove('hidden');
        DOMElements.autoAllocateLoading.setAttribute('aria-live', 'polite');
        await sleep(10); // Allow UI to update

        try {
            const basicSalary = parseFloat(DOMElements.basicSalaryInput.value);
            const targetOTPay = getTargetOTPay();
            const { minHours, maxHours } = getMinMaxHours();
            const selectedDates = mainDatePicker.selectedDates;
            const startDateStr = selectedDates[0] ? formatDate(selectedDates[0]) : '';
            const endDateStr = selectedDates[1] ? formatDate(selectedDates[1]) : '';

            if (isNaN(basicSalary) || basicSalary <= 0 || !startDateStr || !endDateStr || new Date(startDateStr) > new Date(endDateStr) || !validateHourInputs()) {
                showToast('Please ensure all settings (Salary, Date Range, Hour Limits) are valid.', 'error');
                throw new Error("Invalid settings for allocation.");
            }

            let currentPay = 0;
            let currentHours = 0;
            const hoursByDate = {};
            
            if (clearExistingInRange) {
                clearAllEntries();
            } else {
                const startDate = new Date(startDateStr);
                const endDate = new Date(endDateStr);
                otEntries = otEntries.filter(entry => {
                    const entryDate = new Date(entry.date);
                    return entryDate < startDate || entryDate > endDate;
                });
                otEntries.forEach(entry => {
                    const hours = parseFloat(entry.hours);
                    if (!isNaN(hours) && hours > 0) {
                        currentPay += calculateOTPay(calculateHourlyRate(basicSalary), hours, entry.type, entry.date);
                        currentHours += hours;
                        hoursByDate[entry.date] = (hoursByDate[entry.date] || 0) + hours;
                    }
                });
            }

            if (maxHours !== null && currentHours >= maxHours - CONFIG.ALLOCATION_PRECISION) {
                showToast(`Max Total OT Hours (${maxHours.toFixed(1)}h) already met.`, 'warning');
                throw new Error("Max hours already met.");
            }
            
            const hourlyRate = calculateHourlyRate(basicSalary);
            const dateRange = getDateRangeArray(startDateStr, endDateStr);
            const allocationPrefs = {
                workingDay: DOMElements.allocateCheckboxes.workingDay.checked,
                offDay: DOMElements.allocateCheckboxes.offDay.checked,
                restDay: DOMElements.allocateCheckboxes.restDay.checked,
                publicHoliday: DOMElements.allocateCheckboxes.publicHoliday.checked,
            };

            const getAvailableDays = () => dateRange.filter(day => {
                if ((hoursByDate[day.date] || 0) >= CONFIG.MAX_DAILY_OT_HOURS) return false;
                const dayType = getDayType(day.date);
                if (dayType === "Public Holiday" && allocationPrefs.publicHoliday) return true;
                if (dayType === "Normal OT (Weekdays)" && allocationPrefs.workingDay) return true;
                if (dayType === "Off Day (Saturday)" && allocationPrefs.offDay) return true;
                if (dayType === "Rest Day (Sunday)" && allocationPrefs.restDay) return true;
                return false;
            });
            
            const allocationContext = {
                hourlyRate,
                targetOTPay,
                minHours,
                maxHours,
                currentPay,
                currentHours,
                hoursByDate,
                dateRange,
                allocationStrategy: currentAllocationStrategy,
                subStrategy: DOMElements.targetAllocationStrategySelect.value,
                workloadPreset: DOMElements.workloadPresetSelect.value,
                payToReach: targetOTPay !== null ? targetOTPay - currentPay : 0,
                availableDays: getAvailableDays(),
                getAvailableDays // Function to refresh the list
            };

            preAllocationSanityCheck(allocationContext);

            if (allocationContext.allocationStrategy === 'Target-Driven' && allocationContext.targetOTPay > 0) {
                await allocateForTargetPay(allocationContext);
            } else {
                await allocateForWorkload(allocationContext);
            }

            await ensureMinimumHours(allocationContext);

            finalizeAndSortEntries();
            otEntries.forEach(e => delete e.isNew);
            renderCalendar();
            updateAllCalculations();

        } catch (error) {
            if(error.message !== "Invalid settings for allocation." && error.message !== "Max hours already met.") {
                 console.error("Error during auto-allocation:", error);
                 showToast('An error occurred during auto-allocation. Please check console.', 'error');
            }
        } finally {
            toggleLoadingOverlay(false);
            DOMElements.autoAllocateLoading.classList.add('hidden');
            DOMElements.autoAllocateLoading.removeAttribute('aria-live');
        }
    }
    
    /** [NEW] Incrementally adds or removes 0.5 hours. */
    function adjustHours(amount) {
        const basicSalary = parseFloat(DOMElements.basicSalaryInput.value);
        if (isNaN(basicSalary) || basicSalary <= 0) {
            showToast('Please set a valid basic salary first.', 'error');
            return;
        }
        const hourlyRate = calculateHourlyRate(basicSalary);

        if (amount > 0) { // Adding hours
            const availableDays = getDateRangeArray(formatDate(mainDatePicker.selectedDates[0]), formatDate(mainDatePicker.selectedDates[1]))
                .map(day => ({ ...day, payRate: calculateOTPay(hourlyRate, 1, getDayType(day.date), day.date) }))
                .filter(day => {
                    const existingEntry = otEntries.find(e => e.date === day.date);
                    return (!existingEntry || existingEntry.hours < CONFIG.MAX_DAILY_OT_HOURS);
                })
                .sort((a, b) => a.payRate - b.payRate); // Sort by cheapest first

            if (availableDays.length > 0) {
                const dayToAdd = availableDays[0];
                addOrUpdateEntry(dayToAdd.date, amount, getDayType(dayToAdd.date));
                showToast(`Added 0.5h to ${dayToAdd.date}`, 'success');
            } else {
                showToast('No available days to add more hours.', 'warning');
                return;
            }
        } else { // Reducing hours
            const entriesWithHours = otEntries
                .filter(entry => entry.hours > 0)
                .map(entry => ({ ...entry, payRate: calculateOTPay(hourlyRate, 1, entry.type, entry.date) }))
                .sort((a, b) => b.payRate - a.payRate); // Sort by most expensive first

            if (entriesWithHours.length > 0) {
                const entryToReduce = entriesWithHours[0];
                const existingEntry = otEntries.find(e => e.id === entryToReduce.id);
                existingEntry.hours += amount; // amount is negative
                showToast(`Reduced 0.5h from ${existingEntry.date}`, 'success');
                if (existingEntry.hours <= 0) {
                    otEntries = otEntries.filter(e => e.id !== existingEntry.id);
                }
            } else {
                showToast('No overtime entries to reduce.', 'warning');
                return;
            }
        }
        renderCalendar();
        updateAllCalculations();
    }

    // --- [ENHANCED] EXPORT FUNCTIONS ---

    /** Show the export format choice modal. */
    function showExportChoiceModal() {
        DOMElements.exportChoiceModal.container.classList.remove('hidden');
        DOMElements.exportChoiceModal.container.classList.add('show');
        window.lastFocusedElement = document.activeElement;
        DOMElements.exportChoiceModal.exportTxtBtn.focus();
    }

    /** Hide the export format choice modal. */
    function hideExportChoiceModal() {
        DOMElements.exportChoiceModal.container.classList.add('hidden');
        DOMElements.exportChoiceModal.container.classList.remove('show');
        window.lastFocusedElement?.focus();
    }
    
    /** Export a text summary of the calculations. */
    function exportSummary() {
        try {
            const basicSalary = parseFloat(DOMElements.basicSalaryInput.value);
            const targetOTPay = getTargetOTPay();
            const { minHours, maxHours } = getMinMaxHours();
            const selectedDates = mainDatePicker.selectedDates;
            const startDateStr = selectedDates[0] ? formatDate(selectedDates[0]) : '';
            const endDateStr = selectedDates[1] ? formatDate(selectedDates[1]) : '';
            const hourlyRate = calculateHourlyRate(basicSalary);

            let summary = '--- OT Calculation Summary ---\n\n';
            summary += 'Employee Settings:\n';
            summary += `  Basic Monthly Salary: ${formatCurrency(basicSalary)}\n`;
            summary += `  Hourly Rate: RM ${hourlyRate.toFixed(2)}/hour\n\n`;
            summary += `OT Planning Period: ${startDateStr} to ${endDateStr}\n`;
            summary += `Allocation Strategy: ${currentAllocationStrategy}\n`;
            summary += `Target OT Pay: ${targetOTPay === null ? 'N/A' : formatCurrency(targetOTPay)}\n`;
            summary += `Total OT Hours Range: ${minHours !== null && maxHours !== null ? `${minHours.toFixed(1)}h - ${maxHours.toFixed(1)}h` : minHours !== null ? `Min: ${minHours.toFixed(1)}h` : maxHours !== null ? `Max: ${maxHours.toFixed(1)}h` : 'N/A'}\n\n`;
            summary += 'OT Multipliers Used:\n';
            for (const key in CONFIG.OT_MULTIPLIERS) {
                summary += `  ${key}: ${CONFIG.OT_MULTIPLIERS[key].toFixed(2)}x\n`;
            }
            summary += '\n';
            
            const entriesByDayType = {};
            const entriesInRange = otEntries.filter(entry => {
                const entryDate = new Date(entry.date);
                const startDate = startDateStr ? new Date(startDateStr) : null;
                const endDate = endDateStr ? new Date(endDateStr) : null;
                return !(startDate && endDate && (entryDate < startDate || entryDate > endDate));
            });

            entriesInRange.forEach(entry => {
                const dayType = getDayType(entry.date);
                if (!entriesByDayType[dayType]) entriesByDayType[dayType] = [];
                entriesByDayType[dayType].push(entry);
            });
            
            summary += 'Daily OT Entries:\n';
            if (entriesInRange.length === 0) {
                summary += '  No entries recorded for the selected range.\n';
            } else {
                DISPLAYABLE_OT_TYPES.forEach(type => {
                    if (entriesByDayType[type] && entriesByDayType[type].length > 0) {
                        summary += `\n--- ${type} ---\n`;
                        entriesByDayType[type].sort((a, b) => new Date(a.date) - new Date(b.date));
                        entriesByDayType[type].forEach(entry => {
                            summary += `  Date: ${entry.date}, Hours: ${entry.hours.toFixed(1)}h, Type: ${entry.type}`;
                            if (isPublicHoliday(entry.date)) summary += ' (Public Holiday)';
                            if (entry.startTime && entry.endTime) summary += `, Time: ${entry.startTime} - ${entry.endTime}`;
                            summary += '\n';
                        });
                    }
                });
            }
            summary += '\n';

            let totalHoursByType = {};
            let totalPayByCategory = {};
            let totalCombinedOTPay = 0;
            let totalMonthlyOTHours = 0;
            DISPLAYABLE_OT_TYPES.forEach(type => {
                totalHoursByType[type] = 0;
                totalPayByCategory[type] = 0;
            });
            entriesInRange.forEach(entry => {
                const hours = parseFloat(entry.hours);
                if (isNaN(hours) || hours <= 0) return;
                const dayType = getDayType(entry.date);
                const pay = calculateOTPay(hourlyRate, hours, entry.type, entry.date);
                totalHoursByType[dayType] += hours;
                totalPayByCategory[dayType] += pay;
                totalCombinedOTPay += pay;
                totalMonthlyOTHours += hours;
            });
            const expectedSalary = basicSalary + totalCombinedOTPay;

            summary += 'Total OT Hours by Type:\n';
            let hoursSummary = [];
            DISPLAYABLE_OT_TYPES.forEach(type => {
                if (totalHoursByType[type] > 0) hoursSummary.push(`${type}: ${totalHoursByType[type].toFixed(1)}h`);
            });
            summary += `  ${hoursSummary.join(', ')}\n\n`;

            summary += 'Total Pay per OT Category:\n';
            let paySummary = [];
            DISPLAYABLE_OT_TYPES.forEach(type => {
                if (totalPayByCategory[type] > 0) {
                    totalPayByCategory[type] = parseFloat(totalPayByCategory[type].toFixed(2));
                    paySummary.push(`${type}: ${formatCurrency(totalPayByCategory[type])}`);
                }
            });
            summary += `  ${paySummary.join(', ')}\n\n`;
            
            summary += `Combined OT Pay: ${formatCurrency(totalCombinedOTPay)}\n`;
            const difference = totalCombinedOTPay - (targetOTPay === null ? 0 : targetOTPay);
            summary += `Difference from Target: ${targetOTPay === null ? 'N/A (No target set)' : formatCurrency(difference)}\n`;
            summary += `Total Monthly OT Hours: ${totalMonthlyOTHours.toFixed(1)} hours\n`;
            summary += `Expected Salary Pay (Calculated): ${formatCurrency(expectedSalary)}\n\n`;
            summary += '--- End of Summary ---';

            const blob = new Blob([summary], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ot_summary.txt';
            document.body.appendChild(a);
            a.click();
            showToast('Your OT summary is being downloaded.', 'info');
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 250);
        } catch (error) {
            console.error('Error during export summary:', error);
            showToast('Failed to export summary. Please check your browser console for details.', 'error');
        }
    }

    /** Export data to a CSV file. */
    function exportToCSV() {
        try {
            const basicSalary = parseFloat(DOMElements.basicSalaryInput.value);
            const hourlyRate = calculateHourlyRate(basicSalary);
            const selectedDates = mainDatePicker.selectedDates;
            const startDateStr = selectedDates[0] ? formatDate(selectedDates[0]) : '';
            const endDateStr = selectedDates[1] ? formatDate(selectedDates[1]) : '';

            const headers = ['Date', 'Day', 'Type', 'Hours', 'StartTime', 'EndTime', 'Pay_RM'];
            let csvContent = headers.join(',') + '\r\n';

            const entriesInRange = otEntries.filter(entry => {
                const entryDate = new Date(entry.date);
                const startDate = startDateStr ? new Date(startDateStr) : null;
                const endDate = endDateStr ? new Date(endDateStr) : null;
                return !(startDate && endDate && (entryDate < startDate || entryDate > endDate));
            });
            
            entriesInRange.sort((a,b) => new Date(a.date) - new Date(b.date));

            entriesInRange.forEach(entry => {
                const date = new Date(entry.date + 'T00:00:00');
                const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'short' });
                const pay = calculateOTPay(hourlyRate, entry.hours, entry.type, entry.date);
                const row = [
                    entry.date,
                    dayOfWeek,
                    entry.type,
                    entry.hours.toFixed(2),
                    entry.startTime || '',
                    entry.endTime || '',
                    pay.toFixed(2)
                ];
                csvContent += row.join(',') + '\r\n';
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ot_summary.csv';
            document.body.appendChild(a);
            a.click();
            showToast('Your CSV file is being downloaded.', 'success');
             setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 250);
        } catch (error) {
            console.error('Error during CSV export:', error);
            showToast('Failed to export CSV. Please check console.', 'error');
        }
    }

    /** Generate and open a printable HTML report. */
    function exportToPrintableHTML() {
        try {
            const basicSalary = parseFloat(DOMElements.basicSalaryInput.value);
            const hourlyRate = calculateHourlyRate(basicSalary);
            const targetOTPay = getTargetOTPay();
            const { minHours, maxHours } = getMinMaxHours();
            const selectedDates = mainDatePicker.selectedDates;
            const startDateStr = selectedDates[0] ? formatDate(selectedDates[0]) : '';
            const endDateStr = selectedDates[1] ? formatDate(selectedDates[1]) : '';
            
            const entriesInRange = otEntries.filter(entry => {
                const entryDate = new Date(entry.date);
                const startDate = startDateStr ? new Date(startDateStr) : null;
                const endDate = endDateStr ? new Date(endDateStr) : null;
                return !(startDate && endDate && (entryDate < startDate || entryDate > endDate));
            });
            entriesInRange.sort((a,b) => new Date(a.date) - new Date(b.date));

            let totalCombinedOTPay = 0;
            let totalMonthlyOTHours = 0;
            entriesInRange.forEach(entry => {
                totalMonthlyOTHours += entry.hours;
                totalCombinedOTPay += calculateOTPay(hourlyRate, entry.hours, entry.type, entry.date);
            });
            const expectedSalary = basicSalary + totalCombinedOTPay;

            let tableRows = '';
            entriesInRange.forEach(entry => {
                 const date = new Date(entry.date + 'T00:00:00');
                 const dayOfWeek = date.toLocaleDateString('en-US', { weekday: 'long' });
                 const pay = calculateOTPay(hourlyRate, entry.hours, entry.type, entry.date);
                 tableRows += `
                    <tr>
                        <td>${entry.date}</td>
                        <td>${dayOfWeek}</td>
                        <td>${entry.type}</td>
                        <td>${entry.hours.toFixed(2)}</td>
                        <td>${entry.startTime || 'N/A'}</td>
                        <td>${entry.endTime || 'N/A'}</td>
                        <td>${formatCurrency(pay)}</td>
                    </tr>
                 `;
            });

            const htmlContent = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>OT Summary Report</title>
                    <style>
                        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; margin: 0; padding: 20px; background-color: #f8f9fa; color: #333; }
                        .container { max-width: 800px; margin: auto; background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
                        h1 { text-align: center; color: #1a202c; border-bottom: 2px solid #e2e8f0; padding-bottom: 10px; margin-bottom: 20px; }
                        .summary-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px 30px; margin-bottom: 30px; }
                        .summary-item { background-color: #f7fafc; padding: 15px; border-radius: 6px; border: 1px solid #e2e8f0; }
                        .summary-item strong { display: block; font-size: 0.9rem; color: #718096; margin-bottom: 5px; }
                        .summary-item span { font-size: 1.2rem; font-weight: 600; color: #2d3748; }
                        .total { background-color: #edf2f7; border-color: #cbd5e0; }
                        .total span { color: #4a5568; font-size: 1.4rem; }
                        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                        th, td { border: 1px solid #e2e8f0; padding: 12px; text-align: left; }
                        th { background-color: #f7fafc; font-weight: 600; }
                        tr:nth-child(even) { background-color: #f7fafc; }
                        @media print {
                            body { background-color: #fff; }
                            .container { box-shadow: none; border: 1px solid #ccc; }
                            .no-print { display: none; }
                        }
                    </style>
                </head>
                <body>
                    <div class="container">
                        <h1>Overtime Summary Report</h1>
                        <div class="summary-grid">
                            <div class="summary-item"><strong_>Report Period</strong><span>${startDateStr} to ${endDateStr}</span></div>
                            <div class="summary-item"><strong_>Basic Salary</strong><span>${formatCurrency(basicSalary)}</span></div>
                            <div class="summary-item total"><strong_>Total OT Hours</strong><span>${totalMonthlyOTHours.toFixed(2)} hours</span></div>
                            <div class="summary-item total"><strong_>Total OT Pay</strong><span>${formatCurrency(totalCombinedOTPay)}</span></div>
                            <div class="summary-item"><strong_>Target OT Pay</strong><span>${targetOTPay !== null ? formatCurrency(targetOTPay) : 'N/A'}</span></div>
                            <div class="summary-item total"><strong_>Total Expected Salary</strong><span>${formatCurrency(expectedSalary)}</span></div>
                        </div>
                        <h2>Detailed Entries</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Day</th>
                                    <th>Type</th>
                                    <th>Hours</th>
                                    <th>Start Time</th>
                                    <th>End Time</th>
                                    <th>Pay (RM)</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${tableRows || '<tr><td colspan="7" style="text-align:center;">No entries for this period.</td></tr>'}
                            </tbody>
                        </table>
                    </div>
                </body>
                </html>
            `;

            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            window.open(url, '_blank');
            showToast('Printable report is opening in a new tab.', 'success');
        } catch (error) {
            console.error('Error generating printable report:', error);
            showToast('Failed to generate report. Please check console.', 'error');
        }
    }

    /** Save user data to Firebase. */
    async function saveUserData() {
        if (!isFirebaseEnabled) {
            return showToast('Firebase functions (Save/Load) are currently disabled. Please enable them to use this feature.', 'warning');
        }
        if (isAuthReady && userId) {
            toggleLoadingOverlay(true);
            updateStatusMessage(DOMElements.saveDataStatus, 'Saving...', 'loading');
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');
                
                const entriesToSave = otEntries.map(entry => {
                    const { isNew, ...rest } = entry;
                    return rest;
                });
                const { minHours, maxHours } = getMinMaxHours();

                const dataToSave = {
                    basicSalary: parseFloat(DOMElements.basicSalaryInput.value),
                    targetOTPay: getTargetOTPay(),
                    minTotalOTHours: minHours,
                    maxTotalOTHours: maxHours,
                    startDate: mainDatePicker.selectedDates[0] ? formatDate(mainDatePicker.selectedDates[0]) : '',
                    endDate: mainDatePicker.selectedDates[1] ? formatDate(mainDatePicker.selectedDates[1]) : '',
                    workloadPreset: DOMElements.workloadPresetSelect.value,
                    allocationStrategy: DOMElements.allocationStrategySelect.value,
                    targetAllocationStrategy: DOMElements.targetAllocationStrategySelect.value,
                    otEntries: JSON.stringify(entriesToSave),
                    publicHolidays: JSON.stringify(publicHolidays),
                    customMultipliers: JSON.stringify(CONFIG.OT_MULTIPLIERS),
                    allocateWorkingDay: DOMElements.allocateCheckboxes.workingDay.checked,
                    allocateOffDay: DOMElements.allocateCheckboxes.offDay.checked,
                    allocateRestDay: DOMElements.allocateCheckboxes.restDay.checked,
                    allocatePublicHoliday: DOMElements.allocateCheckboxes.publicHoliday.checked,
                };
                
                await setDoc(userDocRef, dataToSave);
                otEntries = entriesToSave; // Remove isNew flag from local state
                renderCalendar();
                updateStatusMessage(DOMElements.saveDataStatus, 'Saved!', 'success');
                showToast('Data saved successfully!', 'success');
            } catch (error) {
                console.error("Error saving document: ", error);
                updateStatusMessage(DOMElements.saveDataStatus, 'Save Failed!', 'error');
                showToast('Failed to save data. Please try again.', 'error');
            } finally {
                toggleLoadingOverlay(false);
            }
        } else {
            showToast('Firebase authentication not ready. Please try again in a moment.', 'error');
        }
    }

    /** Load user data from Firebase. */
    async function loadUserData(isInitialLoad = false) {
        if (!isFirebaseEnabled) {
            if (!isInitialLoad) showToast('Firebase functions (Save/Load) are currently disabled. Please enable them to use this feature.', 'warning');
            return;
        }
        if (isAuthReady && userId) {
            if (!isInitialLoad) {
                toggleLoadingOverlay(true);
                updateStatusMessage(DOMElements.loadDataStatus, 'Loading...', 'loading');
            }
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const userDocRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');
                const docSnap = await getDoc(userDocRef);

                if (docSnap.exists()) {
                    const data = docSnap.data();
                    DOMElements.basicSalaryInput.value = parseFloat(data.basicSalary);
                    
                    const targetPay = data.targetOTPay;
                    if (targetPay === null) {
                        DOMElements.targetOTPaySelect.value = '';
                        DOMElements.customTargetOTPayInput.classList.add('hidden');
                        DOMElements.clearCustomTargetOTPayBtn.classList.add('hidden');
                        DOMElements.customTargetOTPayInput.value = '';
                    } else if (PREDEFINED_TARGET_PAYS.includes(targetPay)) {
                        DOMElements.targetOTPaySelect.value = targetPay.toFixed(2);
                        DOMElements.customTargetOTPayInput.classList.add('hidden');
                        DOMElements.clearCustomTargetOTPayBtn.classList.add('hidden');
                        DOMElements.customTargetOTPayInput.value = '';
                    } else {
                        DOMElements.targetOTPaySelect.value = 'custom';
                        DOMElements.customTargetOTPayInput.classList.remove('hidden');
                        DOMElements.clearCustomTargetOTPayBtn.classList.remove('hidden');
                        DOMElements.customTargetOTPayInput.value = targetPay.toFixed(2);
                    }
                    
                    DOMElements.minTotalOTHoursInput.value = data.minTotalOTHours !== null ? data.minTotalOTHours : '';
                    DOMElements.maxTotalOTHoursInput.value = data.maxTotalOTHours !== null ? data.maxTotalOTHours : '';
                    
                    if (data.startDate && data.endDate) {
                        mainDatePicker.setDate([data.startDate, data.endDate], true);
                    } else {
                        mainDatePicker.clear();
                    }

                    DOMElements.workloadPresetSelect.value = data.workloadPreset || 'Moderate Workload';
                    DOMElements.allocationStrategySelect.value = data.allocationStrategy || 'Target-Driven';
                    DOMElements.targetAllocationStrategySelect.value = data.targetAllocationStrategy || 'Balanced';
                    
                    otEntries = JSON.parse(data.otEntries || '[]');
                    publicHolidays = JSON.parse(data.publicHolidays || '[]');
                    Object.assign(CONFIG.OT_MULTIPLIERS, JSON.parse(data.customMultipliers || '{}'));
                    Object.assign(CONFIG.OT_MULTIPLIERS, { ...DEFAULT_OT_MULTIPLIERS, ...CONFIG.OT_MULTIPLIERS });
                    
                    DOMElements.allocateCheckboxes.workingDay.checked = data.allocateWorkingDay === undefined ? true : data.allocateWorkingDay;
                    DOMElements.allocateCheckboxes.offDay.checked = data.allocateOffDay === undefined ? true : data.allocateOffDay;
                    DOMElements.allocateCheckboxes.restDay.checked = data.allocateRestDay === undefined ? true : data.allocateRestDay;
                    DOMElements.allocateCheckboxes.publicHoliday.checked = data.allocatePublicHoliday === undefined ? true : data.allocatePublicHoliday;
                    
                    nextEntryId = otEntries.length > 0 ? Math.max(...otEntries.map(e => parseInt(e.id.split('-')[2]))) + 1 : 0;
                    
                    finalizeAndSortEntries();
                    renderCalendar();
                    renderPublicHolidaysList();
                    if (publicHolidays.length > 0) {
                         const header = document.querySelector('.collapsible-header[data-target="publicHolidaysContent"]');
                         const icon = header ? header.querySelector('.collapsible-icon') : null;
                         toggleCollapsible(DOMElements.collapsible.publicHolidays, icon, true);
                    }
                    renderMultiplierInputs();
                    updateAllCalculations();
                    
                    if (!isInitialLoad) {
                        updateStatusMessage(DOMElements.loadDataStatus, 'Loaded!', 'success');
                        showToast('Data loaded successfully!', 'success');
                    }
                } else {
                    // Set defaults if no saved data
                    const today = new Date();
                    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                    const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);
                    mainDatePicker.setDate([startOfMonth, endOfMonth], true);
                    DOMElements.basicSalaryInput.value = '3700.00';
                    DOMElements.workloadPresetSelect.value = 'Moderate Workload';
                    DOMElements.allocationStrategySelect.value = 'Target-Driven';
                    DOMElements.targetOTPaySelect.value = '';
                    DOMElements.customTargetOTPayInput.classList.add('hidden');
                    DOMElements.clearCustomTargetOTPayBtn.classList.add('hidden');
                    DOMElements.minTotalOTHoursInput.value = '';
                    DOMElements.maxTotalOTHoursInput.value = '';
                    DOMElements.allocateCheckboxes.workingDay.checked = true;
                    DOMElements.allocateCheckboxes.offDay.checked = true;
                    DOMElements.allocateCheckboxes.restDay.checked = true;
                    DOMElements.allocateCheckboxes.publicHoliday.checked = true;
                    renderPublicHolidaysList();
                    renderMultiplierInputs();
                    renderCalendar();
                    updateAllCalculations();
                    if (!isInitialLoad) updateStatusMessage(DOMElements.loadDataStatus, 'No saved data found.', 'info');
                }
            } catch (error) {
                console.error("Error loading document: ", error);
                if (!isInitialLoad) {
                    updateStatusMessage(DOMElements.loadDataStatus, 'Load Failed!', 'error');
                    showToast('Failed to load data. Please try again.', 'error');
                }
            } finally {
                updateWorkloadPresetUI();
                updateAllocationStrategyUI();
                if (!isInitialLoad) toggleLoadingOverlay(false);
            }
        } else {
            if (!isInitialLoad) showToast('Firebase authentication not ready. Please try again in a moment.', 'error');
        }
    }

    /** Format a date object to YYYY-MM-DD string. */
    const formatDate = (date) => date ? `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}` : '';

    /** Get an array of date objects within a range. */
    const getDateRangeArray = (startStr, endStr) => {
        const arr = [];
        let current = new Date(startStr + "T12:00:00"); // Use noon to avoid timezone issues
        const end = new Date(endStr + "T12:00:00");
        while (current <= end) {
            arr.push({ date: formatDate(current), dayOfWeek: current.getDay() });
            current.setDate(current.getDate() + 1);
        }
        return arr;
    };
    
    // --- MODAL-SPECIFIC FUNCTIONS ---

    /** Open the detailed entry modal for a specific date. */
    function openDetailedEntryModal(dateStr) {
        const { container, dateInput, hoursInput, startTimeInput, removeBtn, hoursError } = DOMElements.detailedEntryModal;
        const entry = otEntries.find(e => e.date === dateStr);
        
        dateInput.value = dateStr;
        hoursInput.value = entry ? entry.hours.toFixed(1) : '2.0';
        startTimeInput.value = entry ? entry.startTime : '18:00';
        
        if (entry) {
            removeBtn.classList.remove('hidden');
        } else {
            removeBtn.classList.add('hidden');
        }
        
        hoursError.textContent = '';
        hoursInput.classList.remove('input-error');

        if (!detailedEntryTimePicker) {
            detailedEntryTimePicker = flatpickr(startTimeInput, {
                enableTime: true,
                noCalendar: true,
                dateFormat: "H:i",
                time_24hr: true,
                minuteIncrement: 15,
                onChange: updateDetailedEntryEndTime,
            });
        }
        detailedEntryTimePicker.setDate(startTimeInput.value, false);
        updateDetailedEntryEndTime();
        
        container.classList.remove('hidden');
        container.classList.add('show');
        window.lastFocusedElement = document.activeElement;
        hoursInput.focus();
    }
    
    /** Hide the detailed entry modal. */
    function hideDetailedEntryModal() {
        DOMElements.detailedEntryModal.container.classList.add('hidden');
        DOMElements.detailedEntryModal.container.classList.remove('show');
        window.lastFocusedElement?.focus();
    }

    /** Update the end time in the detailed entry modal. */
    function updateDetailedEntryEndTime() {
        const { startTimeInput, hoursInput, endTimeInput } = DOMElements.detailedEntryModal;
        const startTime = startTimeInput.value;
        const hours = parseFloat(hoursInput.value);
        if (startTime && !isNaN(hours) && hours >= 0) {
            endTimeInput.value = calculateEndTime(startTime, hours);
        } else {
            endTimeInput.value = '';
        }
    }

    /** Save the details from the detailed entry modal. */
    function saveDetailedEntry() {
        const { dateInput, hoursInput, startTimeInput, endTimeInput, hoursError } = DOMElements.detailedEntryModal;
        const dateStr = dateInput.value;
        const hours = parseFloat(hoursInput.value);
        const startTime = startTimeInput.value;
        const endTime = endTimeInput.value;

        hoursError.textContent = '';
        hoursInput.classList.remove('input-error');
        let isValid = true;

        if (isNaN(hours) || hours < 0) {
            hoursError.textContent = 'Hours must be a positive number or zero.';
            hoursInput.classList.add('input-error');
            isValid = false;
        } else if (hours > CONFIG.MAX_DAILY_OT_HOURS) {
            hoursError.textContent = `Max hours per day is ${CONFIG.MAX_DAILY_OT_HOURS}.`;
            hoursInput.classList.add('input-error');
            isValid = false;
        }

        if (isValid) {
            const existingEntryIndex = otEntries.findIndex(e => e.date === dateStr);
            if (hours === 0) {
                if (existingEntryIndex !== -1) {
                    otEntries.splice(existingEntryIndex, 1);
                    showToast(`Entry for ${dateStr} removed.`, 'success');
                }
            } else {
                if (existingEntryIndex !== -1) {
                    otEntries[existingEntryIndex].hours = hours;
                    otEntries[existingEntryIndex].startTime = startTime;
                    otEntries[existingEntryIndex].endTime = endTime;
                    showToast(`Entry for ${dateStr} updated.`, 'success');
                } else {
                    const newEntry = {
                        id: `ot-entry-${nextEntryId++}`,
                        date: dateStr,
                        hours: hours,
                        type: getDayType(dateStr),
                        startTime: startTime,
                        endTime: endTime,
                        isNew: true
                    };
                    otEntries.push(newEntry);
                    showToast(`New entry for ${dateStr} added.`, 'success');
                }
            }
            renderCalendar();
            updateAllCalculations();
            hideDetailedEntryModal();
        }
    }

    /** Remove an entry via the detailed entry modal. */
    function removeDetailedEntry() {
        const dateStr = DOMElements.detailedEntryModal.dateInput.value;
        const existingEntryIndex = otEntries.findIndex(e => e.date === dateStr);
        if (existingEntryIndex !== -1) {
            otEntries.splice(existingEntryIndex, 1);
            showToast(`Entry for ${dateStr} removed.`, 'success');
        }
        renderCalendar();
        updateAllCalculations();
        hideDetailedEntryModal();
    }

    /** Show the allocation choice modal. */
    function showAllocationChoiceModal() {
        DOMElements.allocationChoiceModal.container.classList.remove('hidden');
        DOMElements.allocationChoiceModal.container.classList.add('show');
        window.lastFocusedElement = document.activeElement;
        DOMElements.allocationChoiceModal.clearAndAllocateBtn.focus();
    }

    /** Hide the allocation choice modal. */
    function hideAllocationChoiceModal() {
        DOMElements.allocationChoiceModal.container.classList.add('hidden');
        DOMElements.allocationChoiceModal.container.classList.remove('show');
        window.lastFocusedElement?.focus();
    }
    
    // --- FIREBASE & INITIALIZATION ---

    /** Initialize Firebase connection. */
    async function initializeFirebaseConnection() {
        if (!isFirebaseEnabled) {
            DOMElements.firebaseStatusMessage.textContent = 'Firebase (Save/Load) is currently disabled.';
            DOMElements.userIdDisplay.classList.add('hidden');
            return;
        }
        DOMElements.firebaseStatusMessage.textContent = 'Initializing Firebase...';
        try {
            const firebaseConfigStr = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
            const firebaseConfig = JSON.parse(firebaseConfigStr);
            if (Object.keys(firebaseConfig).length === 0) {
                throw new Error("Firebase configuration is empty or invalid.");
            }

            const app = initializeFirebaseApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    isAuthReady = true;
                    DOMElements.userIdDisplay.textContent = `User ID: ${userId}`;
                    DOMElements.userIdDisplay.classList.remove('hidden');
                    DOMElements.firebaseStatusMessage.textContent = 'Firebase enabled and connected.';
                    await loadUserData(true);
                } else {
                    try {
                        const anonUser = await signInAnonymously(auth);
                        userId = anonUser.user.uid;
                        isAuthReady = true;
                        DOMElements.userIdDisplay.textContent = `User ID: ${userId}`;
                        DOMElements.userIdDisplay.classList.remove('hidden');
                        DOMElements.firebaseStatusMessage.textContent = 'Firebase enabled and connected (anonymous).';
                        await loadUserData(true);
                    } catch (signInError) {
                        console.error("Anonymous sign-in failed:", signInError);
                        DOMElements.firebaseStatusMessage.textContent = 'Firebase connection failed. Check console.';
                        showToast('Failed to sign in. Data saving/loading may not work.', 'error');
                    }
                }
                updateDataButtonState();
            });
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            DOMElements.firebaseStatusMessage.textContent = `Firebase init failed: ${error.message}.`;
            showToast(`Firebase could not be initialized: ${error.message || 'Unknown error'}.`, 'error');
            isFirebaseEnabled = false;
            DOMElements.firebaseToggle.checked = false;
            localStorage.setItem('isFirebaseEnabled', 'false');
            updateDataButtonState();
            DOMElements.userIdDisplay.classList.add('hidden');
        }
    }

    /** Enable/disable Save/Load buttons based on auth state. */
    function updateDataButtonState() {
        const disabled = !isFirebaseEnabled || !isAuthReady;
        DOMElements.saveDataBtn.disabled = disabled;
        DOMElements.loadDataBtn.disabled = disabled;
    }

    /** Handle the Firebase enable/disable toggle. */
    async function handleFirebaseToggle() {
        isFirebaseEnabled = DOMElements.firebaseToggle.checked;
        localStorage.setItem('isFirebaseEnabled', isFirebaseEnabled);
        if (isFirebaseEnabled) {
            await initializeFirebaseConnection();
        } else {
            db = null; auth = null; userId = null; isAuthReady = false;
            DOMElements.userIdDisplay.classList.add('hidden');
            DOMElements.firebaseStatusMessage.textContent = 'Firebase (Save/Load) is now disabled.';
        }
        updateDataButtonState();
    }
    
    // --- WIZARD FUNCTIONS ---

    /** Show the quick setup wizard. */
    function showWizard() {
        wizardStep = 1;
        updateWizardView();
        DOMElements.wizardModal.container.classList.remove('hidden');
        DOMElements.wizardModal.container.classList.add('show');
    }

    /** Update the current view of the wizard. */
    function updateWizardView() {
        document.querySelectorAll('.wizard-step').forEach(step => step.classList.remove('active'));
        document.getElementById(`wizardStep${wizardStep}`).classList.add('active');
        document.querySelectorAll('.wizard-progress-dot').forEach(dot => {
            dot.classList.toggle('active', dot.dataset.step <= wizardStep);
        });
        DOMElements.wizardModal.prevBtn.classList.toggle('hidden', wizardStep === 1);
        DOMElements.wizardModal.nextBtn.classList.toggle('hidden', wizardStep === 3);
        DOMElements.wizardModal.finishBtn.classList.toggle('hidden', wizardStep !== 3);
    }
    
    /** Go to the next step in the wizard. */
    function wizardNext() {
        if (wizardStep === 1) {
            const salary = parseFloat(DOMElements.wizardModal.basicSalaryInput.value);
            if (isNaN(salary) || salary <= 0) {
                DOMElements.wizardModal.salaryError.textContent = 'Please enter a valid, positive salary.';
                return;
            }
            DOMElements.wizardModal.salaryError.textContent = '';
        } else if (wizardStep === 2) {
            const min = parseFloat(DOMElements.wizardModal.minHoursInput.value);
            const max = parseFloat(DOMElements.wizardModal.maxHoursInput.value);
            if (!isNaN(min) && !isNaN(max) && min > max) {
                DOMElements.wizardModal.hoursError.textContent = 'Min hours cannot be greater than Max hours.';
                return;
            }
            DOMElements.wizardModal.hoursError.textContent = '';
        }
        wizardStep++;
        updateWizardView();
    }

    /** Go to the previous step in the wizard. */
    function wizardPrev() {
        wizardStep--;
        updateWizardView();
    }

    /** Finish the wizard and apply settings. */
    function wizardFinish() {
        const selectedDates = wizardDatePicker.selectedDates;
        if (selectedDates.length < 2) {
            DOMElements.wizardModal.dateError.textContent = 'Please select a start and end date.';
            return;
        }
        DOMElements.wizardModal.dateError.textContent = '';

        // Apply settings from wizard to main form
        DOMElements.basicSalaryInput.value = DOMElements.wizardModal.basicSalaryInput.value;
        
        const wizardTargetSelect = DOMElements.wizardModal.targetOTPaySelect;
        const wizardTargetValue = wizardTargetSelect.value;
        let targetPay = null;
        if (wizardTargetValue === 'custom') {
            targetPay = DOMElements.wizardModal.customTargetOTPayInput.value;
        } else if (wizardTargetValue !== '') {
            targetPay = wizardTargetValue;
        }

        if (targetPay) {
            const isPreset = PREDEFINED_TARGET_PAYS.some(p => p.toFixed(2) === targetPay);
            if (isPreset) {
                DOMElements.targetOTPaySelect.value = targetPay;
                DOMElements.customTargetOTPayInput.classList.add('hidden');
                DOMElements.customTargetOTPayInput.value = '';
            } else {
                DOMElements.targetOTPaySelect.value = 'custom';
                DOMElements.customTargetOTPayInput.value = targetPay;
                DOMElements.customTargetOTPayInput.classList.remove('hidden');
                DOMElements.clearCustomTargetOTPayBtn.classList.remove('hidden');
            }
        } else {
            DOMElements.targetOTPaySelect.value = '';
            DOMElements.customTargetOTPayInput.classList.add('hidden');
            DOMElements.customTargetOTPayInput.value = '';
            DOMElements.clearCustomTargetOTPayBtn.classList.add('hidden');
        }

        DOMElements.minTotalOTHoursInput.value = DOMElements.wizardModal.minHoursInput.value;
        DOMElements.maxTotalOTHoursInput.value = DOMElements.wizardModal.maxHoursInput.value;
        mainDatePicker.setDate(selectedDates, true);

        // Hide wizard and update UI
        DOMElements.wizardModal.container.classList.add('hidden');
        DOMElements.wizardModal.container.classList.remove('show');
        localStorage.setItem('wizardCompleted', 'true');
        
        // Trigger UI updates
        updateAllocationStrategyUI(); // This will also call updateAllCalculations
        showToast('Setup complete!', 'success');
    }

    // --- UI HELPERS ---

    /** Toggle collapsible sections. */
    function toggleCollapsible(contentElement, iconElement, forceOpen = false) {
        if (forceOpen || contentElement.classList.contains('collapsed')) {
            contentElement.style.maxHeight = contentElement.scrollHeight + 'px';
            contentElement.classList.remove('collapsed');
            if (iconElement) iconElement.classList.add('rotated');
            contentElement.addEventListener('transitionend', function handler() {
                contentElement.style.maxHeight = 'none';
                contentElement.removeEventListener('transitionend', handler);
            }, { once: true });
        } else {
            contentElement.style.maxHeight = contentElement.scrollHeight + 'px';
            requestAnimationFrame(() => {
                contentElement.classList.add('collapsed');
                if (iconElement) iconElement.classList.remove('rotated');
                contentElement.style.maxHeight = '0';
            });
        }
    }
    
    /** Populate a select element with target pay options. */
    function populateTargetPaySelect(selectElement) {
        selectElement.innerHTML = '<option value="">No Target</option>';
        PREDEFINED_TARGET_PAYS.forEach(pay => {
            const option = document.createElement('option');
            option.value = pay.toFixed(2);
            option.textContent = `RM ${pay.toFixed(2)}`;
            selectElement.appendChild(option);
        });
        const customOption = document.createElement('option');
        customOption.value = 'custom';
        customOption.textContent = 'Other (Enter Manually)';
        selectElement.appendChild(customOption);
    }
    
    // --- EVENT LISTENERS SETUP ---
    function setupEventListeners() {
        // Debounced listeners for performance
        DOMElements.basicSalaryInput.addEventListener('input', debounce(updateAllCalculations, 150));
        DOMElements.customTargetOTPayInput.addEventListener('input', debounce(updateAllocationStrategyUI, 150));
        DOMElements.minTotalOTHoursInput.addEventListener('input', debounce(() => { validateHourInputs(); updateAllCalculations(); }, 150));
        DOMElements.maxTotalOTHoursInput.addEventListener('input', debounce(() => { validateHourInputs(); updateAllCalculations(); }, 150));

        // Standard listeners
        DOMElements.setThisMonthBtn.addEventListener('click', () => {
            const today = new Date();
            const start = new Date(today.getFullYear(), today.getMonth(), 1);
            const end = new Date(today.getFullYear(), today.getMonth() + 1, 0);
            mainDatePicker.setDate([start, end], true);
            showToast('Date range set to current month.', 'info');
        });
        
        DOMElements.autoAllocateBtn.addEventListener('click', showAllocationChoiceModal);
        DOMElements.allocationChoiceModal.clearAndAllocateBtn.addEventListener('click', () => { hideAllocationChoiceModal(); runAutoAllocation(true); });
        DOMElements.allocationChoiceModal.fillRemainingBtn.addEventListener('click', () => { hideAllocationChoiceModal(); runAutoAllocation(false); });
        DOMElements.allocationChoiceModal.cancelBtn.addEventListener('click', hideAllocationChoiceModal);

        DOMElements.resetAndReallocateBtn.addEventListener('click', () => {
            showMessageBox(
                'Confirm Reset & Re-allocate',
                'Are you sure you want to clear ALL existing OT entries and re-allocate from scratch? This action cannot be undone.',
                'confirm',
                () => runAutoAllocation(true)
            );
        });
        
        DOMElements.clearAllEntriesBtn.addEventListener('click', confirmClearAllEntries);
        
        // Export listeners
        DOMElements.exportSummaryBtn.addEventListener('click', showExportChoiceModal);
        DOMElements.exportChoiceModal.exportTxtBtn.addEventListener('click', () => { hideExportChoiceModal(); exportSummary(); });
        DOMElements.exportChoiceModal.exportCsvBtn.addEventListener('click', () => { hideExportChoiceModal(); exportToCSV(); });
        DOMElements.exportChoiceModal.exportHtmlBtn.addEventListener('click', () => { hideExportChoiceModal(); exportToPrintableHTML(); });
        DOMElements.exportChoiceModal.cancelBtn.addEventListener('click', hideExportChoiceModal);


        DOMElements.saveDataBtn.addEventListener('click', saveUserData);
        DOMElements.loadDataBtn.addEventListener('click', () => loadUserData(false));

        DOMElements.workloadPresetSelect.addEventListener('change', updateWorkloadPresetUI);
        DOMElements.targetAllocationStrategySelect.addEventListener('change', updateTargetSubStrategyUI);
        
        DOMElements.addPublicHolidayDateBtn.addEventListener('click', addPublicHoliday);
        DOMElements.resetMultipliersBtn.addEventListener('click', confirmResetMultipliers);
        
        // [NEW] Hour Adjustment Listeners
        DOMElements.addHourBtn.addEventListener('click', () => adjustHours(0.5));
        DOMElements.reduceHourBtn.addEventListener('click', () => adjustHours(-0.5));

        DOMElements.targetOTPaySelect.addEventListener('change', () => {
            if (DOMElements.targetOTPaySelect.value === 'custom') {
                DOMElements.customTargetOTPayInput.classList.remove('hidden');
                DOMElements.clearCustomTargetOTPayBtn.classList.remove('hidden');
                DOMElements.customTargetOTPayInput.focus();
            } else {
                DOMElements.customTargetOTPayInput.classList.add('hidden');
                DOMElements.clearCustomTargetOTPayBtn.classList.add('hidden');
                DOMElements.customTargetOTPayInput.value = '';
            }
            updateAllocationStrategyUI();
        });

        // Clear buttons
        DOMElements.clearBasicSalaryBtn.addEventListener('click', () => { DOMElements.basicSalaryInput.value = ''; updateAllCalculations(); showToast('Basic Salary cleared.', 'info'); });
        DOMElements.clearCustomTargetOTPayBtn.addEventListener('click', () => { DOMElements.customTargetOTPayInput.value = ''; updateAllocationStrategyUI(); showToast('Custom Target OT Pay cleared.', 'info'); });
        DOMElements.clearMinTotalOTHoursBtn.addEventListener('click', () => { DOMElements.minTotalOTHoursInput.value = ''; validateHourInputs(); updateAllCalculations(); showToast('Min Total OT Hours cleared.', 'info'); });
        DOMElements.clearMaxTotalOTHoursBtn.addEventListener('click', () => { DOMElements.maxTotalOTHoursInput.value = ''; validateHourInputs(); updateAllCalculations(); showToast('Max Total OT Hours cleared.', 'info'); });
        
        DOMElements.setPublicHolidayTodayBtn.addEventListener('click', () => {
            DOMElements.publicHolidayDateInput.value = formatDate(new Date());
            if (DOMElements.publicHolidayDateInput._flatpickr) {
                DOMElements.publicHolidayDateInput._flatpickr.setDate(DOMElements.publicHolidayDateInput.value, true);
            }
            showToast('Public Holiday date set to today.', 'info');
        });

        // Collapsible sections
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', () => {
                const targetId = header.dataset.target;
                toggleCollapsible(document.getElementById(targetId), header.querySelector('.collapsible-icon'));
            });
        });

        // Detailed Entry Modal listeners
        DOMElements.detailedEntryModal.confirmBtn.addEventListener('click', saveDetailedEntry);
        DOMElements.detailedEntryModal.cancelBtn.addEventListener('click', hideDetailedEntryModal);
        DOMElements.detailedEntryModal.removeBtn.addEventListener('click', removeDetailedEntry);
        DOMElements.detailedEntryModal.hoursInput.addEventListener('input', updateDetailedEntryEndTime);
        DOMElements.detailedEntryModal.startTimeInput.addEventListener('input', updateDetailedEntryEndTime);

        // Firebase toggle
        DOMElements.firebaseToggle.addEventListener('change', handleFirebaseToggle);
        
        // Allocation checkboxes
        Object.values(DOMElements.allocateCheckboxes).forEach(checkbox => {
            checkbox.addEventListener('change', updateAllCalculations);
        });

        // Wizard listeners
        DOMElements.quickSetupBtn.addEventListener('click', showWizard);
        DOMElements.wizardModal.nextBtn.addEventListener('click', wizardNext);
        DOMElements.wizardModal.prevBtn.addEventListener('click', wizardPrev);
        DOMElements.wizardModal.finishBtn.addEventListener('click', wizardFinish);
        DOMElements.wizardModal.targetOTPaySelect.addEventListener('change', () => {
            if (DOMElements.wizardModal.targetOTPaySelect.value === 'custom') {
                DOMElements.wizardModal.customTargetOTPayInput.classList.remove('hidden');
                DOMElements.wizardModal.clearCustomTargetOTPayBtn.classList.remove('hidden');
                DOMElements.wizardModal.customTargetOTPayInput.focus();
            } else {
                DOMElements.wizardModal.customTargetOTPayInput.classList.add('hidden');
                DOMElements.wizardModal.clearCustomTargetOTPayBtn.classList.add('hidden');
                DOMElements.wizardModal.customTargetOTPayInput.value = '';
            }
        });
        DOMElements.wizardModal.clearCustomTargetOTPayBtn.addEventListener('click', () => {
            DOMElements.wizardModal.customTargetOTPayInput.value = '';
            showToast('Wizard custom target pay cleared.', 'info');
        });
    }

    // --- INITIALIZATION ---
    async function runCalculatorApp() {
        DOMElements.firebaseToggle.checked = isFirebaseEnabled;
        await initializeFirebaseConnection();
        updateDataButtonState();
        
        setupEventListeners();

        // Initialize date pickers
        const today = new Date();
        const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
        const endOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);
        mainDatePicker = flatpickr(DOMElements.dateRangeInput, {
            mode: 'range',
            dateFormat: 'Y-m-d',
            defaultDate: [startOfMonth, endOfMonth],
            onChange: function(selectedDates, dateStr, instance) {
                if (selectedDates.length === 2) {
                    currentCalendarDate = new Date(selectedDates[0]);
                    renderCalendar();
                    updateAllCalculations();
                    updatePublicHolidayPickerRange();
                    DOMElements.dateRangeError.textContent = '';
                    DOMElements.dateRangeInput.classList.remove('input-error');
                }
            }
        });
        wizardDatePicker = flatpickr(DOMElements.wizardModal.dateRangeInput, {
            mode: 'range',
            dateFormat: 'Y-m-d',
            defaultDate: [startOfMonth, endOfMonth]
        });
        flatpickr(DOMElements.publicHolidayDateInput, { dateFormat: 'Y-m-d' });

        // Populate dynamic selects
        populateTargetPaySelect(DOMElements.targetOTPaySelect);
        populateTargetPaySelect(DOMElements.wizardModal.targetOTPaySelect);
        
        // Initial UI setup
        renderMultiplierInputs();
        DOMElements.collapsible.howToUse.classList.add('collapsed');
        DOMElements.collapsible.publicHolidays.classList.add('collapsed');
        DOMElements.collapsible.otMultiplier.classList.add('collapsed');

        // Initial render and calculation (will be handled by firebase load or defaults)
        if (!isFirebaseEnabled) {
            renderCalendar();
            updateAllocationStrategyUI();
            updateWorkloadPresetUI();
            updatePublicHolidayPickerRange();
        }

        if (localStorage.getItem('wizardCompleted') !== 'true') {
            showWizard();
        }
    }

    // --- START THE APP ---
    document.addEventListener('DOMContentLoaded', runCalculatorApp);

</script>
</body>
</html>
