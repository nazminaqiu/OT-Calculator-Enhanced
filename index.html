<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OT Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Flatpickr CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <!-- Flatpickr JS -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <style>
        /* Custom styles for Inter font and general body */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to allow scrolling */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .main-wrapper {
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            gap: 25px;
            max-width: 1200px;
            width: 100%;
        }
        @media (min-width: 1024px) { /* md breakpoint for two columns */
            .main-wrapper {
                flex-direction: row; /* Two columns on larger screens */
                align-items: flex-start;
            }
        }

        .form-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            flex-grow: 1; /* Allow it to grow and take available space */
            width: 100%; /* Default for smaller screens */
        }
        @media (min-width: 1024px) {
            .form-content {
                min-width: 600px; /* Ensure main content doesn't get too narrow */
            }
        }

        .summary-sidebar {
            background-color: #ffffff; /* Moved from .results-section */
            padding: 25px; /* Moved from .results-section */
            border-radius: 15px; /* Moved from .results-section */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Moved from .results-section */
            position: sticky;
            top: 20px;
            align-self: flex-start;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
            width: 100%; /* Default for smaller screens */
            min-width: 300px; /* Prevent it from becoming too narrow on smaller screens */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
        }
        @media (min-width: 1024px) {
            .summary-sidebar {
                width: 350px; /* Fixed width on large screens */
            }
        }

        .input-group label {
            font-weight: 600;
            color: #374151; /* Darker gray for labels */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db; /* Light gray border */
            border-radius: 8px;
            font-size: 1rem;
            color: #4b5563; /* Medium gray for input text */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Light indigo shadow */
        }
        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background-color: #6366f1; /* Indigo */
            color: #ffffff;
        }
        .btn-primary:hover {
            background-color: #4f46e5; /* Darker indigo */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e0e7ff; /* Light indigo */
            color: #4f46e5; /* Darker indigo text */
        }
        .btn-secondary:hover {
            background-color: #c7d2fe; /* Even lighter indigo */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444; /* Red */
            color: #ffffff;
        }
        .btn-danger:hover {
            background-color: #dc2626; /* Darker red */
            transform: translateY(-1px);
        }
        .results-section {
            /* Styles moved to .summary-sidebar, keeping only internal text styles */
            /* background-color: #f9fafb; */
            /* padding: 25px; */
            /* border-radius: 12px; */
            /* border: 1px solid #e5e7eb; */
        }
        .results-section h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937; /* Darkest gray */
            margin-bottom: 15px;
        }
        .results-section p {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #374151;
        }
        .results-section p strong {
            color: #111827; /* Even darker for emphasis */
        }
        .ot-entry-row {
            display: flex; /* Changed to flex */
            flex-direction: column; /* Stack children vertically */
            gap: 15px; /* Gap between the main sections (date, times, details) */
            align-items: stretch; /* Ensure children stretch to fill width */

            margin-bottom: 15px;
            padding: 15px;
            background-color: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        .ot-entry-row .input-group {
            margin-bottom: 0; /* Override default margin for compact rows */
        }
        .ot-entry-row .input-group label {
            font-size: 0.85rem; /* Smaller labels for row items */
            margin-bottom: 4px;
        }
        .ot-entry-row input, .ot-entry-row select {
            padding: 8px;
            font-size: 0.9rem;
        }
        .message-box {
            position: fixed;
            top: 50% ;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
            min-width: 300px;
            max-width: 90%;
            border: 1px solid #d1d5db;
        }
        .message-box h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 15px;
        }
        .message-box p {
            font-size: 1.1rem;
            color: #4b5563;
            margin-bottom: 25px;
        }
        .message-box-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .message-box button {
            background-color: #6366f1;
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .message-box button:hover {
            background-color: #4f46e5;
        }
        .message-box .btn-cancel {
            background-color: #e5e7eb;
            color: #4b5563;
        }
        .message-box .btn-cancel:hover {
            background-color: #d1d5db;
        }

        /* New modal for adding manual OT entry and date range */
        .manual-entry-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .manual-entry-modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            min-width: 350px;
            max-width: 90%;
            border: 1px solid #d1d5db;
        }
        .manual-entry-modal-content h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 15px;
        }
        .manual-entry-modal-content .input-group {
            margin-bottom: 20px;
        }
        .manual-entry-modal-content .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .form-content, .summary-sidebar {
                padding: 20px;
            }
            /* .ot-entry-row is already flex-col, so no change needed here */
            .ot-entry-row .remove-btn-container {
                display: flex;
                justify-content: flex-end; /* Align remove button to the right */
                margin-top: 10px;
            }
        }
        .ot-group-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f4f8; /* Lighter background for groups */
            border-radius: 10px;
            border: 1px solid #e2e8f0;
        }
        .ot-group-section h4 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #2d3748; /* Darker text for group headings */
            margin-bottom: 10px;
            border-bottom: 1px solid #cbd5e0;
            padding-bottom: 5px;
        }
        .loading-indicator {
            margin-left: 10px;
            font-size: 0.9em;
            color: #6366f1;
            font-weight: 500;
        }
        #userIdDisplay {
            font-size: 0.8em;
            color: #6b7280;
            text-align: right;
            margin-top: -15px;
            margin-bottom: 15px;
            word-break: break-all; /* Ensures long IDs wrap */
        }

        /* New highlight CSS */
        .highlight-new {
            animation: highlightFade 2s ease-out forwards;
        }

        @keyframes highlightFade {
            from { background-color: #e0f2fe; } /* Light blue */
            to { background-color: #f9fafb; } /* Original background */
        }

        .new-badge {
            background-color: #10b981; /* Green-500 */
            color: white;
            padding: 2px 8px;
            border-radius: 9999px; /* Full rounded */
            font-size: 0.75rem; /* text-xs */
            font-weight: 600; /* font-semibold */
            margin-left: 8px; /* ml-2 */
            display: inline-block;
            vertical-align: middle;
        }

        /* Styles for inline summary display */
        .summary-inline-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Space between items */
            font-size: 1.0rem;
            color: #374151;
            margin-bottom: 8px;
        }
        .summary-inline-group strong {
            display: block; /* Ensure the strong tag is on its own line */
            width: 100%; /* Take full width */
            margin-bottom: 4px;
        }
        .summary-inline-item {
            display: inline-block;
            padding: 4px 8px;
            background-color: #e0e7ff; /* Light indigo background */
            border-radius: 6px;
            color: #4f46e5; /* Darker indigo text */
            font-weight: 500;
        }

        /* Collapsible section styles */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px 0;
            border-bottom: 1px solid #cbd5e0;
            margin-bottom: 15px;
        }
        .collapsible-header h3 {
            margin-bottom: 0; /* Override default margin */
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .collapsible-content.collapsed {
            max-height: 0 !important; /* Use !important to ensure override */
        }
        .collapsible-icon {
            transition: transform 0.3s ease-out;
        }
        .collapsible-icon.rotated {
            transform: rotate(90deg);
        }

        /* Input validation styles */
        .input-error {
            border-color: #ef4444; /* Red border */
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2); /* Light red shadow */
        }
        .error-message {
            color: #ef4444; /* Red text */
            font-size: 0.85rem;
            margin-top: 4px;
        }

        /* New styles for loading/success indicators */
        .status-message {
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .status-message.show {
            opacity: 1;
        }
        .status-message.loading {
            color: #6366f1; /* Indigo */
        }
        .status-message.success {
            color: #10b981; /* Green */
        }
        .status-message.error {
            color: #ef4444; /* Red */
        }
        .no-entries-message {
            text-align: center;
            color: #6b7280;
            padding: 20px;
            border: 1px dashed #d1d5db;
            border-radius: 8px;
            margin-top: 15px;
        }

        /* Styles for clear input button */
        .input-with-clear {
            position: relative;
            display: flex;
            align-items: center;
        }
        .input-with-clear input {
            padding-right: 36px; /* Make space for the button */
        }
        .clear-input-btn {
            position: absolute;
            right: 8px;
            background: none;
            border: none;
            cursor: pointer;
            color: #9ca3af; /* Gray-400 */
            padding: 4px;
            border-radius: 50%;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .clear-input-btn:hover {
            background-color: #e5e7eb; /* Gray-200 */
            color: #4b5563; /* Gray-700 */
        }

        /* New styles for allocation choice modal */
        .allocation-choice-modal .modal-buttons button {
            width: 100%; /* Make buttons full width in modal */
        }
        .allocation-choice-modal .modal-buttons {
            flex-direction: column; /* Stack buttons vertically */
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="form-content">
            <h2 class="text-3xl font-extrabold text-center text-gray-900 mb-6">OT Calculator</h2>
            <div id="userIdDisplay" class="hidden"></div>

            <!-- How to Use Section (Collapsible) -->
            <div class="bg-blue-50 p-6 rounded-xl border border-blue-200 mb-6">
                <div class="collapsible-header" data-target="howToUseContent">
                    <h3 class="text-xl font-bold text-blue-800">How to Use This Calculator</h3>
                    <svg class="collapsible-icon h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="howToUseContent" class="collapsible-content">
                    <ul class="list-disc list-inside text-gray-700 space-y-2">
                        <li><strong>1. Employee Settings:</strong> Enter your basic monthly salary. Optionally, set a target OT pay.</li>
                        <li><strong>2. OT Planning Date Range:</strong> Define the period for which you want to calculate or plan your overtime.</li>
                        <li><strong>3. Public Holiday Management:</strong> Add any public holidays within your planning range. OT on these days will be calculated with a higher multiplier.</li>
                        <li><strong>4. OT Multiplier Settings:</strong> Adjust the overtime rates for different types of days (weekdays, off days, rest days, public holidays).</li>
                        <li><strong>5. Daily Overtime Entries:</strong>
                            <ul class="list-circle list-inside ml-4 mt-1 space-y-1">
                                <li>Choose an **Allocation Strategy**:
                                    <ul>
                                        <li>**Target-Driven:** The calculator will try to allocate hours to reach your "Target OT Pay" based on your chosen "Workload Preset".</li>
                                        <li>**Workload-Driven:** Hours will be allocated for all days in your range according to the "Workload Preset", regardless of a specific target pay.</li>
                                    </ul>
                                </li>
                                <li>Select a **Workload Preset** (Light, Moderate, Heavy) to guide auto-allocation.</li>
                                <li>Click "Auto Allocate Hours" to automatically generate entries. You will be prompted to either **clear existing entries** or **fill remaining hours**.</li>
                                <li>Click **"Reset & Re-allocate All"** to clear all entries and start a fresh auto-allocation.</li>
                                <li>Click "Add OT Entry" to manually add entries for specific dates.</li>
                                <li>You can edit hours, dates, and types for each entry.</li>
                                <li>"Save Data" and "Load Data" buttons allow you to persist your entries.</li>
                            </ul>
                        </li>
                        <li><strong>6. Calculate OT:</strong> Click this button to run the auto-allocation and see your total calculated OT pay and other summary details.</li>
                        <li><strong>7. Calculation Summary:</strong> Review your total hours, pay per category, combined OT pay, and expected total salary.</li>
                        <li><strong>8. Export Summary:</strong> Save a text file with a detailed breakdown of your calculations.</li>
                    </ul>
                </div>
            </div>

            <!-- Employee Settings -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Employee Settings</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                    <div class="input-group">
                        <label for="basicSalary">Basic Monthly Salary (RM)</label>
                        <div class="input-with-clear">
                            <input type="number" id="basicSalary" value="3700.00" min="0" step="0.01" class="shadow-sm">
                            <button type="button" class="clear-input-btn" aria-label="Clear Basic Monthly Salary">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="targetOTPaySelect">Target OT Pay (RM) (Optional)</label>
                        <select id="targetOTPaySelect" class="shadow-sm mb-2">
                            <option value="">No Target</option>
                            <!-- Options will be dynamically added by JavaScript -->
                            <option value="custom">Other (Enter Manually)</option>
                        </select>
                        <div class="input-with-clear">
                            <input type="number" id="customTargetOTPayInput" class="shadow-sm hidden" placeholder="Enter custom target pay">
                            <button type="button" class="clear-input-btn hidden" id="clearCustomTargetOTPayBtn" aria-label="Clear Custom Target OT Pay">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                <p class="text-sm text-gray-600 mt-4">
                    Working Schedule: 5 days/week, Saturday: Off Day, Sunday: Rest Day.
                    For payroll, employer uses 26 working days monthly.
                </p>
            </div>

            <!-- Date Range Container -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">OT Planning Date Range</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                    <div class="input-group">
                        <label for="startDate">Start Date</label>
                        <div class="flex items-center gap-2">
                            <input type="date" id="startDate" class="shadow-sm flex-grow" readonly>
                            <button type="button" id="setStartDateTodayBtn" class="btn btn-secondary p-2" aria-label="Set start date to today">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="endDate">End Date</label>
                        <div class="flex items-center gap-2">
                            <input type="date" id="endDate" class="shadow-sm flex-grow" readonly>
                            <button type="button" id="setEndDateTodayBtn" class="btn btn-secondary p-2" aria-label="Set end date to today">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Public Holiday Management (Collapsible) -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <div class="collapsible-header" data-target="publicHolidaysContent">
                    <h3 class="text-xl font-bold text-gray-800">Public Holiday Management</h3>
                    <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="publicHolidaysContent" class="collapsible-content">
                    <div class="flex flex-col sm:flex-row gap-4 mb-4">
                        <div class="input-group flex-grow">
                            <label for="publicHolidayDate">Add Public Holiday Date</label>
                            <div class="flex items-center gap-2">
                                <input type="date" id="publicHolidayDate" class="shadow-sm flex-grow">
                                <button type="button" id="setPublicHolidayTodayBtn" class="btn btn-secondary p-2" aria-label="Set public holiday date to today">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <button id="addPublicHolidayDateBtn" class="btn btn-secondary mt-auto" aria-label="Add public holiday">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                            </svg>
                            Add Holiday
                        </button>
                    </div>
                    <ul id="publicHolidaysList" class="list-disc list-inside ml-4 text-gray-700">
                        <!-- Public holidays will be listed here -->
                    </ul>
                </div>
            </div>

            <!-- OT Multiplier Settings (Collapsible) -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <div class="collapsible-header" data-target="otMultiplierContent">
                    <h3 class="text-xl font-bold text-gray-800">OT Multiplier Settings</h3>
                    <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="otMultiplierContent" class="collapsible-content">
                    <div id="otMultiplierInputs" class="grid grid-cols-1 md:grid-cols-2 gap-5 mb-4">
                        <!-- Multiplier inputs will be dynamically generated here -->
                    </div>
                    <button id="resetMultipliersBtn" class="btn btn-secondary" aria-label="Reset OT multipliers to default">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-8a1 1 0 011-1h3a1 1 0 110 2H4a1 1 0 01-1-1zm11 0a1 1 0 011-1h3a1 1 0 110 2h-3a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Reset to Default Multipliers
                    </button>
                </div>
            </div>

            <!-- Daily OT Entries -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Daily Overtime Entries</h3>
                <div class="input-group mb-4">
                    <label for="allocationStrategy">Allocation Strategy</label>
                    <select id="allocationStrategy" class="shadow-sm" aria-describedby="allocationStrategyDescription">
                        <option value="Target-Driven">Target-Driven (using Workload Presets)</option>
                        <option value="Workload-Driven">Workload-Driven (Fill All Days)</option>
                    </select>
                    <p id="allocationStrategyDescription" class="text-sm text-gray-600 mt-2"></p>
                </div>
                <div class="input-group mb-4">
                    <label for="workloadPreset">Workload Preset for Auto Allocation</label>
                    <select id="workloadPreset" class="shadow-sm" aria-describedby="workloadPresetDescription">
                        <option value="Moderate Workload">Moderate Workload</option>
                        <option value="Light Workload">Light Workload</option>
                        <option value="Heavy Workload">Heavy Workload</option>
                    </select>
                    <p id="workloadPresetDescription" class="text-sm text-gray-600 mt-2"></p>
                </div>
                <!-- Dynamic Workload Preset Details -->
                <div id="workloadPresetDetails" class="text-sm text-gray-700 mb-4 p-3 bg-gray-100 rounded-md border border-gray-200">
                    <!-- Details will be inserted here by JavaScript -->
                </div>

                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <button id="autoAllocateBtn" class="btn btn-secondary flex-grow" aria-label="Auto allocate hours">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-8a1 1 0 011-1h3a1 1 0 110 2H4a1 1 0 01-1-1zm11 0a1 1 0 011-1h3a1 1 0 110 2h-3a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Auto Allocate Hours
                        <span id="autoAllocateLoading" class="loading-indicator hidden" aria-live="polite">Allocating...</span>
                    </button>
                    <button id="resetAndReallocateBtn" class="btn btn-danger flex-grow" aria-label="Reset all and re-allocate">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.118a1 1 0 01-.293.707l-2.118 2.118A1 1 0 012 8v8a2 2 0 002 2h12a2 2 0 002-2V8a1 1 0 01-.293-.707l-2.118-2.118A1 1 0 0115 5.118V3a1 1 0 011-1h-2a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H4zm2 5V4h8v3H6zm-2 4h12V9H4v2zm0 2h12v3H4v-3z" clip-rule="evenodd" />
                        </svg>
                        Reset & Re-allocate All
                    </button>
                </div>

                <div id="otEntriesContainer">
                    <!-- OT entry rows will be added here by JavaScript -->
                    <p id="noEntriesMessage" class="no-entries-message hidden">No OT entries yet. Click "Add OT Entry" or "Auto Allocate Hours" to get started!</p>
                </div>
                <div class="flex flex-col sm:flex-row gap-4 mt-4">
                    <button id="addOTEntryBtn" class="btn btn-secondary flex-grow" aria-label="Add new OT entry">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        Add OT Entry
                    </button>
                    <button id="clearAllEntriesBtn" class="btn btn-danger flex-grow" aria-label="Clear all OT entries">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                    </svg>
                        Clear All Entries
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row gap-4 mt-4">
                    <button id="saveDataBtn" class="btn btn-primary flex-grow" aria-label="Save current data">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M7 3a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1V4a1 1 0 00-1-1H7z" />
                            <path fill-rule="evenodd" d="M18 8H2a2 2 0 00-2 2v8a2 2 0 002 2h16a2 2 0 002-2v-8a2 2 0 00-2-2zM4 13a1 1 0 011-1h10a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3z" clip-rule="evenodd" />
                        </svg>
                        Save Data
                        <span id="saveDataStatus" class="status-message" aria-live="polite"></span>
                    </button>
                    <button id="loadDataBtn" class="btn btn-secondary flex-grow" aria-label="Load saved data">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Load Data
                        <span id="loadDataStatus" class="status-message" aria-live="polite"></span>
                    </button>
                </div>
            </div>

            <button id="calculateBtn" class="btn btn-primary w-full mt-4" aria-label="Calculate total OT pay">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M2 11a1 1 0 011-1h14a1 1 0 011 1v4a1 1 0 01-1 1H3a1 1 0 01-1-1v-4z" />
                    <path fill-rule="evenodd" d="M14.5 4.5a3 3 0 11-6 0 3 3 0 016 0zm-6.293 3.293a1 1 0 011.414 0L10 8.586l.293-.293a1 1 0 011.414 0l.707.707a1 1 0 010 1.414L10 11.414l-.293.293a1 1 0 01-1.414 0l-.707-.707a1 1 0 010-1.414L9.414 9l-.293-.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                Calculate OT
            </button>
        </div>

        <!-- Results Section (Moved to a sticky sidebar) -->
        <div class="summary-sidebar">
            <div id="results" class="results-section">
                <h3 class="text-2xl font-bold text-gray-900 mb-4">Calculation Summary</h3>
                <!-- Changed to inline display -->
                <div class="summary-inline-group">
                    <strong>Total OT Hours by Type:</strong>
                    <span id="totalHoursByType" class="text-gray-700"></span>
                </div>
                <div class="summary-inline-group">
                    <strong>Total Pay per OT Category:</strong>
                    <span id="totalPayByCategory" class="text-gray-700"></span>
                </div>
                <!-- End of changes for inline display -->
                <p class="text-xl font-bold text-gray-900 mt-6">Combined OT Pay: <span id="combinedOTPay" class="text-indigo-600">RM 0.00</span></p>
                <p class="text-xl font-bold text-gray-900 mt-2">Target OT Pay: <span id="targetOTPayDisplay" class="text-green-600">RM 0.00</span></p>
                <p class="text-xl font-bold mt-2">Difference from Target: <span id="differenceFromTarget">RM 0.00</span></p>
                <p class="text-xl font-bold mt-2">Total Monthly OT Hours: <span id="totalMonthlyOTHoursDisplay">0.0 hours</span></p>
                <!-- New: Expected Salary Pay -->
                <p class="text-xl font-bold text-gray-900 mt-2">Expected Salary Pay: <span id="expectedSalaryPayDisplay" class="text-indigo-600">RM 0.00</span></p>
                <button id="exportSummaryBtn" class="btn btn-secondary mt-6" aria-label="Export OT summary to text file">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l2.293-2.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    Export Summary
                </button>
            </div>
        </div>
    </div>

    <!-- Message Box HTML -->
    <div id="messageBox" class="message-box hidden" role="dialog" aria-modal="true" aria-labelledby="messageBoxTitle" aria-describedby="messageBoxContent">
        <h4 id="messageBoxTitle"></h4>
        <p id="messageBoxContent"></p>
        <div class="message-box-buttons">
            <button id="messageBoxCancelBtn" class="btn btn-cancel hidden">Cancel</button>
            <button id="messageBoxConfirmBtn" class="hidden">Confirm</button>
            <button id="messageBoxCloseBtn">OK</button>
        </div>
    </div>

    <!-- New Manual Entry Modal HTML (Original, now unused by addOTEntryBtn) -->
    <div id="addManualEntryModal" class="manual-entry-modal hidden" role="dialog" aria-modal="true" aria-labelledby="manualEntryModalTitle">
        <div class="manual-entry-modal-content">
            <h4 id="manualEntryModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Add New OT Entry</h4>
            <div class="input-group">
                <label for="manualEntryDate">Select Date</label>
                <input type="date" id="manualEntryDate" class="shadow-sm">
                <div id="manualEntryDateError" class="error-message text-left"></div>
            </div>
            <div class="modal-buttons">
                <button id="cancelManualEntryBtn" class="btn btn-cancel">Cancel</button>
                <button id="confirmManualEntryBtn" class="btn btn-primary">Add Entry</button>
            </div>
        </div>
    </div>

    <!-- NEW: Detailed OT Entry Modal -->
    <div id="addDetailedOTEntryModal" class="manual-entry-modal hidden" role="dialog" aria-modal="true" aria-labelledby="detailedEntryModalTitle">
        <div class="manual-entry-modal-content">
            <h4 id="detailedEntryModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Add Detailed OT Entry</h4>
            <div class="input-group">
                <label for="detailedEntryDate">Select Date</label>
                <input type="date" id="detailedEntryDate" class="shadow-sm">
                <div id="detailedEntryDateError" class="error-message text-left"></div>
            </div>
            <div class="input-group">
                <label for="detailedEntryHours">Hours</label>
                <input type="number" id="detailedEntryHours" value="2.0" min="0.5" step="0.5" class="shadow-sm">
                <div id="detailedEntryHoursError" class="error-message text-left"></div>
            </div>
            <div class="input-group">
                <label for="detailedEntryStartTime">Start Time</label>
                <input type="time" id="detailedEntryStartTime" value="18:00" class="shadow-sm">
                <div id="detailedEntryStartTimeError" class="error-message text-left"></div>
            </div>
            <div class="input-group">
                <label for="detailedEntryEndTime">End Time (Calculated)</label>
                <input type="time" id="detailedEntryEndTime" class="shadow-sm" readonly>
            </div>
            <div class="modal-buttons">
                <button id="cancelDetailedEntryBtn" class="btn btn-cancel">Cancel</button>
                <button id="confirmDetailedEntryBtn" class="btn btn-primary">Add Entry</button>
            </div>
        </div>
    </div>

    <!-- New Date Range Modal HTML -->
    <div id="dateRangeModal" class="manual-entry-modal hidden" role="dialog" aria-modal="true" aria-labelledby="dateRangeModalTitle">
        <div class="manual-entry-modal-content">
            <h4 id="dateRangeModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Select OT Planning Date Range</h4>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                <div class="input-group">
                    <label for="startDateModalInput">Start Date</label>
                    <input type="date" id="startDateModalInput" class="shadow-sm">
                    <div id="startDateModalError" class="error-message text-left"></div>
                </div>
                <div class="input-group">
                    <label for="endDateModalInput">End Date</label>
                    <input type="date" id="endDateModalInput" class="shadow-sm">
                    <div id="endDateModalError" class="error-message text-left"></div>
                </div>
            </div>
            <div class="modal-buttons mt-4">
                <button id="cancelDateRangeBtn" class="btn btn-cancel">Cancel</button>
                <button id="confirmDateRangeBtn" class="btn btn-primary">Set Range</button>
            </div>
        </div>
    </div>

    <!-- NEW: Allocation Choice Modal -->
    <div id="allocationChoiceModal" class="manual-entry-modal hidden allocation-choice-modal" role="dialog" aria-modal="true" aria-labelledby="allocationChoiceModalTitle">
        <div class="manual-entry-modal-content">
            <h4 id="allocationChoiceModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Auto-Allocation Options</h4>
            <p class="text-gray-700 mb-6">How would you like to allocate overtime hours?</p>
            <div class="modal-buttons">
                <button id="clearAndAllocateBtn" class="btn btn-danger">
                    Clear All & Re-allocate
                </button>
                <button id="fillRemainingBtn" class="btn btn-primary mt-4">
                    Fill Remaining Hours
                </button>
                <button id="cancelAllocationChoiceBtn" class="btn btn-secondary mt-4">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // Flatpickr JS is now loaded globally via a separate <script> tag in the head.

        // --- Configuration Constants (Moved to global scope) ---
        const DEFAULT_OT_MULTIPLIERS = { // Store original defaults
            'Normal OT (Weekdays)': 1.5,
            'Off Day (Saturday)': 1.5,
            'Rest Day (Sunday) — 1st 8h': 0.5,
            'Rest Day (Sunday) — after 8h': 2.0,
            'Public Holiday': 2.0
        };

        const PREDEFINED_TARGET_PAYS = [
            1000.00,
            2000.00,
            3000.00,
            4000.00,
            5000.00
        ];

        const CONFIG = {
            WORKING_DAYS_MONTHLY: 26,
            STANDARD_WORK_HOURS_DAILY: 8,
            MAX_DAILY_OT_HOURS: 8, // Max 8 hours OT per day as per typical regulations
            ALLOCATION_PRECISION: 0.01, // Small value to handle floating point comparisons
            OT_MULTIPLIERS: { ...DEFAULT_OT_MULTIPLIERS }, // Current multipliers, can be changed by user
            // Define preferred allocation ranges for auto-allocation based on workload presets
            WORKLOAD_PRESETS: {
                'Light Workload': {
                    'Normal OT (Weekdays)': { minHours: 1, maxHours: 3 },
                    'Off Day (Saturday)': { minHours: 2, maxHours: 4 },
                    // Sunday 1st 8h now uses a range for flexibility
                    'Rest Day (Sunday) — 1st 8h': { minHours: 2, maxHours: 4 },
                    'Rest Day (Sunday) — after 8h': { minHours: 0.5, maxHours: 2 }
                },
                'Moderate Workload': {
                    'Normal OT (Weekdays)': { minHours: 2, maxHours: 4 },
                    'Off Day (Saturday)': { minHours: 3, maxHours: 5 },
                    // Sunday 1st 8h now uses a range for flexibility
                    'Rest Day (Sunday) — 1st 8h': { minHours: 4, maxHours: 6 },
                    'Rest Day (Sunday) — after 8h': { minHours: 1, maxHours: 3 }
                },
                'Heavy Workload': {
                    'Normal OT (Weekdays)': { minHours: 3, maxHours: 6 },
                    'Off Day (Saturday)': { minHours: 5, maxHours: 8 },
                    // Sunday 1st 8h now uses a range for flexibility
                    'Rest Day (Sunday) — 1st 8h': { minHours: 6, maxHours: 8 },
                    'Rest Day (Sunday) — after 8h': { minHours: 3, maxHours: 8 }
                }
            },
            // Define base allocation steps (these will be overridden by presets for min/max hours)
            ALLOCATION_STEPS: [
                { type: 'Normal OT (Weekdays)', days: [1, 2, 3, 4, 5] }, // Mon-Fri
                { type: 'Off Day (Saturday)', days: [6] }, // Saturday
                // Sunday 1st 8h now uses minHours/maxHours from presets, not a fixed 'hours: 8'
                { type: 'Rest Day (Sunday) — 1st 8h', days: [0] },
                { type: 'Rest Day (Sunday) — after 8h', days: [0] },
            ]
        };

        let db;
        let auth;
        let userId;
        let isAuthReady = false; // Flag to ensure Firestore operations wait for auth
        let manualDatePickerInstance; // Flatpickr instance for manual entry date picker (original, now unused)
        let publicHolidayDatePickerInstance; // Flatpickr instance for public holiday date picker
        let startDateModalPicker; // New: Flatpickr instance for start date in modal
        let endDateModalPicker;   // New: Flatpickr instance for end date in modal
        let detailedDatePickerInstance; // NEW: Flatpickr instance for detailed entry date picker
        let detailedStartTimePickerInstance; // NEW: Flatpickr instance for detailed entry start time

        // --- State Variables ---
        let otEntries = []; // Stores objects like { id, date, hours, type, startTime, endTime, isNew }
        let publicHolidays = []; // Stores public holiday dates as YYYY-MM-DD strings
        let entryCounter = 0; // To generate unique IDs for each entry row

        // --- DOM Elements (declared globally for easier access in functions) ---
        let basicSalaryInput;
        let clearBasicSalaryBtn; // New: Clear basic salary button
        let targetOTPaySelect;
        let customTargetOTPayInput;
        let clearCustomTargetOTPayBtn; // New: Clear custom target pay button
        let startDateInput;
        let endDateInput;
        let publicHolidayDateInput;
        let addPublicHolidayDateBtn;
        let publicHolidaysList;
        let otMultiplierInputsContainer;
        let resetMultipliersBtn;
        let allocationStrategySelect;
        let allocationStrategyDescription; // New: Description for allocation strategy
        let workloadPresetSelect;
        let workloadPresetDescription; // New: Description for workload preset
        let workloadPresetDetails;
        let otEntriesContainer;
        let noEntriesMessage;
        let addOTEntryBtn;
        let autoAllocateBtn;
        let autoAllocateLoading;
        let resetAndReallocateBtn; // NEW: Reset & Re-allocate All button
        let clearAllEntriesBtn;
        let calculateBtn;
        let saveDataBtn;
        let loadDataBtn;
        let resultsSection;
        let totalHoursByTypeElem;
        let totalPayByCategoryElem;
        let combinedOTPayElem;
        let targetOTPayDisplayElem;
        let differenceFromTargetElem;
        let totalMonthlyOTHoursDisplay;
        let expectedSalaryPayDisplay;
        let exportSummaryBtn;
        let userIdDisplay;

        let messageBox;
        let messageBoxTitle;
        let messageBoxContent;
        let messageBoxCloseBtn;
        let messageBoxConfirmBtn;
        let messageBoxCancelBtn;

        // Original manual entry modal (now unused by addOTEntryBtn)
        let addManualEntryModal;
        let manualEntryModalTitle;
        let manualEntryDateInput;
        let manualEntryDateError;
        let confirmManualEntryBtn;
        let cancelManualEntryBtn;

        // NEW: Detailed OT Entry Modal Elements
        let addDetailedOTEntryModal;
        let detailedEntryModalTitle;
        let detailedEntryDate;
        let detailedEntryDateError;
        let detailedEntryHours;
        let detailedEntryHoursError;
        let detailedEntryStartTime;
        let detailedEntryStartTimeError;
        let detailedEntryEndTime;
        let confirmDetailedEntryBtn;
        let cancelDetailedEntryBtn;

        let dateRangeModal; // New: Date Range Modal
        let dateRangeModalTitle; // New: Date Range Modal Title
        let startDateModalInput; // New: Input for start date in modal
        let endDateModalInput;   // New: Input for end date in modal
        let startDateModalError; // New: Error for start date in modal
        let endDateModalError;   // New: Error for end date in modal
        let confirmDateRangeBtn; // New: Confirm button for date range modal
        let cancelDateRangeBtn; // New: Cancel button for date range modal

        let allocationChoiceModal; // NEW: Allocation Choice Modal
        let clearAndAllocateBtn;   // NEW: Clear & Re-allocate button
        let fillRemainingBtn;      // NEW: Fill Remaining button
        let cancelAllocationChoiceBtn; // NEW: Cancel button for choice modal

        let setStartDateTodayBtn;
        let setEndDateTodayBtn;
        let setPublicHolidayTodayBtn;

        let collapsibleHeaders;
        let publicHolidaysContent;
        let otMultiplierContent;
        let howToUseContent; // New: How to Use content element

        let saveDataStatus;
        let loadDataStatus;


        // --- Utility Functions ---

        /**
         * Displays a custom message box.
         * @param {string} title - The title of the message box.
         * @param {string} message - The content message.
         * @param {string} type - 'info' (default) or 'confirm'.
         * @param {function} [confirmCallback] - Callback function for 'confirm' type when confirmed.
         */
        function showMessageBox(title, message, type = 'info', confirmCallback = null) {
            messageBoxTitle.textContent = title;
            messageBoxContent.textContent = message;

            // Reset buttons visibility
            messageBoxCloseBtn.classList.add('hidden');
            messageBoxConfirmBtn.classList.add('hidden');
            messageBoxCancelBtn.classList.add('hidden');

            if (type === 'confirm') {
                messageBoxConfirmBtn.classList.remove('hidden');
                messageBoxCancelBtn.classList.remove('hidden');
                messageBoxConfirmBtn.onclick = () => {
                    messageBox.classList.add('hidden');
                    if (confirmCallback) {
                        confirmCallback();
                    }
                    // Return focus to the element that triggered the modal
                    if (window.lastFocusedElement) {
                        window.lastFocusedElement.focus();
                    }
                };
                messageBoxCancelBtn.onclick = () => {
                    messageBox.classList.add('hidden');
                    // Return focus to the element that triggered the modal
                    if (window.lastFocusedElement) {
                        window.lastFocusedElement.focus();
                    }
                };
            } else { // 'info' type
                messageBoxCloseBtn.classList.remove('hidden');
                messageBoxCloseBtn.onclick = () => {
                    messageBox.classList.add('hidden');
                    // Return focus to the element that triggered the modal
                    if (window.lastFocusedElement) {
                        window.lastFocusedElement.focus();
                    }
                };
            }
            messageBox.classList.remove('hidden');
            // Store the currently focused element before showing the modal
            window.lastFocusedElement = document.activeElement;
            // Focus the first interactive element in the modal
            messageBoxConfirmBtn.focus();
        }

        /**
         * Displays a temporary status message next to a button.
         * @param {HTMLElement} statusElement - The span element to display the status.
         * @param {string} message - The message to display.
         * @param {string} type - 'loading', 'success', or 'error'.
         */
        function showStatusMessage(statusElement, message, type) {
            statusElement.textContent = message;
            statusElement.className = `status-message show ${type}`;
            // For accessibility, ensure the message is announced if it's dynamic status
            statusElement.setAttribute('aria-live', 'polite');
            if (type !== 'loading') {
                setTimeout(() => {
                    statusElement.classList.remove('show');
                    statusElement.removeAttribute('aria-live'); // Remove aria-live when hidden
                }, 2000); // Hide after 2 seconds for success/error
            }
        }

        /**
         * Populates the target OT pay dropdown with predefined values.
         */
        function populateTargetOTPayDropdown() {
            // Clear existing options except "No Target" and "Other"
            targetOTPaySelect.innerHTML = '<option value="">No Target</option>';
            PREDEFINED_TARGET_PAYS.forEach(amount => {
                const option = document.createElement('option');
                option.value = amount.toFixed(2);
                option.textContent = `RM ${amount.toFixed(2)}`;
                targetOTPaySelect.appendChild(option);
            });
            const otherOption = document.createElement('option');
            otherOption.value = 'custom';
            otherOption.textContent = 'Other (Enter Manually)';
            targetOTPaySelect.appendChild(otherOption);
        }

        /**
         * Handles the change event for the target OT pay dropdown.
         * Shows/hides the custom input field and its clear button.
         */
        function handleTargetOTPayChange() {
            if (targetOTPaySelect.value === 'custom') {
                customTargetOTPayInput.classList.remove('hidden');
                clearCustomTargetOTPayBtn.classList.remove('hidden');
                customTargetOTPayInput.focus();
            } else {
                customTargetOTPayInput.classList.add('hidden');
                clearCustomTargetOTPayBtn.classList.add('hidden');
                customTargetOTPayInput.value = ''; // Clear custom input when not in use
            }
            calculateAndDisplayResults(); // Recalculate on target change
        }

        /**
         * Retrieves the current target OT pay value, handling both dropdown and custom input.
         * @returns {number | null} The target OT pay as a number, or null if no target is set.
         */
        function getTargetOTPayValue() {
            if (targetOTPaySelect.value === 'custom') {
                const customValue = parseFloat(customTargetOTPayInput.value); // Corrected to customTargetOTPayInput
                return isNaN(customValue) ? null : customValue;
            } else if (targetOTPaySelect.value === '') {
                return null;
            } else {
                return parseFloat(targetOTPaySelect.value);
            }
        }

        /**
         * Calculates the basic hourly rate.
         * @param {number} monthlySalary - The employee's basic monthly salary.
         * @returns {number} The calculated basic hourly rate.
         */
        function calculateHourlyRate(monthlySalary) {
            if (monthlySalary <= 0) return 0;
            return monthlySalary / CONFIG.WORKING_DAYS_MONTHLY / CONFIG.STANDARD_WORK_HOURS_DAILY;
        }

        /**
         * Calculates the OT pay for a given entry.
         * @param {number} hourlyRate - The basic hourly rate.
         * @param {number} hours - The number of OT hours.
         * @param {string} type - The type of OT (e.g., 'Normal OT (Weekdays)').
         * @param {string} date - The date of the OT entry (YYYY-MM-DD).
         * @returns {number} The calculated OT pay.
         */
        function calculateOT(hourlyRate, hours, type, date) {
            let multiplier = CONFIG.OT_MULTIPLIERS[type];

            // Override multiplier if it's a public holiday and the type is not already Public Holiday
            if (isPublicHoliday(date) && type !== 'Public Holiday') {
                multiplier = CONFIG.OT_MULTIPLIERS['Public Holiday'];
            }
            
            if (multiplier === undefined) {
                console.warn(`Unknown OT type or multiplier for type: ${type}`);
                return 0; // Return 0 if multiplier is not found
            }

            return hourlyRate * multiplier * hours;
        }

        /**
         * Formats a number to RM currency string.
         * @param {number} amount - The amount to format.
         * @returns {string} Formatted currency string (e.g., "RM 123.45").
         */
        function formatCurrency(amount) {
            return `RM ${amount.toFixed(2)}`;
        }

        /**
         * Gets the current date in YYYY-MM-DD format.
         * @returns {string} The current date string.
         */
        function getTodayDateString() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        /**
         * Generates a random time (HH:MM) within a given hour range, at 15-minute intervals.
         * @param {number} minHour - The minimum hour (inclusive).
         * @param {number} maxHour - The maximum hour (exclusive).
         * @returns {string} The random time in "HH:MM" format.
         */
        function getRandomTime(minHour, maxHour) {
            const hours = Math.floor(Math.random() * (maxHour - minHour)) + minHour;
            const minutesOptions = [0, 15, 30, 45];
            const minutes = minutesOptions[Math.floor(Math.random() * minutesOptions.length)];
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        /**
         * Adds hours to a given time string (HH:MM) and returns a new time string.
         * Handles crossing midnight (though for OT, typically hours reset per day).
         * @param {string} startTimeStr - The start time in "HH:MM" format.
         * @param {number} hoursToAdd - The hours to add (can be decimal like 3.5).
         * @returns {string} The new time in "HH:MM" format.
         */
        function addHoursToTime(startTimeStr, hoursToAdd) {
            if (!startTimeStr) return ''; // Handle cases where start time is not set
            const [startHour, startMinute] = startTimeStr.split(':').map(Number);
            let totalMinutes = startHour * 60 + startMinute + (hoursToAdd * 60);

            let newHour = Math.floor(totalMinutes / 60) % 24; // % 24 to handle midnight crossing
            let newMinute = Math.round(totalMinutes % 60);

            // Handle cases like 59.9 minutes becoming 60, or 60.1 minutes becoming 60.
            if (newMinute === 60) {
                newMinute = 0;
                newHour = (newHour + 1) % 24;
            }

            return `${String(newHour).padStart(2, '0')}:${String(newMinute).padStart(2, '0')}`;
        }

        /**
         * Calculates and updates the suggested start and end times for a given OT entry.
         * This function modifies the entry object directly.
         * @param {Object} entry - The OT entry object to update.
         * @param {string} [prevEndTimeForDay] - Optional: The end time of a previous OT entry on the same day, for chaining.
         */
        function calculateSuggestedTimes(entry, prevEndTimeForDay = null) {
            let suggestedStartTime = '';

            if (entry.type === 'Normal OT (Weekdays)') {
                // Start anytime after 6 PM (18:00)
                suggestedStartTime = getRandomTime(18, 20); // Random between 6 PM and 7:45 PM
            } else if (entry.type === 'Off Day (Saturday)' || entry.type === 'Public Holiday' || entry.type === 'Rest Day (Sunday) — 1st 8h') {
                // Start anytime after 9 AM (09:00)
                suggestedStartTime = getRandomTime(9, 11); // Random between 9 AM and 10:45 AM
            } else if (entry.type === 'Rest Day (Sunday) — after 8h') {
                // If there's a preceding entry for the same day, use its end time
                if (prevEndTimeForDay) {
                    suggestedStartTime = prevEndTimeForDay;
                } else {
                    // Otherwise, start anytime after 5 PM (17:00)
                    suggestedStartTime = getRandomTime(17, 19); // Random between 5 PM and 6:45 PM
                }
            }

            entry.startTime = suggestedStartTime;
            entry.endTime = addHoursToTime(entry.startTime, entry.hours);
        }


        /**
         * Clears all existing OT entry rows from the UI and the internal state.
         * This is a helper function used by `clearDailyOTEntries` and `autoAllocateHours`.
         */
        function clearOTEntries() {
            otEntries = [];
            otEntriesContainer.innerHTML = '';
            entryCounter = 0; // Reset counter when clearing
            noEntriesMessage.classList.remove('hidden'); // Show no entries message
            // No longer calling updateManualEntryDatePicker as it's not used by the new modal
        }

        /**
         * Helper to determine the default OT type based on date (day of week).
         * This is used for grouping purposes in the UI.
         * @param {string} dateString - The date string (YYYY-MM-DD).
         * @returns {string} The default OT type for that date.
         */
        function getDefaultOTTypeForDate(dateString) {
            const date = new Date(dateString);
            const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

            if (isPublicHoliday(dateString)) {
                console.log(`Date ${dateString} is a Public Holiday. Setting type to 'Public Holiday'.`);
                return 'Public Holiday';
            } else if (dayOfWeek === 0) { // Sunday
                console.log(`Date ${dateString} is a Sunday. Setting type to 'Rest Day (Sunday) — 1st 8h'.`);
                return 'Rest Day (Sunday) — 1st 8h'; // Default to 1st 8h for grouping Sundays
            } else if (dayOfWeek === 6) { // Saturday
                console.log(`Date ${dateString} is a Saturday. Setting type to 'Off Day (Saturday)'.`);
                return 'Off Day (Saturday)';
            } else { // Weekday (Monday to Friday)
                console.log(`Date ${dateString} is a Weekday. Setting type to 'Normal OT (Weekdays)'.`);
                return 'Normal OT (Weekdays)';
            }
        }

        /**
         * Renders the OT entries from the `otEntries` array to the UI, grouped by OT type.
         * This function is responsible for updating the display, not modifying the `otEntries` array itself.
         */
        function renderOTEntries() {
            console.log("--- Starting renderOTEntries ---");
            console.log("otEntries at render time:", JSON.stringify(otEntries));

            otEntriesContainer.innerHTML = ''; // Clear current UI

            if (otEntries.length === 0) {
                noEntriesMessage.classList.remove('hidden');
                console.log("No entries found, showing 'No entries message'.");
            } else {
                noEntriesMessage.classList.add('hidden');
                console.log(`${otEntries.length} entries found, hiding 'No entries message'.`);
            }

            // Augment entries with a displayType for grouping
            const entriesWithDisplayType = otEntries.map(entry => {
                let resolvedDisplayType;
                if (isPublicHoliday(entry.date)) {
                    resolvedDisplayType = 'Public Holiday';
                } else {
                    // If not a public holiday, group based on the actual day of the week
                    resolvedDisplayType = getDefaultOTTypeForDate(entry.date);
                }
                return { ...entry, displayType: resolvedDisplayType };
            });

            // Group entries by their resolved displayType
            const groupedEntries = entriesWithDisplayType.reduce((acc, entry) => {
                if (!acc[entry.displayType]) {
                    acc[entry.displayType] = [];
                }
                acc[entry.displayType].push(entry);
                return acc;
            }, {});

            // Define a preferred order for displaying OT types, ensuring Public Holiday is included
            const preferredOrder = [
                'Normal OT (Weekdays)',
                'Off Day (Saturday)',
                'Rest Day (Sunday) — 1st 8h',
                'Rest Day (Sunday) — after 8h',
                'Public Holiday' // Ensure Public Holiday is in the display order
            ];

            // Render each group
            preferredOrder.forEach(displayType => { // Iterate over displayType
                if (groupedEntries[displayType] && groupedEntries[displayType].length > 0) {
                    const groupSection = document.createElement('div');
                    groupSection.classList.add('ot-group-section');

                    const groupTitle = document.createElement('h4');
                    groupTitle.textContent = displayType; // Use displayType for group title
                    groupSection.appendChild(groupTitle);

                    // Sort entries within each group by date
                    groupedEntries[displayType].sort((a, b) => new Date(a.date) - new Date(b.date));

                    groupedEntries[displayType].forEach(entry => {
                        const entryId = entry.id;
                        const newRow = document.createElement('div');
                        newRow.classList.add('ot-entry-row', 'flex', 'flex-col', 'gap-4');
                        newRow.setAttribute('data-id', entryId);

                        if (entry.isNew) {
                            newRow.classList.add('highlight-new');
                            setTimeout(() => {
                                newRow.classList.remove('highlight-new');
                                // Remove the isNew flag after highlighting
                                const entryIndex = otEntries.findIndex(e => e.id === entryId);
                                if (entryIndex !== -1) {
                                    delete otEntries[entryIndex].isNew;
                                }
                            }, 2000);
                        }

                        // Determine the type that should be selected in the dropdown
                        const typeToDisplayInDropdown = isPublicHoliday(entry.date) ? 'Public Holiday' : entry.type;

                        newRow.innerHTML = `
                            <!-- Date and Hours (1st line) -->
                            <div class="grid grid-cols-2 gap-4 items-end">
                                <div class="input-group">
                                    <label for="${entryId}-date">Date${entry.isNew ? '<span class="new-badge">New</span>' : ''}</label>
                                    <input type="date" id="${entryId}-date" value="${entry.date}" class="shadow-sm">
                                </div>
                                <div class="input-group">
                                    <label for="${entryId}-hours">Hours</label>
                                    <input type="number" id="${entryId}-hours" value="${entry.hours.toFixed(1)}" min="0" step="0.5" class="shadow-sm">
                                    <div id="${entryId}-hours-error" class="error-message"></div>
                                </div>
                            </div>

                            <!-- Start Time & End Time (2nd line) -->
                            <div class="flex gap-4">
                                <div class="input-group flex-1">
                                    <label for="${entryId}-start-time">Start Time</label>
                                    <input type="time" id="${entryId}-start-time" value="${entry.startTime}" class="shadow-sm"> <!-- Removed readonly -->
                                    <div id="${entryId}-start-time-error" class="error-message"></div>
                                </div>
                                <div class="input-group flex-1">
                                    <label for="${entryId}-end-time">End Time</label>
                                    <input type="time" id="${entryId}-end-time" value="${entry.endTime}" class="shadow-sm" readonly>
                                </div>
                            </div>

                            <!-- OT Type and Remove Button (3rd line) -->
                            <div class="grid grid-cols-[1.8fr_auto] gap-4 items-end"> <!-- Adjusted grid for OT Type and Remove -->
                                <div class="input-group">
                                    <label for="${entryId}-type">OT Type</label>
                                    <select id="${entryId}-type" class="shadow-sm">
                                        ${Object.keys(DEFAULT_OT_MULTIPLIERS).map(otType => `
                                            <option value="${otType}">${otType}</option>
                                        `).join('')}
                                    </select>
                                </div>
                                <div class="remove-btn-container flex justify-end">
                                    <button type="button" class="btn btn-danger btn-sm remove-ot-entry-btn" data-id="${entryId}" aria-label="Remove OT entry for ${entry.date}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        `;
                        groupSection.appendChild(newRow);

                        // Explicitly set the value of the select element after it's in the DOM
                        const typeSelect = newRow.querySelector(`#${entryId}-type`);
                        if (typeSelect) {
                            typeSelect.value = typeToDisplayInDropdown; // Set the value here
                        }

                        // Initialize Flatpickr for each date input in the rendered entries
                        const dateInput = newRow.querySelector(`#${entryId}-date`);
                        if (dateInput) {
                            // Disable all dates that are already used by other entries
                            const disabledDates = otEntries
                                .filter(e => e.id !== entryId) // Exclude the current entry's date
                                .map(e => e.date);

                            window.flatpickr(dateInput, {
                                dateFormat: "Y-m-d",
                                minDate: startDateInput.value, // Enforce planning range
                                maxDate: endDateInput.value,   // Enforce planning range
                                disable: disabledDates,
                                onChange: function(selectedDates, dateStr, instance) {
                                    // Manually trigger the updateOTEntry logic
                                    updateOTEntry(entryId, 'date', dateStr);
                                }
                            });
                        }

                        // Initialize Flatpickr for start time input
                        const startTimeInput = newRow.querySelector(`#${entryId}-start-time`);
                        if (startTimeInput) {
                            window.flatpickr(startTimeInput, {
                                enableTime: true,
                                noCalendar: true,
                                dateFormat: "H:i",
                                time_24hr: true,
                                minuteIncrement: 15,
                                onChange: function(selectedDates, dateStr, instance) {
                                    updateOTEntry(entryId, 'startTime', dateStr);
                                }
                            });
                        }

                        // Re-attach event listeners for hours and type
                        const hoursInput = newRow.querySelector(`#${entryId}-hours`);
                        const hoursError = newRow.querySelector(`#${entryId}-hours-error`);
                        hoursInput.addEventListener('input', (e) => {
                            const value = parseFloat(e.target.value);
                            // Validation for hours
                            if (isNaN(value) || value < 0) {
                                hoursInput.classList.add('input-error');
                                hoursError.textContent = 'Hours must be a positive number.';
                            } else if (value > CONFIG.MAX_DAILY_OT_HOURS) {
                                hoursInput.classList.add('input-error');
                                hoursError.textContent = `Max hours per day is ${CONFIG.MAX_DAILY_OT_HOURS}.`;
                            }
                            else {
                                hoursInput.classList.remove('input-error');
                                hoursError.textContent = '';
                                updateOTEntry(entryId, 'hours', value);
                            }
                        });
                        newRow.querySelector(`#${entryId}-type`).addEventListener('change', (e) => {
                            updateOTEntry(entryId, 'type', e.target.value);
                        });
                        newRow.querySelector(`.remove-ot-entry-btn`).addEventListener('click', () => removeOTEntryRow(entryId));
                    });
                    otEntriesContainer.appendChild(groupSection);
                }
            });
            console.log("--- Finished renderOTEntries ---");
        }


        /**
         * Adds a new OT entry to the `otEntries` array and then re-renders the UI.
         * This is for manual "Add OT Entry" button clicks.
         * @param {string} selectedDate - The date selected by the user from the modal.
         * @param {number} hours - The hours duration.
         * @param {string} startTime - The start time.
         * @param {string} endTime - The end time.
         */
        function addNewDetailedOTEntry(selectedDate, hours, startTime, endTime) {
            const newEntry = {
                id: `ot-entry-${entryCounter++}`, // Generate a new unique ID
                date: selectedDate,
                hours: hours,
                type: getDefaultOTTypeForDate(selectedDate), // Auto-set type based on date
                startTime: startTime,
                endTime: endTime,
                isNew: true     // Mark as new
            };
            otEntries.push(newEntry);
            renderOTEntries(); // Re-render the entire list
            calculateAndDisplayResults(); // Recalculate after adding an entry

            // Find the newly added row and scroll it into view with a highlight
            setTimeout(() => {
                const newRowElement = otEntriesContainer.querySelector(`[data-id="${newEntry.id}"]`);
                if (newRowElement) {
                    newRowElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100); // Small delay to ensure DOM update
        }

        /**
         * Updates an OT entry in the otEntries array and its corresponding DOM elements.
         * @param {string} id - The ID of the entry to update.
         * @param {string} field - The field to update ('date', 'hours', 'type', 'startTime').
         * @param {*} value - The new value for the field.
         */
        function updateOTEntry(id, field, value) {
            const index = otEntries.findIndex(entry => entry.id === id);
            if (index === -1) return;

            const originalEntry = { ...otEntries[index] }; // Clone for potential revert

            if (field === 'date') {
                const newDate = value;
                // Check for duplicate date across ALL entries (excluding the current one being edited)
                const isDuplicate = otEntries.some(entry =>
                    entry.id !== id && entry.date === newDate
                );

                if (isDuplicate) {
                    showMessageBox(
                        'Duplicate Date Warning',
                        `An OT entry already exists for ${newDate}. Each date can only have one OT entry. Please choose a different date or adjust the existing entry.`,
                        'info'
                    );
                    // Revert the date input in the UI
                    document.querySelector(`#${id}-date`).value = originalEntry.date;
                    return; // Prevent update
                }

                otEntries[index].date = newDate;
                otEntries[index].type = getDefaultOTTypeForDate(newDate); // Auto-adjust type based on new date
                console.log(`Updated entry ${id}: date=${otEntries[index].date}, type=${otEntries[index].type}`);

            } else if (field === 'hours') {
                otEntries[index].hours = parseFloat(value);
                // Recalculate end time if hours change
                otEntries[index].endTime = addHoursToTime(otEntries[index].startTime, otEntries[index].hours);
            } else if (field === 'startTime') {
                otEntries[index].startTime = value;
                // Recalculate end time if start time changes
                otEntries[index].endTime = addHoursToTime(otEntries[index].startTime, otEntries[index].hours);
            } else { // For 'type' field
                otEntries[index][field] = value;
            }

            // Always re-render the entire list if date or type changed, as this affects grouping
            // For hours/startTime changes, we also re-render to update endTime and ensure consistency
            renderOTEntries();
            calculateAndDisplayResults(); // Recalculate after any entry update
        }


        /**
         * Removes an OT entry from the otEntries array and then re-renders the UI.
         * @param {string} id - The ID of the entry to remove.
         */
        function removeOTEntryRow(id) {
            showMessageBox(
                'Confirm Removal',
                'Are you sure you want to remove this OT entry? This action cannot be undone.',
                'confirm',
                () => {
                    otEntries = otEntries.filter(entry => entry.id !== id);
                    renderOTEntries(); // Re-render the entire list after removal
                    calculateAndDisplayResults(); // Recalculate after removing an entry
                    showMessageBox('Entry Removed', 'The OT entry has been removed.');
                }
            );
        }

        /**
         * Function to clear all daily OT entries and reset the results section.
         */
        function clearDailyOTEntries() {
            showMessageBox(
                'Confirm Clear All',
                'Are you sure you want to clear all daily OT entries? This action cannot be undone.',
                'confirm',
                () => {
                    clearOTEntries(); // Use the helper function to clear all rows and state
                    showMessageBox('Entries Cleared', 'All daily OT entries have been cleared.');
                    calculateAndDisplayResults(); // Recalculate after clearing entries
                }
            );
        }

        /**
         * Main function to calculate and display OT results.
         */
        function calculateAndDisplayResults() {
            console.log("--- Starting calculateAndDisplayResults ---");
            const basicSalary = parseFloat(basicSalaryInput.value);
            const targetOTPay = getTargetOTPayValue();
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;

            console.log(`Inputs: Basic Salary=${basicSalary}, Target OT Pay=${targetOTPay}, Start Date=${startDate}, End Date=${endDate}`);

            if (isNaN(basicSalary) || basicSalary <= 0) {
                console.warn("Basic Salary is invalid or zero. Displaying zero results.");
                // Set all display elements to 0 or N/A if basic salary is not valid
                totalHoursByTypeElem.innerHTML = '';
                totalPayByCategoryElem.innerHTML = '';
                combinedOTPayElem.textContent = formatCurrency(0);
                totalMonthlyOTHoursDisplay.textContent = `0.0 hours`;
                expectedSalaryPayDisplay.textContent = formatCurrency(0);
                targetOTPayDisplayElem.textContent = "N/A (No target set)";
                targetOTPayDisplayElem.classList.remove('text-green-600');
                targetOTPayDisplayElem.classList.add('text-gray-600'); // Ensure gray text for N/A

                differenceFromTargetElem.textContent = "N/A (No target set)";
                differenceFromTargetElem.classList.remove('text-green-600', 'text-red-600');
                differenceFromTargetElem.classList.add('text-gray-600'); // Ensure gray text for N/A
                console.log("--- Finished calculateAndDisplayResults (due to invalid basic salary) ---");
                return; // Exit if basic salary is invalid, no further calculation possible
            }

            const hourlyRate = calculateHourlyRate(basicSalary);
            console.log("Hourly Rate:", hourlyRate);

            let totalHoursByType = {};
            let totalPayByCategory = {};
            let combinedOTPay = 0;
            let totalMonthlyOTHours = 0;

            // Initialize categories including Public Holiday
            for (const type in CONFIG.OT_MULTIPLIERS) {
                totalHoursByType[type] = 0;
                totalPayByCategory[type] = 0;
            }
            // Ensure 'Public Holiday' is always initialized, even if not in DEFAULT_OT_MULTIPLIERS keys
            if (!totalHoursByType['Public Holiday']) {
                totalHoursByType['Public Holiday'] = 0;
                totalPayByCategory['Public Holiday'] = 0;
            }
            console.log("Initial totalHoursByType:", totalHoursByType);

            otEntries.forEach((entry, index) => {
                console.log(`Processing entry ${index}:`, entry);
                const hours = parseFloat(entry.hours);
                const type = entry.type;
                const date = entry.date;

                if (isNaN(hours) || hours <= 0) {
                    console.warn(`Skipping entry ${index} due to invalid hours: ${hours}`);
                    return;
                }

                const categoryForSumming = isPublicHoliday(date) ? 'Public Holiday' : type;
                const multiplier = isPublicHoliday(date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : CONFIG.OT_MULTIPLIERS[type];

                if (multiplier === undefined) {
                    console.warn(`Unknown OT type or multiplier for type: ${type} on date ${date}. Skipping entry.`);
                    return;
                }

                const dailyOTPay = calculateOT(hourlyRate, hours, type, date);
                console.log(`Entry ${index} details: Hours=${hours}, Type=${type}, Date=${date}, Category=${categoryForSumming}, Multiplier=${multiplier}, Daily Pay=${dailyOTPay}`);

                totalHoursByType[categoryForSumming] += hours;
                totalPayByCategory[categoryForSumming] += dailyOTPay;
                combinedOTPay += dailyOTPay;
                totalMonthlyOTHours += hours;
            });

            console.log("Calculated totalHoursByType:", totalHoursByType);
            console.log("Calculated totalPayByCategory:", totalPayByCategory);
            console.log("Combined OT Pay:", combinedOTPay);
            console.log("Total Monthly OT Hours:", totalMonthlyOTHours);

            const expectedSalaryPay = basicSalary + combinedOTPay;
            console.log("Expected Salary Pay:", expectedSalaryPay);

            // Display Results for totalHoursByType
            let hoursSummaryHtml = [];
            const displayOrderForSummary = [
                'Normal OT (Weekdays)',
                'Off Day (Saturday)',
                'Rest Day (Sunday) — 1st 8h',
                'Rest Day (Sunday) — after 8h',
                'Public Holiday'
            ];
            displayOrderForSummary.forEach(type => {
                if (totalHoursByType[type] > 0) {
                    hoursSummaryHtml.push(`<span class="summary-inline-item">${type}: ${totalHoursByType[type].toFixed(1)}h</span>`);
                }
            });
            totalHoursByTypeElem.innerHTML = hoursSummaryHtml.join('');
            console.log("Hours Summary HTML:", hoursSummaryHtml.join(''));


            // Display Results for totalPayByCategory
            let paySummaryHtml = [];
            displayOrderForSummary.forEach(type => {
                if (totalPayByCategory[type] > 0) {
                    paySummaryHtml.push(`<span class="summary-inline-item">${type}: ${formatCurrency(totalPayByCategory[type])}</span>`);
                }
            });
            totalPayByCategoryElem.innerHTML = paySummaryHtml.join('');
            console.log("Pay Summary HTML:", paySummaryHtml.join(''));


            combinedOTPayElem.textContent = formatCurrency(combinedOTPay);
            totalMonthlyOTHoursDisplay.textContent = `${totalMonthlyOTHours.toFixed(1)} hours`;
            expectedSalaryPayDisplay.textContent = formatCurrency(expectedSalaryPay);

            const isTargetOptional = targetOTPay === null || targetOTPay <= 0;

            if (isTargetOptional) {
                targetOTPayDisplayElem.textContent = "N/A (No target set)";
                targetOTPayDisplayElem.classList.remove('text-green-600');
                targetOTPayDisplayElem.classList.add('text-gray-600');

                differenceFromTargetElem.textContent = "N/A (No target set)";
                differenceFromTargetElem.classList.remove('text-green-600', 'text-red-600');
                differenceFromTargetElem.classList.add('text-gray-600');
            } else {
                targetOTPayDisplayElem.textContent = formatCurrency(targetOTPay);
                targetOTPayDisplayElem.classList.remove('text-gray-600');
                targetOTPayDisplayElem.classList.add('text-green-600');

                const difference = combinedOTPay - targetOTPay;
                differenceFromTargetElem.textContent = formatCurrency(difference);
                if (difference >= 0) {
                    differenceFromTargetElem.classList.remove('text-red-600', 'text-gray-600');
                    differenceFromTargetElem.classList.add('text-green-600');
                } else {
                    differenceFromTargetElem.classList.remove('text-green-600', 'text-gray-600');
                    differenceFromTargetElem.classList.add('text-red-600');
                }
            }
            console.log("--- Finished calculateAndDisplayResults ---");
        }

        /**
         * Generates a random number within a given range, rounded to the nearest 0.5.
         * @param {number} min - The minimum value.
         * @param {number} max - The maximum value.
         * @returns {number} The random number.
         */
        function getRandomHours(min, max) {
            const random = Math.random() * (max - min) + min;
            return Math.round(random * 2) / 2; // Round to nearest 0.5
        }

        /**
         * Adds or updates an OT entry in the otEntries array for auto-allocation.
         * This function assumes one OT entry per date. If an entry for the given date
         * already exists, its hours are updated. Otherwise, a new entry is added.
         * The type for new entries is determined by getDefaultOTTypeForDate.
         * @param {string} date - The date of the OT entry.
         * @param {number} hours - The hours to add/set for the OT entry.
         * @param {string} [suggestedTypeFromAllocationStep] - (Optional) The type suggested by the allocation step. This is mostly for internal consistency during allocation, but the actual stored type for new entries is derived from the date.
         */
        function addOrUpdateOTEntry(date, hours, suggestedTypeFromAllocationStep) { // Kept suggestedTypeFromAllocationStep for clarity, though not directly used for stored type
            console.log(`[addOrUpdateOTEntry] Attempting to add/update for date: ${date}, hours: ${hours}, suggestedType: ${suggestedTypeFromAllocationStep}`);
            const existingEntryIndex = otEntries.findIndex(entry => entry.date === date);

            if (existingEntryIndex !== -1) {
                // Update existing entry's hours
                otEntries[existingEntryIndex].hours = parseFloat((otEntries[existingEntryIndex].hours + hours).toFixed(1)); // Ensure precision
                // Recalculate end time for updated entry
                otEntries[existingEntryIndex].endTime = addHoursToTime(otEntries[existingEntryIndex].startTime, otEntries[existingEntryIndex].hours);
                console.log(`[addOrUpdateOTEntry] Updated existing entry for ${date}. New hours: ${otEntries[existingEntryIndex].hours}. Current otEntries length: ${otEntries.length}`);
            } else {
                // Add new entry
                const newEntry = {
                    id: `ot-entry-${entryCounter++}`,
                    date: date,
                    hours: parseFloat(hours.toFixed(1)), // Ensure precision
                    // For new entries, determine the type based on the date, considering public holidays.
                    // This ensures consistency with how manual entries are typed.
                    type: getDefaultOTTypeForDate(date),
                    startTime: '', // Will be calculated by calculateAndAssignTimes
                    endTime: '',    // Will be calculated by calculateAndAssignTimes
                };
                // Calculate initial times for new entry
                calculateSuggestedTimes(newEntry);
                otEntries.push(newEntry);
                console.log(`[addOrUpdateOTEntry] Added new entry for ${date}. Hours: ${newEntry.hours}. Type: ${newEntry.type}. Current otEntries length: ${otEntries.length}`);
            }
        }

        /**
         * Initializes the list of available days within the planning range.
         * @param {string} startDateStr - The start date string (YYYY-MM-DD).
         * @param {string} endDateStr - The end date string (YYYY-MM-DD).
         * @returns {Array<Object>} An array of day objects { date: 'YYYY-MM-DD', dayOfWeek: number }.
         */
        function initializePlanningDays(startDateStr, endDateStr) {
            const days = [];
            let currentDate = new Date(startDateStr);
            const endDateTime = new Date(endDateStr).getTime();

            while (currentDate.getTime() <= endDateTime) {
                days.push({
                    date: currentDate.toISOString().split('T')[0],
                    dayOfWeek: currentDate.getDay() // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
                });
                currentDate.setDate(currentDate.getDate() + 1);
            }
            // Shuffle days to distribute OT more evenly across the period, rather than front-loading
            days.sort(() => Math.random() - 0.5);
            console.log("Initialized planning days:", days.map(d => d.date));
            return days;
        }

        /**
         * Performs one pass of hour allocation based on predefined steps.
         * @param {Array<Object>} availableDays - List of days to allocate hours to.
         * @param {number} targetOTPay - The target OT pay.
         * @param {number} currentAllocatedPay - The current accumulated OT pay.
         * @param {number} hourlyRate - The employee's hourly rate.
         * @param {Array<Object>} allocationSteps - Array of preferred allocation rules.
         * @param {Object} hoursAllocatedPerDay - Map to track hours per day.
         * @param {Map<string, number>} sundayFirst8hAllocated - Map to track 0.5x hours allocated per Sunday.
         * @returns {number} The updated currentAllocatedPay.
         */
        function performAllocationPass(availableDays, targetOTPay, currentAllocatedPay, hourlyRate, allocationSteps, hoursAllocatedPerDay, sundayFirst8hAllocated) {
            console.log("[performAllocationPass] Starting pass. Current allocated pay:", currentAllocatedPay);
            for (const step of allocationSteps) {
                // Modified condition: Continue until currentAllocatedPay is >= targetOTPay
                if (targetOTPay !== null && currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) {
                    console.log("[performAllocationPass] Target met or exceeded, breaking from pass.");
                    break;
                }

                const multiplier = CONFIG.OT_MULTIPLIERS[step.type];
                if (!multiplier) {
                    console.warn(`[performAllocationPass] No multiplier found for step type: ${step.type}. Skipping step.`);
                    continue;
                }

                const relevantDays = availableDays.filter(day => step.days.includes(day.dayOfWeek));
                console.log(`[performAllocationPass] Processing step type: ${step.type}. Relevant days: ${relevantDays.map(d => d.date).join(', ')}`);

                for (const day of relevantDays) {
                    // Modified condition: Continue until currentAllocatedPay is >= targetOTPay
                    if (targetOTPay !== null && currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) {
                        console.log("[performAllocationPass] Target met or exceeded within day loop, breaking.");
                        break;
                    }

                    const maxHoursForThisDay = CONFIG.MAX_DAILY_OT_HOURS - (hoursAllocatedPerDay[day.date] || 0); // Use 0 if no hours yet
                    if (maxHoursForThisDay <= 0) {
                        console.log(`[performAllocationPass] Day ${day.date} has no max hours remaining (${maxHoursForThisDay}). Skipping.`);
                        continue;
                    }

                    let hoursToConsider = 0;
                    if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                        const currentSunday1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                        const remainingFor1st8h = 8 - currentSunday1st8h;
                        const suggestedHours = getRandomHours(step.minHours, step.maxHours);
                        hoursToConsider = Math.min(suggestedHours, maxHoursForThisDay, remainingFor1st8h);
                        console.log(`[performAllocationPass] Sunday 1st 8h for ${day.date}. current1st8h: ${currentSunday1st8h}, remainingFor1st8h: ${remainingFor1st8h}, hoursToConsider: ${hoursToConsider}`);
                    } else if (step.hours !== undefined) {
                        hoursToConsider = Math.min(step.hours, maxHoursForThisDay);
                    } else {
                        const suggestedHours = getRandomHours(step.minHours, step.maxHours);
                        hoursToConsider = Math.min(suggestedHours, maxHoursForThisDay);
                    }

                    if (step.type === 'Rest Day (Sunday) — after 8h') {
                        const totalHoursOnSunday = hoursAllocatedPerDay[day.date];
                        if (totalHoursOnSunday < 8) {
                            console.log(`[performAllocationPass] Skipping Sunday after 8h for ${day.date} as total hours (${totalHoursOnSunday}) < 8.`);
                            continue;
                        }
                    }

                    // Use the correct multiplier for public holidays during allocation
                    const currentMultiplier = isPublicHoliday(day.date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : multiplier;

                    const potentialPay = calculateOT(hourlyRate, hoursToConsider, step.type, day.date);
                    console.log(`[performAllocationPass] Day ${day.date}, Type ${step.type}, Hours to consider: ${hoursToConsider}, Potential Pay: ${potentialPay}`);


                    // Modified condition: Add if it doesn't make us *too* far over target, or if it's the last chance to meet it
                    if (hoursToConsider > 0 && (targetOTPay === null || currentAllocatedPay + potentialPay <= targetOTPay + (hourlyRate * currentMultiplier * 0.5) + CONFIG.ALLOCATION_PRECISION)) { // Allow up to 0.5h over if needed
                        addOrUpdateOTEntry(day.date, hoursToConsider, step.type);
                        currentAllocatedPay += potentialPay;
                        hoursAllocatedPerDay[day.date] = (hoursAllocatedPerDay[day.date] || 0) + hoursToConsider; // Update total hours for the day
                        if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                            sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToConsider);
                        }
                        console.log(`[performAllocationPass] Added ${hoursToConsider}h for ${day.date}. New allocated pay: ${currentAllocatedPay}`);
                    } else if (hoursToConsider > 0 && targetOTPay !== null && currentAllocatedPay < targetOTPay - CONFIG.ALLOCATION_PRECISION) { // If adding full hours exceeds target, try to add precisely if still under target
                        const remainingPayNeeded = targetOTPay - currentAllocatedPay;
                        const hoursToPreciselyAdd = remainingPayNeeded / (hourlyRate * currentMultiplier);
                        const finalHoursToAdd = Math.min(hoursToPreciselyAdd, hoursToConsider, maxHoursForThisDay);
                        console.log(`[performAllocationPass] Trying precise add for ${day.date}. Remaining pay needed: ${remainingPayNeeded}, Hours to precisely add: ${hoursToPreciselyAdd}, Final hours to add: ${finalHoursToAdd}`);

                        if (finalHoursToAdd > 0) {
                            addOrUpdateOTEntry(day.date, finalHoursToAdd, step.type);
                            currentAllocatedPay = targetOTPay; // Set to target as we're hitting it precisely
                            hoursAllocatedPerDay[day.date] = (hoursAllocatedPerDay[day.date] || 0) + finalHoursToAdd; // Update total hours for the day
                            if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + finalHoursToAdd);
                            }
                            console.log(`[performAllocationPass] Precisely added ${finalHoursToAdd}h for ${day.date}. Target reached.`);
                        }
                    }
                }
            }
            console.log("[performAllocationPass] Pass finished. Current allocated pay:", currentAllocatedPay);
            return currentAllocatedPay;
        }

        /**
         * Fills any remaining gap in target pay using available OT types.
         * @param {Array<Object>} availableDays - List of days to allocate hours to.
         * @param {number} targetOTPay - The target OT pay.
         * @param {number} currentAllocatedPay - The current accumulated OT pay.
         * @param {number} hourlyRate - The employee's hourly rate.
         * @param {Object} hoursAllocatedPerDay - Map to track hours per day.
         * @param {Map<string, number>} sundayFirst8hAllocated - Map to track 0.5x hours allocated per Sunday.
         * @returns {number} The updated currentAllocatedPay.
         */
        function fillRemainingGap(availableDays, targetOTPay, currentAllocatedPay, hourlyRate, hoursAllocatedPerDay, sundayFirst8hAllocated) {
            console.log("[fillRemainingGap] Starting to fill remaining gap. Current allocated pay:", currentAllocatedPay);
            const daysToFill = availableDays.slice().sort((a, b) => hoursAllocatedPerDay[a.date] - hoursAllocatedPerDay[b.date]);

            for (const day of daysToFill) {
                // Modified condition: Continue until currentAllocatedPay is >= targetOTPay
                if (targetOTPay !== null && currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) {
                    console.log("[fillRemainingGap] Target met or exceeded, breaking from gap fill.");
                    break;
                }

                const maxHoursForThisDay = CONFIG.MAX_DAILY_OT_HOURS - (hoursAllocatedPerDay[day.date] || 0);
                if (maxHoursForThisDay <= 0) {
                    console.log(`[fillRemainingGap] Day ${day.date} has no max hours remaining (${maxHoursForThisDay}). Skipping.`);
                    continue;
                }

                let hoursToConsider = 0;
                let typeToUse = '';
                let currentMultiplier = 0;

                // Get preset details for the current workload
                const presetDetails = CONFIG.WORKLOAD_PRESETS[workloadPresetSelect.value];

                // Priority for Sunday: 1st 8h (0.5x) first, then after 8h (2.0x)
                if (day.dayOfWeek === 0) { // It's a Sunday
                    const currentSunday1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                    const totalHoursOnSunday = (hoursAllocatedPerDay[day.date] || 0);

                    if (currentSunday1st8h < 8) { // Still space for 1st 8h at 0.5x
                        typeToUse = 'Rest Day (Sunday) — 1st 8h';
                        currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                        const presetFor1st8h = presetDetails[typeToUse];
                        hoursToConsider = getRandomHours(presetFor1st8h.minHours, presetFor1st8h.maxHours);
                        hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay, 8 - currentSunday1st8h);
                        console.log(`[fillRemainingGap] Sunday 1st 8h for ${day.date}. current1st8h: ${currentSunday1st8h}, hoursToConsider: ${hoursToConsider}`);

                    } else if (totalHoursOnSunday < CONFIG.MAX_DAILY_OT_HOURS) { // After 1st 8h, consider after 8h
                        typeToUse = 'Rest Day (Sunday) — after 8h';
                        currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                        const presetForAfter8h = presetDetails[typeToUse];
                        hoursToConsider = getRandomHours(presetForAfter8h.minHours, presetForAfter8h.maxHours);
                        hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay);
                        console.log(`[fillRemainingGap] Sunday after 8h for ${day.date}. totalHoursOnSunday: ${totalHoursOnSunday}, hoursToConsider: ${hoursToConsider}`);
                    }
                } else if (day.dayOfWeek === 6) { // Saturday
                    typeToUse = 'Off Day (Saturday)';
                    currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                    const presetForOffDay = presetDetails[typeToUse];
                    hoursToConsider = getRandomHours(presetForOffDay.minHours, presetForOffDay.maxHours);
                    hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay);
                    console.log(`[fillRemainingGap] Saturday for ${day.date}. hoursToConsider: ${hoursToConsider}`);
                } else if (day.dayOfWeek >= 1 && day.dayOfWeek <= 5) { // Weekday
                    typeToUse = 'Normal OT (Weekdays)';
                    currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                    const presetForNormalOT = presetDetails[typeToUse];
                    hoursToConsider = getRandomHours(presetForNormalOT.minHours, presetForNormalOT.maxHours);
                    hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay);
                    console.log(`[fillRemainingGap] Weekday for ${day.date}. hoursToConsider: ${hoursToConsider}`);
                }

                if (hoursToConsider > 0 && typeToUse && currentMultiplier > 0) { // Ensure typeToUse is not empty
                    // Use the correct multiplier for public holidays during allocation
                    const finalMultiplier = isPublicHoliday(day.date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : currentMultiplier;

                    const potentialPay = calculateOT(hourlyRate, hoursToConsider, typeToUse, day.date);
                    console.log(`[fillRemainingGap] Day ${day.date}, Type ${typeToUse}, Hours to consider: ${hoursToConsider}, Potential Pay: ${potentialPay}`);

                    // Modified condition: Add if it doesn't make us *too* far over target, or if it's the last chance to meet it
                    if (targetOTPay === null || currentAllocatedPay + potentialPay <= targetOTPay + (hourlyRate * finalMultiplier * 0.5) + CONFIG.ALLOCATION_PRECISION) { // Allow up to 0.5h over if needed
                        addOrUpdateOTEntry(day.date, hoursToConsider, typeToUse);
                        currentAllocatedPay += potentialPay;
                        hoursAllocatedPerDay[day.date] = (hoursAllocatedPerDay[day.date] || 0) + hoursToConsider;
                        if (typeToUse === 'Rest Day (Sunday) — 1st 8h') {
                            sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToConsider);
                        }
                        console.log(`[fillRemainingGap] Added ${hoursToConsider}h for ${day.date}. New allocated pay: ${currentAllocatedPay}`);
                    } else if (targetOTPay !== null && currentAllocatedPay < targetOTPay - CONFIG.ALLOCATION_PRECISION) { // If adding full hours exceeds target, try to add precisely if still under target
                        const remainingPayNeeded = targetOTPay - currentAllocatedPay;
                        const hoursToPreciselyAdd = remainingPayNeeded / (hourlyRate * finalMultiplier);
                        const finalHoursToAdd = Math.min(hoursToPreciselyAdd, hoursToConsider);
                        console.log(`[fillRemainingGap] Trying precise add for ${day.date}. Remaining pay needed: ${remainingPayNeeded}, Hours to precisely add: ${hoursToPreciselyAdd}, Final hours to add: ${finalHoursToAdd}`);

                        if (finalHoursToAdd > 0) {
                            addOrUpdateOTEntry(day.date, finalHoursToAdd, typeToUse);
                            currentAllocatedPay = targetOTPay;
                            hoursAllocatedPerDay[day.date] = (hoursAllocatedPerDay[day.date] || 0) + finalHoursToAdd;
                            if (typeToUse === 'Rest Day (Sunday) — 1st 8h') {
                                sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + finalHoursToAdd);
                            }
                            console.log(`[fillRemainingGap] Precisely added ${finalHoursToAdd}h for ${day.date}. Target reached.`);
                        }
                    }
                }
            }
            console.log("[fillRemainingGap] Gap fill finished. Current allocated pay:", currentAllocatedPay);
            return currentAllocatedPay;
        }

        /**
         * Calculates and assigns start/end times for all entries in otEntries, ensuring chaining for same-day entries.
         */
        function calculateAndAssignTimes() {
            console.log("--- Starting calculateAndAssignTimes ---");
            // Sort entries by date and then by their original ID (to maintain creation order for same-day entries)
            otEntries.sort((a, b) => {
                const dateComparison = new Date(a.date) - new Date(b.date);
                if (dateComparison !== 0) {
                    return dateComparison;
                }
                // If dates are the same, sort by the numeric part of the ID to maintain original creation order
                return parseInt(a.id.split('-')[2]) - parseInt(b.id.split('-')[2]);
            });
            console.log("otEntries sorted for time assignment:", JSON.stringify(otEntries));

            const lastEndTimeOnDay = {}; // To track end time for chaining on the same day
            otEntries.forEach(entry => {
                let prevEndTime = lastEndTimeOnDay[entry.date] || null;
                // Only calculate if entry.startTime is empty (auto-allocated)
                // If startTime is already set (manual entry), use it
                if (!entry.startTime || !entry.endTime) {
                    calculateSuggestedTimes(entry, prevEndTime);
                    console.log(`  Assigned times for ${entry.date}: ${entry.startTime} - ${entry.endTime}`);
                } else {
                    // If times are already set, ensure endTime is correct based on current hours and startTime
                    entry.endTime = addHoursToTime(entry.startTime, entry.hours);
                    console.log(`  Times for ${entry.date} already set, re-calculated endTime: ${entry.startTime} - ${entry.endTime}`);
                }
                lastEndTimeOnDay[entry.date] = entry.endTime; // Update last end time for this day
            });
            console.log("--- Finished calculateAndAssignTimes ---");
        }

        /**
         * Updates the display of workload preset details based on the selected preset.
         */
        function updateWorkloadPresetDetails() {
            const selectedPresetName = workloadPresetSelect.value;
            const presetDetails = CONFIG.WORKLOAD_PRESETS[selectedPresetName];
            let html = `<strong>${selectedPresetName} Details:</strong><ul class="list-disc list-inside ml-4">`;

            // Order for display
            const displayOrder = [
                'Normal OT (Weekdays)',
                'Off Day (Saturday)',
                'Rest Day (Sunday) — 1st 8h',
                'Rest Day (Sunday) — after 8h'
            ];

            displayOrder.forEach(type => {
                const detail = presetDetails[type];
                if (detail) {
                    // All workload preset details for OT types now use minHours/maxHours
                    html += `<li>${type}: ${detail.minHours.toFixed(1)} - ${detail.maxHours.toFixed(1)} hours</li>`;
                }
            });
            html += `</ul>`;
            workloadPresetDetails.innerHTML = html;

            // Update the workload preset description
            workloadPresetDescription.textContent = `This preset suggests daily OT hours for different day types to guide auto-allocation.`;
        }

        /**
         * Updates the display of allocation strategy description.
         */
        function updateAllocationStrategyDisplay() {
            const strategy = allocationStrategySelect.value;
            if (strategy === 'Target-Driven') {
                allocationStrategyDescription.textContent = 'The calculator will try to allocate hours to reach your "Target OT Pay" based on your chosen "Workload Preset".';
            } else if (strategy === 'Workload-Driven') {
                allocationStrategyDescription.textContent = 'Hours will be allocated for all days in your range according to the "Workload Preset", regardless of a specific target pay.';
            }
        }

        /**
         * Expands a collapsible content section smoothly.
         * @param {HTMLElement} contentElement - The content div to expand.
         * @param {HTMLElement} iconElement - The icon element to rotate.
         */
        function expandCollapsible(contentElement, iconElement) {
            contentElement.style.maxHeight = 'none'; // Temporarily set to none to get actual scrollHeight
            const scrollHeight = contentElement.scrollHeight;
            contentElement.style.maxHeight = '0'; // Reset to 0 for the transition
            contentElement.classList.remove('collapsed');
            // Force reflow to ensure the browser registers the height before transition
            contentElement.offsetWidth;
            contentElement.style.maxHeight = scrollHeight + "px";
            if (iconElement) iconElement.classList.add('rotated');

            // After transition, set max-height to 'none' to allow dynamic content changes
            contentElement.addEventListener('transitionend', function handler() {
                contentElement.style.maxHeight = 'none'; // Use 'none' for auto height after transition
                contentElement.removeEventListener('transitionend', handler);
            }, { once: true }); // Use { once: true } to automatically remove the listener
        }

        /**
         * Collapses a collapsible content section smoothly.
         * @param {HTMLElement} contentElement - The content div to collapse.
         * @param {HTMLElement} iconElement - The icon element to rotate.
         */
        function collapseCollapsible(contentElement, iconElement) {
            // Set max-height to current scrollHeight before adding 'collapsed'
            contentElement.style.maxHeight = contentElement.scrollHeight + "px";
            // Force reflow to ensure the browser registers the height before transition
            contentElement.offsetWidth;
            contentElement.classList.add('collapsed');
            if (iconElement) iconElement.classList.remove('rotated');

            // Clear max-height after transition to allow it to be re-calculated if expanded again
            contentElement.addEventListener('transitionend', function handler() {
                // This check ensures we only clear if it's still collapsed (prevents issues if expanded during transition)
                if (contentElement.classList.contains('collapsed')) {
                    contentElement.style.maxHeight = '0'; // Ensure it stays 0 after transition
                }
                contentElement.removeEventListener('transitionend', handler);
            }, { once: true }); // Use { once: true } to automatically remove the listener
        }


        /**
         * Adds a public holiday to the list.
         */
        function addPublicHoliday() {
            const date = publicHolidayDateInput.value;
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;

            if (!date) {
                showMessageBox('Input Error', 'Please select a date for the public holiday.');
                return;
            }

            // Validate against the OT Planning Date Range
            if (!startDate || !endDate || new Date(date) < new Date(startDate) || new Date(date) > new Date(endDate)) {
                showMessageBox('Date Range Error', `Public Holiday date must be within the OT Planning Date Range (${startDate || 'Not Set'} to ${endDate || 'Not Set'}). Please set a valid date range first.`);
                return;
            }

            if (publicHolidays.includes(date)) {
                showMessageBox('Duplicate Entry', `${date} is already in the public holidays list.`);
                return;
            }
            publicHolidays.push(date);
            publicHolidays.sort(); // Keep sorted for consistency
            renderPublicHolidays(); // This should re-render the list

            // --- FIX: Ensure collapsible section expands correctly using new helper ---
            const header = document.querySelector('.collapsible-header[data-target="publicHolidaysContent"]');
            const icon = header ? header.querySelector('.collapsible-icon') : null;
            if (publicHolidaysContent.classList.contains('collapsed')) {
                expandCollapsible(publicHolidaysContent, icon);
            }
            // --- END FIX ---

            // After adding a public holiday, re-render all OT entries to update their grouping/PH indicator
            renderOTEntries();
            calculateAndDisplayResults(); // Recalculate after adding holiday
        }

        /**
         * Removes a public holiday from the list.
         * @param {string} dateToRemove - The date string to remove.
         */
        function removePublicHoliday(dateToRemove) {
            showMessageBox(
                'Confirm Removal',
                `Are you sure you want to remove ${dateToRemove} from public holidays?`,
                'confirm',
                () => {
                    publicHolidays = publicHolidays.filter(date => date !== dateToRemove);
                    renderPublicHolidays();
                    // After removing a public holiday, re-render all OT entries to update their grouping/PH indicator
                    renderOTEntries();
                    calculateAndDisplayResults(); // Recalculate after removing holiday
                    showMessageBox('Holiday Removed', `${dateToRemove} has been removed from public holidays.`);
                }
            );
        }

        /**
         * Renders the list of public holidays.
         */
        function renderPublicHolidays() {
            publicHolidaysList.innerHTML = '';
            if (publicHolidays.length === 0) {
                publicHolidaysList.innerHTML = '<li class="text-gray-500">No public holidays added yet.</li>';
                return;
            }
            publicHolidays.forEach(date => {
                const li = document.createElement('li');
                li.classList.add('flex', 'justify-between', 'items-center', 'py-1');
                li.innerHTML = `
                    <span>${date}</span>
                    <button type="button" class="text-red-500 hover:text-red-700 ml-4" data-date="${date}" aria-label="Remove public holiday ${date}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                        </svg>
                    </button>
                `;
                publicHolidaysList.appendChild(li);
                li.querySelector('button').addEventListener('click', (e) => {
                    removePublicHoliday(e.currentTarget.dataset.date);
                });
            });
        }

        /**
         * Checks if a given date is a public holiday.
         * @param {string} date - The date string (YYYY-MM-DD) to check.
         * @returns {boolean} True if it's a public holiday, false otherwise.
         */
        function isPublicHoliday(date) {
            return publicHolidays.includes(date);
        }

        /**
         * Renders the OT multiplier input fields.
         */
        function renderOTMultiplierInputs() {
            otMultiplierInputsContainer.innerHTML = '';
            // Order for display
            const displayOrder = [
                'Normal OT (Weekdays)',
                'Off Day (Saturday)',
                'Rest Day (Sunday) — 1st 8h',
                'Rest Day (Sunday) — after 8h',
                'Public Holiday'
            ];

            displayOrder.forEach(type => {
                const inputGroup = document.createElement('div');
                inputGroup.classList.add('input-group');
                inputGroup.innerHTML = `
                    <label for="multiplier-${type.replace(/[^a-zA-Z0-9]/g, '')}">${type} Multiplier</label>
                    <input type="number" id="multiplier-${type.replace(/[^a-zA-Z0-9]/g, '')}" value="${(CONFIG.OT_MULTIPLIERS[type] || 0).toFixed(2)}" min="0" step="0.1" class="shadow-sm">
                `;
                otMultiplierInputsContainer.appendChild(inputGroup);

                // Add event listener to update CONFIG.OT_MULTIPLIERS on input change
                inputGroup.querySelector('input').addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value) && value >= 0) {
                        CONFIG.OT_MULTIPLIERS[type] = value;
                        calculateAndDisplayResults(); // Recalculate after multiplier change
                    }
                });
            });
        }

        /**
         * Resets OT multipliers to their default values.
         */
        function resetMultipliersToDefault() {
            showMessageBox(
                'Confirm Reset Multipliers',
                'Are you sure you want to reset all OT multipliers to their default values?',
                'confirm',
                () => {
                    Object.assign(CONFIG.OT_MULTIPLIERS, DEFAULT_OT_MULTIPLIERS);
                    renderOTMultiplierInputs(); // Re-render to show default values
                    showMessageBox('Multipliers Reset', 'OT multipliers have been reset to their default values.');
                    calculateAndDisplayResults(); // Recalculate after resetting multipliers
                }
            );
        }

        /**
         * Main function for auto-allocating OT hours.
         * @param {boolean} clearExisting - If true, clears all existing entries before allocation.
         */
        async function performAutoAllocation(clearExisting) {
            autoAllocateLoading.classList.remove('hidden'); // Show loading indicator
            autoAllocateLoading.setAttribute('aria-live', 'polite'); // Announce loading

            const basicSalary = parseFloat(basicSalaryInput.value);
            const targetOTPay = getTargetOTPayValue(); // Get value using new helper
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;
            const selectedWorkloadPreset = workloadPresetSelect.value;
            const selectedAllocationStrategy = allocationStrategySelect.value;

            console.log("--- Auto Allocate Hours Start ---");
            console.log("Current otEntries before allocation:", JSON.stringify(otEntries));
            console.log("Clear existing:", clearExisting);

            // Basic validation
            if (isNaN(basicSalary) || basicSalary <= 0) {
                showMessageBox('Input Error', 'Please enter a valid Basic Monthly Salary for auto-allocation.');
                autoAllocateLoading.classList.add('hidden');
                autoAllocateLoading.removeAttribute('aria-live');
                console.log("--- Auto Allocate Hours End (Validation Failed: Basic Salary) ---");
                return;
            }
            if (!startDate || !endDate) {
                showMessageBox('Input Error', 'Please select both Start and End Dates for the planning range.');
                autoAllocateLoading.classList.add('hidden');
                autoAllocateLoading.removeAttribute('aria-live');
                console.log("--- Auto Allocate Hours End (Validation Failed: Date Range Missing) ---");
                return;
            }
            if (new Date(startDate) > new Date(endDate)) {
                showMessageBox('Input Error', 'Start Date cannot be after End Date.');
                autoAllocateLoading.classList.add('hidden');
                autoAllocateLoading.removeAttribute('aria-live');
                console.log("--- Auto Allocate Hours End (Validation Failed: Invalid Date Range) ---");
                return;
            }

            let currentAllocatedPay = 0;
            const hoursAllocatedPerDay = {}; // Map to track total hours for each day (including existing)
            const sundayFirst8hAllocated = new Map(); // Map to track 0.5x hours for Sundays

            if (clearExisting) {
                console.log("[Auto Allocate] Clearing all existing OT entries before new allocation.");
                clearOTEntries(); // This clears otEntries array and UI
            } else {
                // If not clearing, pre-populate current state from existing entries
                otEntries.forEach(entry => {
                    const hours = parseFloat(entry.hours);
                    const type = entry.type;
                    const date = entry.date;

                    if (isNaN(hours) || hours <= 0) {
                        console.warn(`Skipping existing entry ${entry.id} due to invalid hours: ${hours}`);
                        return;
                    }

                    const dailyOTPay = calculateOT(calculateHourlyRate(basicSalary), hours, type, date);
                    currentAllocatedPay += dailyOTPay;
                    hoursAllocatedPerDay[date] = (hoursAllocatedPerDay[date] || 0) + hours;
                    if (type === 'Rest Day (Sunday) — 1st 8h') {
                        sundayFirst8hAllocated.set(date, (sundayFirst8hAllocated.get(date) || 0) + hours);
                    }
                });
                console.log("[Auto Allocate] Pre-populated state from existing entries.");
                console.log("Pre-existing currentAllocatedPay:", currentAllocatedPay);
                console.log("Pre-existing hoursAllocatedPerDay:", JSON.stringify(hoursAllocatedPerDay));
                console.log("Pre-existing sundayFirst8hAllocated:", JSON.stringify(Array.from(sundayFirst8hAllocated.entries())));
            }

            const hourlyRate = calculateHourlyRate(basicSalary);
            const allDaysInPlanningRange = initializePlanningDays(startDate, endDate);

            // Filter out days that are already fully allocated (MAX_DAILY_OT_HOURS reached)
            const availableDaysForAllocation = allDaysInPlanningRange.filter(day => {
                return (hoursAllocatedPerDay[day.date] || 0) < CONFIG.MAX_DAILY_OT_HOURS;
            });
            console.log("Available days for allocation:", availableDaysForAllocation.map(d => d.date));


            // Get the base allocation steps and apply preset overrides
            let currentAllocationSteps = JSON.parse(JSON.stringify(CONFIG.ALLOCATION_STEPS));
            currentAllocationSteps.forEach(step => {
                const presetOverrides = CONFIG.WORKLOAD_PRESETS[selectedWorkloadPreset][step.type];
                if (presetOverrides) {
                    step.minHours = presetOverrides.minHours;
                    step.maxHours = presetOverrides.maxHours;
                }
            });

            const isTargetProvided = targetOTPay !== null && targetOTPay > 0;

            if (selectedAllocationStrategy === 'Target-Driven') {
                if (!isTargetProvided) {
                    showMessageBox('Input Error', 'Please enter a valid Target OT Pay (> RM0) for Target-Driven allocation, or select "Workload-Driven" strategy.');
                    autoAllocateLoading.classList.add('hidden');
                    autoAllocateLoading.removeAttribute('aria-live');
                    console.log("--- Auto Allocate Hours End (Validation Failed: Target Not Provided) ---");
                    return;
                }
                // Calculate remaining target pay
                const remainingTargetPay = targetOTPay - currentAllocatedPay;
                // Changed condition: if target is already met or exceeded, no further auto-allocation needed
                if (remainingTargetPay <= CONFIG.ALLOCATION_PRECISION) { // Use precision for comparison
                    showMessageBox('Target Already Met', 'Your target OT pay has already been met or exceeded with existing entries. No further auto-allocation needed.');
                    autoAllocateLoading.classList.add('hidden');
                    autoAllocateLoading.removeAttribute('aria-live');
                    calculateAndDisplayResults();
                    console.log("--- Auto Allocate Hours End (Target Already Met) ---");
                    return;
                }
                console.log(`Target-Driven Allocation: Target=${targetOTPay}, Remaining to allocate=${remainingTargetPay}`);

                // --- Target-based Allocation ---
                currentAllocatedPay = performAllocationPass(availableDaysForAllocation, targetOTPay, currentAllocatedPay, hourlyRate, currentAllocationSteps, hoursAllocatedPerDay, sundayFirst8hAllocated);

                // Phase 2: Fill remaining gap if target not met (now `currentAllocatedPay < targetOTPay`)
                if (currentAllocatedPay < targetOTPay - CONFIG.ALLOCATION_PRECISION) { // Use precision for comparison
                    console.log("[Auto Allocate] Target not fully met after first pass. Filling remaining gap.");
                    currentAllocatedPay = fillRemainingGap(availableDaysForAllocation, targetOTPay, currentAllocatedPay, hourlyRate, hoursAllocatedPerDay, sundayFirst8hAllocated);
                }

                // Final Check: If target still not met, inform the user
                if (currentAllocatedPay < targetOTPay - CONFIG.ALLOCATION_PRECISION) { // Use precision for comparison
                    showMessageBox('Target Not Fully Met', `The target OT pay of ${formatCurrency(targetOTPay)} was not fully met (${formatCurrency(currentAllocatedPay)}). You may need to manually add more hours or increase the planning date range.`);
                } else {
                    showMessageBox('Auto Allocation Complete', 'Overtime hours have been automatically allocated to reach your target pay, guided by the workload preset. Please review and adjust as needed.');
                }
            } else if (selectedAllocationStrategy === 'Workload-Driven') {
                console.log("Workload-Driven Allocation: Filling all days based on preset.");
                // --- Workload-only Allocation (No Target) ---
                availableDaysForAllocation.sort((a, b) => new Date(a.date) - new Date(b.date)); // Ensure sorted by date for consistent allocation

                for (const day of availableDaysForAllocation) {
                    let maxHoursRemaining = CONFIG.MAX_DAILY_OT_HOURS - (hoursAllocatedPerDay[day.date] || 0); // Use 0 if no hours yet
                    if (maxHoursRemaining <= 0) {
                        console.log(`[Workload-Driven] Day ${day.date} has no max hours remaining. Skipping.`);
                        continue;
                    }

                    // Iterate through applicable steps for the current day
                    const applicableStepsForDay = currentAllocationSteps.filter(step => step.days.includes(day.dayOfWeek));
                    console.log(`[Workload-Driven] Processing day ${day.date}. Applicable steps: ${applicableStepsForDay.map(s => s.type).join(', ')}`);

                    for (const step of applicableStepsForDay) {
                        if (maxHoursRemaining <= 0) break;

                        let hoursToAllocate = 0;
                        // Logic for Sunday 1st 8h and after 8h
                        if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                            const current1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                            const remainingFor1st8h = 8 - current1st8h;
                            hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                            hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining, remainingFor1st8h);
                            console.log(`  [Workload-Driven] Sunday 1st 8h for ${day.date}. current1st8h: ${current1st8h}, hoursToAllocate: ${hoursToAllocate}`);
                        } else if (step.type === 'Rest Day (Sunday) — after 8h') {
                            const totalHoursOnSunday = (hoursAllocatedPerDay[day.date] || 0);
                            if (totalHoursOnSunday < 8) {
                                console.log(`  [Workload-Driven] Skipping Sunday after 8h for ${day.date} as total hours (${totalHoursOnSunday}) < 8.`);
                                continue; // Skip 2.0x if 0.5x hasn't been fully allocated yet
                            }
                            hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                            hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                            console.log(`  [Workload-Driven] Sunday after 8h for ${day.date}. totalHoursOnSunday: ${totalHoursOnSunday}, hoursToAllocate: ${hoursToAllocate}`);
                        } else if (step.hours !== undefined) { // Fixed hours (e.g., if we had any other fixed hours type)
                            hoursToAllocate = getRandomHours(step.minHours, step.maxHours); // Use range for fixed hours too
                            hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                        } else { // Range-based hours for other types
                            hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                            hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                            console.log(`  [Workload-Driven] Other type ${step.type} for ${day.date}. hoursToAllocate: ${hoursToAllocate}`);
                        }

                        if (hoursToAllocate > 0) {
                            addOrUpdateOTEntry(day.date, hoursToAllocate, step.type);
                            hoursAllocatedPerDay[day.date] = (hoursAllocatedPerDay[day.date] || 0) + hoursToAllocate;
                            if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToAllocate);
                            }
                            maxHoursRemaining = CONFIG.MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date]; // Update remaining hours
                            console.log(`  [Workload-Driven] Added ${hoursToAllocate}h for ${day.date}. Remaining for day: ${maxHoursRemaining}`);
                        }
                    }
                }
                showMessageBox('Workload Allocated', 'Overtime hours have been allocated based on the selected workload preset for all days in the range.');
            }

            // Phase 3: Calculate and assign final start/end times for all entries
            calculateAndAssignTimes();

            // Clear all 'isNew' flags after auto-allocation
            otEntries.forEach(entry => {
                delete entry.isNew;
            });

            renderOTEntries(); // Re-render the UI based on the sorted and time-calculated otEntries array
            calculateAndDisplayResults(); // Update results after auto-allocation
            autoAllocateLoading.classList.add('hidden'); // Hide loading indicator
            autoAllocateLoading.removeAttribute('aria-live'); // Remove aria-live when hidden

            console.log("Final otEntries after allocation passes:", JSON.stringify(otEntries));
            console.log("Final hoursAllocatedPerDay after allocation passes:", JSON.stringify(hoursAllocatedPerDay));
            console.log("Final sundayFirst8hAllocated after allocation passes:", JSON.stringify(Array.from(sundayFirst8hAllocated.entries())));
            console.log("Final currentAllocatedPay after allocation passes:", currentAllocatedPay);
            console.log("--- Auto Allocate Hours End ---");

            // Scroll to the results section
            // resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' }); // No longer needed with sticky
        }


        /**
         * Exports the summary to a text file.
         */
        function exportSummary() {
            console.log("Export Summary button clicked."); // Log to confirm function call
            try {
                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = getTargetOTPayValue(); // Get value using new helper
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const hourlyRate = calculateHourlyRate(basicSalary);

                let summaryText = `--- OT Calculation Summary ---\n\n`;
                summaryText += `Employee Settings:\n`;
                summaryText += `  Basic Monthly Salary: ${formatCurrency(basicSalary)}\n`;
                summaryText += `  Hourly Rate: RM ${hourlyRate.toFixed(2)}/hour\n\n`;

                summaryText += `OT Planning Period: ${startDate} to ${endDate}\n`;
                summaryText += `Target OT Pay: ${targetOTPay === null ? 'N/A' : formatCurrency(targetOTPay)}\n\n`;

                summaryText += `OT Multipliers Used:\n`;
                for (const type in CONFIG.OT_MULTIPLIERS) {
                    summaryText += `  ${type}: ${CONFIG.OT_MULTIPLIERS[type].toFixed(2)}x\n`;
                }
                summaryText += `\n`;

                // Group entries by type for export
                const groupedEntriesForExport = {};
                const exportOrder = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday'
                ];

                // Populate groupedEntriesForExport
                otEntries.forEach(entry => {
                    const typeToGroup = isPublicHoliday(entry.date) ? 'Public Holiday' : entry.type;
                    if (!groupedEntriesForExport[typeToGroup]) {
                        groupedEntriesForExport[typeToGroup] = [];
                    }
                    groupedEntriesForExport[typeToGroup].push(entry);
                });

                summaryText += `Daily OT Entries:\n`;
                if (otEntries.length === 0) {
                    summaryText += `  No entries recorded.\n`;
                } else {
                    exportOrder.forEach(typeGroup => {
                        if (groupedEntriesForExport[typeGroup] && groupedEntriesForExport[typeGroup].length > 0) {
                            summaryText += `\n--- ${typeGroup} ---\n`;
                            // Sort entries within each group by date for chronological display within type
                            groupedEntriesForExport[typeGroup].sort((a, b) => new Date(a.date) - new Date(b.date));
                            groupedEntriesForExport[typeGroup].forEach(entry => {
                                summaryText += `  Date: ${entry.date}, Hours: ${entry.hours.toFixed(1)}h, Type: ${entry.type}`;
                                if (isPublicHoliday(entry.date)) {
                                    summaryText += ` (Public Holiday)`;
                                }
                                summaryText += `\n`;
                                if (entry.startTime && entry.endTime) {
                                    summaryText += `  Suggested Time: ${entry.startTime} - ${entry.endTime}\n`;
                                }
                            });
                        }
                    });
                }
                summaryText += `\n`;

                // Recalculate for export to ensure consistency
                let totalHoursByType = {};
                let totalPayByCategory = {};
                let combinedOTPay = 0;
                let totalMonthlyOTHours = 0;

                // Initialize categories including Public Holiday
                for (const type in CONFIG.OT_MULTIPLIERS) {
                    totalHoursByType[type] = 0;
                    totalPayByCategory[type] = 0;
                }
                if (!totalHoursByType['Public Holiday']) {
                    totalHoursByType['Public Holiday'] = 0;
                    totalPayByCategory['Public Holiday'] = 0;
                }

                otEntries.forEach(entry => {
                    const hours = parseFloat(entry.hours);
                    const type = entry.type;
                    const date = entry.date;
                    if (isNaN(hours) || hours <= 0) return;

                    // Determine the category for summing hours and pay in the summary
                    const categoryForSumming = isPublicHoliday(date) ? 'Public Holiday' : type;

                    const multiplier = isPublicHoliday(date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : CONFIG.OT_MULTIPLIERS[type];
                    if (multiplier === undefined) return;

                    const dailyOTPay = calculateOT(hourlyRate, hours, type, date);

                    totalHoursByType[categoryForSumming] += hours;
                    totalPayByCategory[categoryForSumming] += dailyOTPay;
                    combinedOTPay += dailyOTPay;
                    totalMonthlyOTHours += hours;
                });

                const expectedSalaryPay = basicSalary + combinedOTPay; // Calculate for export

                summaryText += `Total OT Hours by Type:\n`;
                let hoursSummaryExport = [];
                const displayOrderForSummaryExport = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday'
                ];
                displayOrderForSummaryExport.forEach(type => {
                    if (totalHoursByType[type] > 0) {
                        hoursSummaryExport.push(`${type}: ${totalHoursByType[type].toFixed(1)}h`);
                    }
                });
                summaryText += `  ${hoursSummaryExport.join(', ')}\n`;
                summaryText += `\n`;

                summaryText += `Total Pay per OT Category:\n`;
                let paySummaryExport = [];
                displayOrderForSummaryExport.forEach(type => {
                    if (totalPayByCategory[type] > 0) {
                        totalPayByCategory[type] = parseFloat(totalPayByCategory[type].toFixed(2)); // Round to 2 decimal places for display
                        paySummaryExport.push(`${type}: ${formatCurrency(totalPayByCategory[type])}`);
                    }
                });
                summaryText += `  ${paySummaryExport.join(', ')}\n`;
                summaryText += `\n`;

                summaryText += `Combined OT Pay: ${formatCurrency(combinedOTPay)}\n`;
                const difference = combinedOTPay - (targetOTPay === null ? 0 : targetOTPay);
                summaryText += `Difference from Target: ${targetOTPay === null ? 'N/A (No target set)' : formatCurrency(difference)}\n`;
                summaryText += `Total Monthly OT Hours: ${totalMonthlyOTHours.toFixed(1)} hours\n`; // Removed max hours
                summaryText += `Expected Salary Pay (Calculated): ${formatCurrency(expectedSalaryPay)}\n`; // Add calculated expected salary
                summaryText += `\n--- End of Summary ---`;

                const blob = new Blob([summaryText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ot_summary.txt';
                document.body.appendChild(a);
                a.click(); // Programmatically click the link

                // Show a temporary success message
                showMessageBox('Export Initiated', 'Your OT summary is being downloaded. Please check your browser console for details.', 'info');

                // Clean up the temporary URL and element after a short delay
                // This delay can sometimes help ensure the download starts before cleanup
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 250); // Increased delay to 250ms

            } catch (error) {
                console.error("Error during export summary:", error);
                showMessageBox('Export Error', 'Failed to export summary. Please check your browser console for details.');
            }
        }

        /**
         * Saves the current application data to Firestore.
         */
        async function saveOTEntries() {
            if (!isAuthReady || !userId) {
                showMessageBox('Save Error', 'Authentication not ready. Please try again in a moment.');
                return;
            }
            showStatusMessage(saveDataStatus, 'Saving...', 'loading');

            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');

                // Before saving, clear the 'isNew' flag for all entries
                const cleanedOtEntries = otEntries.map(entry => {
                    const newEntry = { ...entry };
                    delete newEntry.isNew; // Remove the isNew flag
                    return newEntry;
                });

                const dataToSave = {
                    basicSalary: parseFloat(basicSalaryInput.value),
                    targetOTPay: getTargetOTPayValue(), // Save value using new helper
                    startDate: startDateInput.value,
                    endDate: endDateInput.value,
                    workloadPreset: workloadPresetSelect.value, // Save the selected preset
                    allocationStrategy: allocationStrategySelect.value, // Save the selected strategy
                    otEntries: JSON.stringify(cleanedOtEntries), // Stringify cleaned array
                    publicHolidays: JSON.stringify(publicHolidays), // Save public holidays
                    customMultipliers: JSON.stringify(CONFIG.OT_MULTIPLIERS) // Save custom multipliers
                };

                await setDoc(docRef, dataToSave);
                // Update the local state to reflect that 'isNew' flags are cleared
                otEntries = cleanedOtEntries;
                renderOTEntries(); // Re-render to remove "New" badges
                showStatusMessage(saveDataStatus, 'Saved!', 'success');
            } catch (e) {
                console.error("Error saving document: ", e);
                showStatusMessage(saveDataStatus, 'Save Failed!', 'error');
                showMessageBox('Save Error', 'Failed to save data. Please try again.');
            }
        }

        /**
         * Loads the application data from Firestore.
         * @param {boolean} showMessageBoxOnSuccess - Whether to show a message box on successful load.
         */
        async function loadOTEntries(showMessageBoxOnSuccess = true) {
            if (!isAuthReady || !userId) {
                console.warn("Authentication not ready for loading data.");
                if (showMessageBoxOnSuccess) { // Only show error if explicitly requested by button click
                    showMessageBox('Load Error', 'Authentication not ready. Please try again in a moment.');
                }
                return;
            }
            if (showMessageBoxOnSuccess) { // Only show loading if explicitly requested by button click
                showStatusMessage(loadDataStatus, 'Loading...', 'loading');
            }

            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const docRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');
                const docSnap = await getDoc(docRef);

                if (docSnap.exists()) {
                    const loadedData = docSnap.data();
                    basicSalaryInput.value = parseFloat(loadedData.basicSalary);
                    
                    // Set targetOTPaySelect and customTargetOTPayInput values
                    const loadedTargetOTPay = loadedData.targetOTPay;
                    if (loadedTargetOTPay === null) {
                        targetOTPaySelect.value = ''; // "No Target"
                        customTargetOTPayInput.classList.add('hidden');
                        clearCustomTargetOTPayBtn.classList.add('hidden'); // Also hide clear button
                        customTargetOTPayInput.value = '';
                    } else if (PREDEFINED_TARGET_PAYS.includes(loadedTargetOTPay)) {
                        targetOTPaySelect.value = loadedTargetOTPay.toFixed(2);
                        customTargetOTPayInput.classList.add('hidden');
                        clearCustomTargetOTPayBtn.classList.add('hidden'); // Also hide clear button
                        customTargetOTPayInput.value = '';
                    } else {
                        targetOTPaySelect.value = 'custom'; // "Other (Enter Manually)"
                        customTargetOTPayInput.classList.remove('hidden');
                        clearCustomTargetOTPayBtn.classList.remove('hidden'); // Show clear button
                        customTargetOTPayInput.value = loadedTargetOTPay.toFixed(2);
                    }
                    
                    startDateInput.value = loadedData.startDate;
                    endDateInput.value = loadedData.endDate;
                    workloadPresetSelect.value = loadedData.workloadPreset || 'Moderate Workload'; // Load preset, default if not found
                    allocationStrategySelect.value = loadedData.allocationStrategy || 'Target-Driven'; // Load strategy, default if not found
                    otEntries = JSON.parse(loadedData.otEntries || '[]'); // Parse stringified array
                    publicHolidays = JSON.parse(loadedData.publicHolidays || '[]'); // Load public holidays
                    // Load custom multipliers, falling back to defaults if not present
                    Object.assign(CONFIG.OT_MULTIPLIERS, JSON.parse(loadedData.customMultipliers || '{}'));
                    // Ensure all default multipliers are present if not in loaded data
                    Object.assign(CONFIG.OT_MULTIPLIERS, { ...DEFAULT_OT_MULTIPLIERS, ...CONFIG.OT_MULTIPLIERS });


                    // Reset entryCounter to avoid ID conflicts if new entries are added later
                    entryCounter = otEntries.length > 0 ? Math.max(...otEntries.map(e => parseInt(e.id.split('-')[2]))) + 1 : 0;

                    calculateAndAssignTimes(); // Recalculate times for loaded entries
                    renderOTEntries(); // Render loaded entries
                    renderPublicHolidays(); // Render public holidays

                    // --- NEW: Expand public holidays section if data is loaded ---
                    if (publicHolidays.length > 0) { // No need to check 'collapsed' here, just expand if there's data
                        const header = document.querySelector('.collapsible-header[data-target="publicHolidaysContent"]');
                        const icon = header ? header.querySelector('.collapsible-icon') : null;
                        expandCollapsible(publicHolidaysContent, icon);
                    }
                    // --- END NEW ---

                    renderOTMultiplierInputs(); // Render multiplier inputs with loaded values
                    calculateAndDisplayResults(); // Update results based on loaded data
                    if (showMessageBoxOnSuccess) {
                        showStatusMessage(loadDataStatus, 'Loaded!', 'success');
                        showMessageBox('Load Successful', 'Your OT data has been loaded!');
                    }
                } else {
                    console.log("No saved data found for this user. Initializing with default values.");
                    // If no data, initialize with default values for current month and add one entry
                    const today = new Date();
                    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                    const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

                    startDateInput.value = firstDayOfMonth.toISOString().split('T')[0];
                    endDateInput.value = lastDayOfMonth.toISOString().split('T')[0];
                    workloadPresetSelect.value = 'Moderate Workload'; // Default preset
                    allocationStrategySelect.value = 'Target-Driven'; // Default strategy
                    targetOTPaySelect.value = ''; // Default to "No Target"
                    customTargetOTPayInput.classList.add('hidden'); // Ensure custom input is hidden
                    clearCustomTargetOTPayBtn.classList.add('hidden'); // Ensure clear button is hidden

                    // Only add a default entry if otEntries is truly empty (fresh start)
                    if (otEntries.length === 0) {
                        // No longer adding a default entry here, as it will be done via the modal
                        console.log("Skipping initial default OT entry as manual entry now uses a modal.");
                    }
                    
                    renderPublicHolidays(); // Render empty public holidays list
                    renderOTMultiplierInputs(); // Render default multipliers
                    renderOTEntries(); // Render the (potentially new) default entry
                    calculateAndDisplayResults(); // Calculate results for the (potentially new) default entry
                    if (showMessageBoxOnSuccess) {
                        showStatusMessage(loadDataStatus, 'No saved data found.', 'info');
                    }
                }
            } catch (e) {
                console.error("Error loading document: ", e);
                if (showMessageBoxOnSuccess) {
                    showStatusMessage(loadDataStatus, 'Load Failed!', 'error');
                    showMessageBox('Load Error', 'Failed to load data. Please try again.');
                }
            } finally {
                // Ensure workload preset details are updated even if loading fails or no data is found
                updateWorkloadPresetDetails();
                updateAllocationStrategyDisplay(); // Also update allocation strategy display
            }
        }

        /**
         * Shows the modal for adding a new detailed OT entry.
         * Initializes or updates the Flatpickr and time picker instances.
         */
        function showAddDetailedEntryModal() {
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;

            if (!startDate || !endDate || new Date(startDate) > new Date(endDate)) {
                showMessageBox('Date Range Error', 'Please set a valid "OT Planning Date Range" before adding a manual entry.');
                return;
            }

            // Clear previous errors and styling
            detailedEntryDateError.textContent = '';
            detailedEntryHoursError.textContent = '';
            detailedEntryStartTimeError.textContent = '';
            detailedEntryDate.classList.remove('input-error');
            detailedEntryHours.classList.remove('input-error');
            detailedEntryStartTime.classList.remove('input-error');

            // Calculate available dates before opening the modal
            const allDatesInRange = [];
            let currentCheckDate = new Date(startDate);
            const endCheckDate = new Date(endDate);
            while (currentCheckDate.getTime() <= endCheckDate.getTime()) {
                allDatesInRange.push(currentCheckDate.toISOString().split('T')[0]);
                currentCheckDate.setDate(currentCheckDate.getDate() + 1);
            }

            // Filter out dates that already have an OT entry
            const availableDatesForSelection = allDatesInRange.filter(dateString => {
                return !otEntries.some(entry => entry.date === dateString);
            });

            if (availableDatesForSelection.length === 0) {
                showMessageBox('No Available Dates', 'All dates in the current planning range already have an OT entry. Please adjust your date range or clear existing entries to add more.');
                return; // Prevent modal from opening
            }

            // Initialize or update Flatpickr for date
            if (!detailedDatePickerInstance) {
                detailedDatePickerInstance = window.flatpickr(detailedEntryDate, {
                    dateFormat: "Y-m-d",
                    minDate: startDate,
                    maxDate: endDate,
                    disable: otEntries.map(entry => entry.date),
                    defaultDate: availableDatesForSelection[0] || getTodayDateString(),
                    onChange: function(selectedDates, dateStr, instance) {
                        detailedEntryDateError.textContent = '';
                        detailedEntryDate.classList.remove('input-error');
                    }
                });
            } else {
                detailedDatePickerInstance.set('minDate', startDate);
                detailedDatePickerInstance.set('maxDate', endDate);
                detailedDatePickerInstance.set('disable', otEntries.map(entry => entry.date));
                detailedDatePickerInstance.setDate(availableDatesForSelection[0] || getTodayDateString());
                detailedDatePickerInstance.redraw();
            }

            // Initialize or update Flatpickr for time
            if (!detailedStartTimePickerInstance) {
                detailedStartTimePickerInstance = window.flatpickr(detailedEntryStartTime, {
                    enableTime: true,
                    noCalendar: true,
                    dateFormat: "H:i",
                    time_24hr: true,
                    defaultHour: 18, // Default to 6 PM
                    defaultMinute: 0,
                    minuteIncrement: 15,
                    onChange: function(selectedDates, dateStr, instance) {
                        detailedEntryStartTimeError.textContent = '';
                        detailedEntryStartTime.classList.remove('input-error');
                        updateDetailedEntryEndTime();
                    }
                });
            } else {
                detailedStartTimePickerInstance.setDate('18:00', false); // Reset to default 6 PM
            }

            // Set default hours and calculate end time
            detailedEntryHours.value = '2.0';
            updateDetailedEntryEndTime();

            addDetailedOTEntryModal.classList.remove('hidden');
            window.lastFocusedElement = document.activeElement;
            detailedEntryDate.focus(); // Focus the date input first
        }

        /**
         * Hides the detailed OT entry modal.
         */
        function hideAddDetailedEntryModal() {
            addDetailedOTEntryModal.classList.add('hidden');
            if (window.lastFocusedElement) {
                window.lastFocusedElement.focus();
            }
        }

        /**
         * Updates the calculated end time in the detailed entry modal.
         */
        function updateDetailedEntryEndTime() {
            const startTime = detailedEntryStartTime.value;
            const hours = parseFloat(detailedEntryHours.value);

            if (startTime && !isNaN(hours) && hours > 0) {
                detailedEntryEndTime.value = addHoursToTime(startTime, hours);
            } else {
                detailedEntryEndTime.value = '';
            }
        }

        /**
         * Handles confirming the detailed OT entry from the modal.
         */
        function handleConfirmDetailedEntry() {
            const selectedDate = detailedEntryDate.value;
            const hours = parseFloat(detailedEntryHours.value);
            const startTime = detailedEntryStartTime.value;
            const endTime = detailedEntryEndTime.value; // Get the calculated end time

            // Clear previous errors
            detailedEntryDateError.textContent = '';
            detailedEntryHoursError.textContent = '';
            detailedEntryStartTimeError.textContent = '';
            detailedEntryDate.classList.remove('input-error');
            detailedEntryHours.classList.remove('input-error');
            detailedEntryStartTime.classList.remove('input-error');

            let isValid = true;

            if (!selectedDate) {
                detailedEntryDateError.textContent = 'Please select a date.';
                detailedEntryDate.classList.add('input-error');
                isValid = false;
            }

            if (isNaN(hours) || hours <= 0) {
                detailedEntryHoursError.textContent = 'Hours must be a positive number.';
                detailedEntryHours.classList.add('input-error');
                isValid = false;
            } else if (hours > CONFIG.MAX_DAILY_OT_HOURS) {
                detailedEntryHoursError.textContent = `Max hours per day is ${CONFIG.MAX_DAILY_OT_HOURS}.`;
                detailedEntryHours.classList.add('input-error');
                isValid = false;
            }

            if (!startTime) {
                detailedEntryStartTimeError.textContent = 'Please set a start time.';
                detailedEntryStartTime.classList.add('input-error');
                isValid = false;
            }

            const startDate = startDateInput.value;
            const endDate = endDateInput.value;
            const selectedDateTime = new Date(selectedDate).getTime();
            const startDateTime = new Date(startDate).getTime();
            const endDateTime = new Date(endDate).getTime();

            if (selectedDateTime < startDateTime || selectedDateTime > endDateTime) {
                detailedEntryDateError.textContent = `Date must be within ${startDate} and ${endDate}.`;
                detailedEntryDate.classList.add('input-error');
                isValid = false;
            }

            // Check for duplicate date across ALL existing entries
            const isDateAlreadyUsed = otEntries.some(entry => entry.date === selectedDate);
            if (isDateAlreadyUsed) {
                detailedEntryDateError.textContent = `An OT entry already exists for ${selectedDate}. Each date can only have one OT entry.`;
                detailedEntryDate.classList.add('input-error');
                isValid = false;
            }

            if (!isValid) {
                return; // Stop if any validation fails
            }

            addNewDetailedOTEntry(selectedDate, hours, startTime, endTime);
            hideAddDetailedEntryModal();
            showMessageBox('Entry Added', `New OT entry added for ${selectedDate} (${hours}h, ${startTime}-${endTime}).`);
        }

        /**
         * Updates the Flatpickr instance for the manual entry date picker.
         * This function is called when the date range or OT entries change.
         */
        function updateManualEntryDatePicker() {
            // This function is now specifically for the detailed entry modal's date picker
            if (detailedDatePickerInstance) {
                detailedDatePickerInstance.set('minDate', startDateInput.value);
                detailedDatePickerInstance.set('maxDate', endDateInput.value);
                // Disable dates that already have an entry
                detailedDatePickerInstance.set('disable', otEntries.map(entry => entry.date));
                detailedDatePickerInstance.redraw(); // Redraw to apply new disable rules
            }
        }

        /**
         * Shows the modal for selecting the OT Planning Date Range.
         */
        function showDateRangeModal() {
            // Store the currently focused element before showing the modal
            window.lastFocusedElement = document.activeElement;

            dateRangeModal.classList.remove('hidden');

            // Clear previous errors
            startDateModalError.textContent = '';
            endDateModalError.textContent = '';
            startDateModalInput.classList.remove('input-error');
            endDateModalInput.classList.remove('input-error');

            // Initialize or update Flatpickr for start date in modal
            if (!startDateModalPicker) {
                startDateModalPicker = window.flatpickr(startDateModalInput, {
                    dateFormat: "Y-m-d",
                    onChange: function(selectedDates, dateStr, instance) {
                        // When start date changes, update minDate for end date picker
                        endDateModalPicker.set('minDate', dateStr);
                        startDateModalError.textContent = '';
                        startDateModalInput.classList.remove('input-error');
                    }
                });
            }
            // Initialize or update Flatpickr for end date in modal
            if (!endDateModalPicker) {
                endDateModalPicker = window.flatpickr(endDateModalInput, {
                    dateFormat: "Y-m-d",
                    onChange: function(selectedDates, dateStr, instance) {
                        // When end date changes, update maxDate for start date picker
                        startDateModalPicker.set('maxDate', dateStr);
                        endDateModalError.textContent = '';
                        endDateModalInput.classList.remove('input-error');
                    }
                });
            }

            // Set default dates for modal pickers based on current main inputs
            if (startDateInput.value) {
                startDateModalPicker.setDate(startDateInput.value, false);
            } else {
                startDateModalPicker.clear();
            }
            if (endDateInput.value) {
                endDateModalPicker.setDate(endDateInput.value, false);
            } else {
                endDateModalPicker.clear();
            }

            // Ensure min/max date constraints are applied correctly on open
            if (startDateModalInput.value) {
                endDateModalPicker.set('minDate', startDateModalInput.value);
            } else {
                endDateModalPicker.set('minDate', null); // No min if start date is empty
            }
            if (endDateModalInput.value) {
                startDateModalPicker.set('maxDate', endDateModalInput.value);
            } else {
                startDateModalPicker.set('maxDate', null); // No max if end date is empty
            }

            startDateModalInput.focus(); // Focus the first input in the modal
        }

        /**
         * Hides the date range modal.
         */
        function hideDateRangeModal() {
            dateRangeModal.classList.add('hidden');
            // Return focus to the element that triggered the modal
            if (window.lastFocusedElement) {
                window.lastFocusedElement.focus();
            }
        }

        /**
         * Handles confirming the date range selection from the modal.
         */
        function handleConfirmDateRange() {
            const newStartDate = startDateModalInput.value;
            const newEndDate = endDateModalInput.value;

            startDateModalError.textContent = '';
            endDateModalError.textContent = '';
            startDateModalInput.classList.remove('input-error');
            endDateModalInput.classList.remove('input-error');

            if (!newStartDate) {
                startDateModalError.textContent = 'Please select a start date.';
                startDateModalInput.classList.add('input-error');
                return;
            }
            if (!newEndDate) {
                endDateModalError.textContent = 'Please select an end date.';
                endDateModalInput.classList.add('input-error');
                return;
            }

            if (new Date(newStartDate) > new Date(newEndDate)) {
                startDateModalError.textContent = 'Start Date cannot be after End Date.';
                startDateModalInput.classList.add('input-error');
                endDateModalInput.classList.add('input-error');
                return;
            }

            startDateInput.value = newStartDate;
            endDateInput.value = newEndDate;

            // Manually trigger change events on the hidden inputs to update everything
            const startDateChangeEvent = new Event('change');
            startDateInput.dispatchEvent(startDateChangeEvent);

            const endDateChangeEvent = new Event('change');
            endDateInput.dispatchEvent(endDateChangeEvent);

            hideDateRangeModal();
            showMessageBox('Date Range Set', `OT Planning Date Range set from ${newStartDate} to ${newEndDate}.`);
        }

        /**
         * Updates the Flatpickr instance for the public holiday date picker.
         * This function is called when the date range changes.
         */
        function updatePublicHolidayDatePicker() {
            const startDate = startDateInput.value;
            const endDate = endDateInput.value;
            const isRangeValid = startDate && endDate && (new Date(startDate) <= new Date(endDate));

            console.log(`[updatePublicHolidayDatePicker] Start Date: ${startDate}, End Date: ${endDate}, Is Range Valid: ${isRangeValid}`);

            if (publicHolidayDatePickerInstance) {
                if (isRangeValid) {
                    publicHolidayDatePickerInstance.set('minDate', startDate);
                    publicHolidayDatePickerInstance.set('maxDate', endDate);
                    publicHolidayDatePickerInstance.redraw();
                    console.log("[updatePublicHolidayDatePicker] Public Holiday picker min/max dates set based on valid range.");
                } else {
                    // If range is not valid, clear min/max dates to allow any selection, but validation will occur on add.
                    publicHolidayDatePickerInstance.set('minDate', null);
                    publicHolidayDatePickerInstance.set('maxDate', null);
                    publicHolidayDatePickerInstance.redraw();
                    console.log("[updatePublicHolidayDatePicker] Public Holiday picker min/max dates cleared (no valid range).");
                }
            } else {
                console.warn("[updatePublicHolidayDatePicker] Flatpickr instance for public holiday date picker not initialized yet.");
            }
        }

        /**
         * Shows the allocation choice modal.
         */
        function showAllocationChoiceModal() {
            allocationChoiceModal.classList.remove('hidden');
            window.lastFocusedElement = document.activeElement; // Store focused element
            clearAndAllocateBtn.focus(); // Focus the first button in the modal
        }

        /**
         * Hides the allocation choice modal.
         */
        function hideAllocationChoiceModal() {
            allocationChoiceModal.classList.add('hidden');
            if (window.lastFocusedElement) {
                window.lastFocusedElement.focus(); // Restore focus
            }
        }


        document.addEventListener('DOMContentLoaded', async () => {
            // --- DOM Elements Assignment ---
            basicSalaryInput = document.getElementById('basicSalary');
            clearBasicSalaryBtn = basicSalaryInput.nextElementSibling; // Get the clear button next to basicSalary
            targetOTPaySelect = document.getElementById('targetOTPaySelect');
            customTargetOTPayInput = document.getElementById('customTargetOTPayInput');
            clearCustomTargetOTPayBtn = document.getElementById('clearCustomTargetOTPayBtn'); // Get the clear button for custom target pay
            startDateInput = document.getElementById('startDate');
            endDateInput = document.getElementById('endDate');
            publicHolidayDateInput = document.getElementById('publicHolidayDate');
            addPublicHolidayDateBtn = document.getElementById('addPublicHolidayDateBtn');
            publicHolidaysList = document.getElementById('publicHolidaysList');
            otMultiplierInputsContainer = document.getElementById('otMultiplierInputs');
            resetMultipliersBtn = document.getElementById('resetMultipliersBtn');
            allocationStrategySelect = document.getElementById('allocationStrategy');
            allocationStrategyDescription = document.getElementById('allocationStrategyDescription'); // Assign new element
            workloadPresetSelect = document.getElementById('workloadPreset');
            workloadPresetDescription = document.getElementById('workloadPresetDescription'); // Assign new element
            workloadPresetDetails = document.getElementById('workloadPresetDetails');
            otEntriesContainer = document.getElementById('otEntriesContainer');
            noEntriesMessage = document.getElementById('noEntriesMessage');
            addOTEntryBtn = document.getElementById('addOTEntryBtn');
            autoAllocateBtn = document.getElementById('autoAllocateBtn');
            autoAllocateLoading = document.getElementById('autoAllocateLoading');
            resetAndReallocateBtn = document.getElementById('resetAndReallocateBtn'); // NEW
            clearAllEntriesBtn = document.getElementById('clearAllEntriesBtn');
            calculateBtn = document.getElementById('calculateBtn');
            saveDataBtn = document.getElementById('saveDataBtn');
            loadDataBtn = document.getElementById('loadDataBtn');
            resultsSection = document.getElementById('results');
            totalHoursByTypeElem = document.getElementById('totalHoursByType');
            totalPayByCategoryElem = document.getElementById('totalPayByCategory');
            combinedOTPayElem = document.getElementById('combinedOTPay');
            targetOTPayDisplayElem = document.getElementById('targetOTPayDisplay');
            differenceFromTargetElem = document.getElementById('differenceFromTarget');
            totalMonthlyOTHoursDisplay = document.getElementById('totalMonthlyOTHoursDisplay');
            expectedSalaryPayDisplay = document.getElementById('expectedSalaryPayDisplay');
            exportSummaryBtn = document.getElementById('exportSummaryBtn');
            userIdDisplay = document.getElementById('userIdDisplay');

            messageBox = document.getElementById('messageBox');
            messageBoxTitle = document.getElementById('messageBoxTitle');
            messageBoxContent = document.getElementById('messageBoxContent');
            messageBoxCloseBtn = document.getElementById('messageBoxCloseBtn');
            messageBoxConfirmBtn = document.getElementById('messageBoxConfirmBtn');
            messageBoxCancelBtn = document.getElementById('messageBoxCancelBtn');

            // Original manual entry modal (now unused by addOTEntryBtn)
            addManualEntryModal = document.getElementById('addManualEntryModal');
            manualEntryModalTitle = document.getElementById('manualEntryModalTitle');
            manualEntryDateInput = document.getElementById('manualEntryDate');
            manualEntryDateError = document.getElementById('manualEntryDateError');
            confirmManualEntryBtn = document.getElementById('confirmManualEntryBtn');
            cancelManualEntryBtn = document.getElementById('cancelManualEntryBtn');

            // NEW: Detailed OT Entry Modal Elements
            addDetailedOTEntryModal = document.getElementById('addDetailedOTEntryModal');
            detailedEntryModalTitle = document.getElementById('detailedEntryModalTitle');
            detailedEntryDate = document.getElementById('detailedEntryDate');
            detailedEntryDateError = document.getElementById('detailedEntryDateError');
            detailedEntryHours = document.getElementById('detailedEntryHours');
            detailedEntryHoursError = document.getElementById('detailedEntryHoursError');
            detailedEntryStartTime = document.getElementById('detailedEntryStartTime');
            detailedEntryStartTimeError = document.getElementById('detailedEntryStartTimeError');
            detailedEntryEndTime = document.getElementById('detailedEntryEndTime');
            confirmDetailedEntryBtn = document.getElementById('confirmDetailedEntryBtn');
            cancelDetailedEntryBtn = document.getElementById('cancelDetailedEntryBtn');

            dateRangeModal = document.getElementById('dateRangeModal'); // New: Assign modal
            dateRangeModalTitle = document.getElementById('dateRangeModalTitle'); // New: Assign title
            startDateModalInput = document.getElementById('startDateModalInput'); // New: Assign input
            endDateModalInput = document.getElementById('endDateModalInput');   // New: Assign input
            startDateModalError = document.getElementById('startDateModalError'); // New: Error for start date in modal
            endDateModalError = document.getElementById('endDateModalError');   // New: Error for end date in modal
            confirmDateRangeBtn = document.getElementById('confirmDateRangeBtn'); // New: Assign confirm button
            cancelDateRangeBtn = document.getElementById('cancelDateRangeBtn'); // New: Assign cancel button

            allocationChoiceModal = document.getElementById('allocationChoiceModal'); // NEW
            clearAndAllocateBtn = document.getElementById('clearAndAllocateBtn');     // NEW
            fillRemainingBtn = document.getElementById('fillRemainingBtn');           // NEW
            cancelAllocationChoiceBtn = document.getElementById('cancelAllocationChoiceBtn'); // NEW

            setStartDateTodayBtn = document.getElementById('setStartDateTodayBtn');
            setEndDateTodayBtn = document.getElementById('setEndDateTodayBtn');
            setPublicHolidayTodayBtn = document.getElementById('setPublicHolidayTodayBtn');

            collapsibleHeaders = document.querySelectorAll('.collapsible-header');
            publicHolidaysContent = document.getElementById('publicHolidaysContent');
            otMultiplierContent = document.getElementById('otMultiplierContent');
            howToUseContent = document.getElementById('howToUseContent'); // Assign the new element


            saveDataStatus = document.getElementById('saveDataStatus');
            loadDataStatus = document.getElementById('loadDataStatus');


            // --- Firebase Initialization ---
            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Listen for auth state changes to set userId and load data
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        userIdDisplay.textContent = `User ID: ${userId}`;
                        userIdDisplay.classList.remove('hidden');
                        console.log("Firebase authenticated. User ID:", userId);
                        await loadOTEntries(false); // Load data once authenticated, don't show message box on initial load
                    } else {
                        // Sign in anonymously if no user is logged in
                        try {
                            const anonymousUser = await signInAnonymously(auth);
                            userId = anonymousUser.user.uid;
                            isAuthReady = true;
                            userIdDisplay.textContent = `User ID: ${userId}`;
                            userIdDisplay.classList.remove('hidden');
                            console.log("Signed in anonymously. User ID:", userId);
                            await loadOTEntries(false); // Load data once authenticated, don't show message box on initial load
                        } catch (error) {
                            console.error("Anonymous sign-in failed:", error);
                            showMessageBox('Authentication Error', 'Failed to sign in. Data saving/loading may not work.');
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessageBox('Initialization Error', 'Firebase could not be initialized. Data saving/loading will not work.');
            }

            // --- Event Listeners ---
            basicSalaryInput.addEventListener('input', calculateAndDisplayResults); // Live update for basic salary
            customTargetOTPayInput.addEventListener('input', calculateAndDisplayResults); // Live update for custom target pay

            // Date Range Inputs (now trigger modal)
            startDateInput.addEventListener('click', showDateRangeModal);
            endDateInput.addEventListener('click', showDateRangeModal);

            // These listeners are now triggered by the modal's confirm action
            startDateInput.addEventListener('change', () => {
                calculateAndDisplayResults();
                updateManualEntryDatePicker(); // Update detailed OT date picker constraints
                updatePublicHolidayDatePicker(); // Update Public Holiday date picker constraints
            });
            endDateInput.addEventListener('change', () => {
                calculateAndDisplayResults();
                updateManualEntryDatePicker(); // Update detailed OT date picker constraints
                updatePublicHolidayDatePicker(); // Update Public Holiday date picker constraints
            });

            // Modified autoAllocateBtn to show choice modal first
            autoAllocateBtn.addEventListener('click', showAllocationChoiceModal);
            // New listeners for the allocation choice modal buttons
            clearAndAllocateBtn.addEventListener('click', () => {
                hideAllocationChoiceModal();
                performAutoAllocation(true); // True to clear existing
            });
            fillRemainingBtn.addEventListener('click', () => {
                hideAllocationChoiceModal();
                performAutoAllocation(false); // False to keep existing
            });
            cancelAllocationChoiceBtn.addEventListener('click', hideAllocationChoiceModal);

            // NEW: Listener for the Reset & Re-allocate All button
            resetAndReallocateBtn.addEventListener('click', () => {
                showMessageBox(
                    'Confirm Reset & Re-allocate',
                    'Are you sure you want to clear ALL existing OT entries and re-allocate from scratch? This action cannot be undone.',
                    'confirm',
                    () => performAutoAllocation(true) // Directly call with clearExisting = true
                );
            });


            clearAllEntriesBtn.addEventListener('click', clearDailyOTEntries);
            calculateBtn.addEventListener('click', () => performAutoAllocation(false)); // Calculate button will now just fill remaining
            exportSummaryBtn.addEventListener('click', exportSummary);
            saveDataBtn.addEventListener('click', saveOTEntries);
            loadDataBtn.addEventListener('click', () => loadOTEntries(true)); // Pass true to show message box
            workloadPresetSelect.addEventListener('change', updateWorkloadPresetDetails); // Update details on change
            allocationStrategySelect.addEventListener('change', updateAllocationStrategyDisplay); // New: Update allocation strategy description
            addPublicHolidayDateBtn.addEventListener('click', addPublicHoliday); // Add event listener for public holiday button
            resetMultipliersBtn.addEventListener('click', resetMultipliersToDefault); // Add event listener for reset multipliers
            targetOTPaySelect.addEventListener('change', handleTargetOTPayChange); // Re-added as custom input is back

            // Clear input buttons
            clearBasicSalaryBtn.addEventListener('click', () => {
                basicSalaryInput.value = '';
                calculateAndDisplayResults();
            });
            clearCustomTargetOTPayBtn.addEventListener('click', () => {
                customTargetOTPayInput.value = '';
                calculateAndDisplayResults();
            });

            // "Today" button listeners
            setStartDateTodayBtn.addEventListener('click', () => {
                startDateInput.value = getTodayDateString();
                // Manually trigger change event to update dependencies
                startDateInput.dispatchEvent(new Event('change'));
            });
            setEndDateTodayBtn.addEventListener('click', () => {
                endDateInput.value = getTodayDateString();
                // Manually trigger change event to update dependencies
                endDateInput.dispatchEvent(new Event('change'));
            });
            setPublicHolidayTodayBtn.addEventListener('click', () => {
                publicHolidayDateInput.value = getTodayDateString();
                // Ensure the Flatpickr instance updates its display if the date is set programmatically
                if (publicHolidayDatePickerInstance) {
                    publicHolidayDatePickerInstance.setDate(publicHolidayDateInput.value, true); // true to trigger onChange
                }
            });

            // Collapsible section listeners
            collapsibleHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const targetId = header.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    const icon = header.querySelector('.collapsible-icon');

                    if (targetContent.classList.contains('collapsed')) {
                        expandCollapsible(targetContent, icon);
                    } else {
                        collapseCollapsible(targetContent, icon);
                    }
                });
            });

            // Event listeners for NEW detailed entry modal buttons
            addOTEntryBtn.addEventListener('click', showAddDetailedEntryModal);
            confirmDetailedEntryBtn.addEventListener('click', handleConfirmDetailedEntry);
            cancelDetailedEntryBtn.addEventListener('click', hideAddDetailedEntryModal);
            detailedEntryHours.addEventListener('input', updateDetailedEntryEndTime);
            detailedEntryStartTime.addEventListener('input', updateDetailedEntryEndTime);


            // New: Event listeners for date range modal buttons
            confirmDateRangeBtn.addEventListener('click', handleConfirmDateRange);
            cancelDateRangeBtn.addEventListener('click', hideDateRangeModal);


            // Initial Setup (handled by onAuthStateChanged calling loadOTEntries)
            populateTargetOTPayDropdown(); // Populate dropdown on load
            renderOTMultiplierInputs(); // Render default multipliers immediately

            // Initialize Flatpickr for public holiday date picker
            publicHolidayDatePickerInstance = window.flatpickr(publicHolidayDateInput, {
                dateFormat: "Y-m-d",
                // minDate and maxDate will be set by updatePublicHolidayDatePicker
            });

            // Data will be loaded via onAuthStateChanged, which will then call other render/update functions.
            // The `updateWorkloadPresetDetails()` is called in `loadOTEntries`'s finally block
            // to ensure it's always called after loading, or if loading fails.

            // Initialize collapsible sections to be collapsed by default
            howToUseContent.classList.add('collapsed'); // New: Collapse How to Use by default
            publicHolidaysContent.classList.add('collapsed');
            otMultiplierContent.classList.add('collapsed');

            // Initial call for new UX elements
            updateAllocationStrategyDisplay();
            updateWorkloadPresetDetails();
            updatePublicHolidayDatePicker(); // Call this initially to set the correct disabled state
        });
    </script>
</body>
</html>
