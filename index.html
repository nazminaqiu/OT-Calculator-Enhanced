<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OT Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Flatpickr CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <!-- Flatpickr JS -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <!-- Chart.js CDN for interactive charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* CSS Variables for easier theme management */
        :root {
            --primary-indigo: #6366f1;
            --dark-indigo: #4f46e5;
            --light-indigo: #e0e7ff;
            --lightest-indigo: #c7d2fe;
            --danger-red: #ef4444;
            --dark-red: #dc2626;
            --success-green: #10b981;
            --info-blue: #3b82f6;
            --warning-orange: #f59e0b;
            --gray-900: #1f2937;
            --gray-800: #374151;
            --gray-700: #4b5563;
            --gray-600: #6b7280;
            --gray-500: #9ca3af;
            --gray-400: #d1d5db;
            --gray-300: #e5e7eb;
            --gray-200: #f3f4f6;
            --gray-100: #f9fafb;
            --gray-50: #f9fafb; /* Using a consistent light background */
        }

        /* Custom styles for Inter font and general body */
        body {
            font-family: "Inter", sans-serif;
            background-color: var(--gray-200); /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to allow scrolling */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .main-wrapper {
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            gap: 25px;
            max-width: 1200px;
            width: 100%;
        }
        @media (min-width: 1024px) { /* md breakpoint for two columns */
            .main-wrapper {
                flex-direction: row; /* Two columns on larger screens */
                align-items: flex-start;
            }
        }

        .form-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            flex-grow: 1; /* Allow it to grow and take available space */
            width: 100%; /* Default for smaller screens */
        }
        @media (min-width: 1024px) {
            .form-content {
                min-width: 600px; /* Ensure main content doesn't get too narrow */
            }
        }

        .summary-sidebar {
            background-color: #ffffff;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 20px;
            align-self: flex-start;
            /* Removed max-height and overflow-y: auto */
            width: 100%; /* Default for smaller screens */
            min-width: 300px; /* Prevent it from becoming too narrow on smaller screens */
            flex-shrink: 0; /* Prevent sidebar from shrinking */
        }
        @media (min-width: 1024px) {
            .summary-sidebar {
                width: 350px; /* Fixed width on large screens */
            }
        }

        .input-group label {
            font-weight: 600;
            color: var(--gray-800); /* Darker gray for labels */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--gray-400); /* Light gray border */
            border-radius: 8px;
            font-size: 1rem;
            color: var(--gray-700); /* Medium gray for input text */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--primary-indigo); /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Light indigo shadow */
        }
        .input-group select:disabled {
            background-color: var(--gray-200);
            cursor: not-allowed;
        }
        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background-color: var(--primary-indigo); /* Indigo */
            color: #ffffff;
        }
        .btn-primary:hover {
            background-color: var(--dark-indigo); /* Darker indigo */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: var(--light-indigo); /* Light indigo */
            color: var(--dark-indigo); /* Darker indigo text */
        }
        .btn-secondary:hover {
            background-color: var(--lightest-indigo); /* Even lighter indigo */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: var(--danger-red); /* Red */
            color: #ffffff;
        }
        .btn-danger:hover {
            background-color: var(--dark-red); /* Darker red */
            transform: translateY(-1px);
        }
        .results-section {
            /* Styles moved to .summary-sidebar, keeping only internal text styles */
        }
        .results-section h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray-900); /* Darkest gray */
            margin-bottom: 15px;
        }
        .results-section p {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: var(--gray-800);
        }
        .results-section p strong {
            color: var(--gray-900); /* Even darker for emphasis */
        }
        .ot-entry-row {
            display: flex; /* Changed to flex */
            flex-direction: column; /* Stack children vertically */
            gap: 15px; /* Gap between the main sections (date, times, details) */
            align-items: stretch; /* Ensure children stretch to fill width */

            margin-bottom: 15px;
            padding: 15px;
            background-color: var(--gray-100);
            border-radius: 8px;
            border: 1px solid var(--gray-300);
        }
        .ot-entry-row .input-group {
            margin-bottom: 0; /* Override default margin for compact rows */
        }
        .ot-entry-row .input-group label {
            font-size: 0.85rem; /* Smaller labels for row items */
            margin-bottom: 4px;
        }
        .ot-entry-row input, .ot-entry-row select {
            padding: 8px;
            font-size: 0.9rem;
        }
        .message-box {
            position: fixed;
            top: 50% ;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
            min-width: 300px;
            max-width: 90%;
            border: 1px solid var(--gray-400);
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.9);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        .message-box.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        .message-box h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray-900);
            margin-bottom: 15px;
        }
        .message-box p {
            font-size: 1.1rem;
            color: var(--gray-700);
            margin-bottom: 25px;
        }
        .message-box-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .message-box button {
            background-color: var(--primary-indigo);
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .message-box button:hover {
            background-color: var(--dark-indigo);
        }
        .message-box .btn-cancel {
            background-color: var(--gray-300);
            color: var(--gray-700);
        }
        .message-box .btn-cancel:hover {
            background-color: var(--gray-400);
        }

        /* New modal for adding manual OT entry and date range */
        .manual-entry-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-out;
        }
        .manual-entry-modal.show {
            opacity: 1;
        }
        .manual-entry-modal-content {
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            min-width: 350px;
            max-width: 90%;
            border: 1px solid var(--gray-400);
            transform: scale(0.9);
            transition: transform 0.3s ease-out;
        }
        .manual-entry-modal.show .manual-entry-modal-content {
            transform: scale(1);
        }
        .manual-entry-modal-content h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--gray-900);
            margin-bottom: 15px;
        }
        .manual-entry-modal-content .input-group {
            margin-bottom: 20px;
        }
        .manual-entry-modal-content .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .form-content, .summary-sidebar {
                padding: 20px;
            }
            /* .ot-entry-row is already flex-col, so no change needed here */
            .ot-entry-row .remove-btn-container {
                display: flex;
                justify-content: flex-end; /* Align remove button to the right */
                margin-top: 10px;
            }
        }
        .ot-group-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f4f8; /* Lighter background for groups */
            border-radius: 10px;
            border: 1px solid #e2e8f0;
        }
        .ot-group-section h4 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #2d3748; /* Darker text for group headings */
            margin-bottom: 10px;
            border-bottom: 1px solid #cbd5e0;
            padding-bottom: 5px;
        }
        .loading-indicator {
            margin-left: 10px;
            font-size: 0.9em;
            color: var(--primary-indigo);
            font-weight: 500;
        }
        #userIdDisplay {
            font-size: 0.8em;
            color: var(--gray-600);
            text-align: right;
            margin-top: -15px;
            margin-bottom: 15px;
            word-break: break-all; /* Ensures long IDs wrap */
        }

        /* New highlight CSS */
        .highlight-new {
            animation: highlightFade 2s ease-out forwards;
        }

        @keyframes highlightFade {
            from { background-color: #e0f2fe; } /* Light blue */
            to { background-color: var(--gray-100); } /* Original background */
        }

        .new-badge {
            background-color: var(--success-green); /* Green-500 */
            color: white;
            padding: 2px 8px;
            border-radius: 9999px; /* Full rounded */
            font-size: 0.75rem; /* text-xs */
            font-weight: 600; /* font-semibold */
            margin-left: 8px; /* ml-2 */
            display: inline-block;
            vertical-align: middle;
        }

        /* Styles for inline summary display */
        .summary-inline-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Space between items */
            font-size: 1.0rem;
            color: var(--gray-800);
            margin-bottom: 8px;
        }
        .summary-inline-group strong {
            display: block; /* Ensure the strong tag is on its own line */
            width: 100%; /* Take full width */
            margin-bottom: 4px;
        }
        .summary-inline-item {
            display: inline-block;
            padding: 4px 8px;
            background-color: var(--light-indigo); /* Light indigo background */
            border-radius: 6px;
            color: var(--dark-indigo); /* Darker indigo text */
            font-weight: 500;
        }

        /* Collapsible section styles */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px 0;
            border-bottom: 1px solid #cbd5e0;
            margin-bottom: 15px;
        }
        .collapsible-header h3 {
            margin-bottom: 0; /* Override default margin */
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .collapsible-content.collapsed {
            max-height: 0 !important; /* Use !important to ensure override */
        }
        .collapsible-icon {
            transition: transform 0.3s ease-out;
        }
        .collapsible-icon.rotated {
            transform: rotate(90deg);
        }

        /* Input validation styles */
        .input-error {
            border-color: var(--danger-red); /* Red border */
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2); /* Light red shadow */
        }
        .error-message {
            color: var(--danger-red); /* Red text */
            font-size: 0.85rem;
            margin-top: 4px;
        }

        /* New styles for loading/success indicators */
        .status-message {
            margin-left: 10px;
            font-size: 0.9em;
            font-weight: 500;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        .status-message.show {
            opacity: 1;
        }
        .status-message.loading {
            color: var(--primary-indigo); /* Indigo */
        }
        .status-message.success {
            color: var(--success-green); /* Green */
        }
        .status-message.error {
            color: var(--danger-red); /* Red */
        }
        .no-entries-message {
            text-align: center;
            color: var(--gray-600);
            padding: 20px;
            border: 1px dashed var(--gray-400);
            border-radius: 8px;
            margin-top: 15px;
        }

        /* Styles for clear input button */
        .input-with-clear {
            position: relative;
            display: flex;
            align-items: center;
        }
        .input-with-clear input {
            padding-right: 36px; /* Make space for the button */
        }
        .clear-input-btn {
            position: absolute;
            right: 8px;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--gray-500); /* Gray-400 */
            padding: 4px;
            border-radius: 50%;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .clear-input-btn:hover {
            background-color: var(--gray-300); /* Gray-200 */
            color: var(--gray-700); /* Gray-700 */
        }

        /* New styles for allocation choice modal */
        .allocation-choice-modal .modal-buttons button {
            width: 100%; /* Make buttons full width in modal */
        }
        .allocation-choice-modal .modal-buttons {
            flex-direction: column; /* Stack buttons vertically */
        }

        /* Toggle switch styling */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-indigo); /* Indigo */
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-indigo);
        }

        input:checked + .slider:before {
            -webkit-transform: translateX(26px);
            -ms-transform: translateX(26px);
            transform: translateX(26px);
        }

        /* Toast Notification Styles */
        #toastContainer {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-width: 300px;
        }

        .toast {
            background-color: #333;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .toast.info { background-color: var(--info-blue); } /* Blue */
        .toast.success { background-color: var(--success-green); } /* Green */
        .toast.error { background-color: var(--danger-red); } /* Red */
        .toast.warning { background-color: var(--warning-orange); } /* Yellow/Orange */

        /* Loading Overlay Styles */
        #loadingOverlay {
            transition: opacity 0.3s ease-in-out;
        }
        .loader {
            border-top-color: var(--primary-indigo); /* Indigo */
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Tooltip Styles */
        .tooltip-container {
            position: relative;
            display: inline-flex; /* To make the icon align with text */
            align-items: center;
            margin-left: 0.5rem;
            cursor: help;
        }

        .tooltip-content {
            position: absolute;
            bottom: 100%; /* Position above the icon */
            left: 50%;
            transform: translateX(-50%) translateY(-0.5rem); /* Adjust for spacing */
            background-color: #333;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
            z-index: 10;
        }

        .tooltip-container:hover .tooltip-content {
            opacity: 1;
            transform: translateX(-50%) translateY(-1rem); /* Move up slightly on hover */
        }

        /* Chart container specific styles */
        .chart-container {
            position: relative;
            width: 100%;
            height: 256px; /* Fixed height for the canvas */
            display: flex; /* Use flexbox to center content */
            align-items: center; /* Center vertically */
            justify-content: center; /* Center horizontally */
            background-color: var(--gray-50); /* Light background for chart area */
            border-radius: 8px;
            overflow: hidden; /* Hide any overflow from chart */
        }
        .chart-placeholder {
            color: var(--gray-500);
            font-style: italic;
            text-align: center;
            padding: 1rem;
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="form-content">
            <h2 class="text-3xl font-extrabold text-center text-gray-900 mb-6">OT Calculator</h2>
            <div id="userIdDisplay" class="hidden"></div>

            <!-- How to Use Section (Collapsible) -->
            <div class="bg-blue-50 p-6 rounded-xl border border-blue-200 mb-6">
                <div class="collapsible-header" data-target="howToUseContent">
                    <h3 class="text-xl font-bold text-blue-800">How to Use This Calculator</h3>
                    <svg class="collapsible-icon h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="howToUseContent" class="collapsible-content">
                    <ul class="list-disc list-inside text-gray-700 space-y-2">
                        <li><strong>1. Employee Settings:</strong> Enter your basic monthly salary. Optionally, set a target OT pay.</li>
                        <li><strong>2. OT Planning Date Range:</strong> Define the period for which you want to calculate or plan your overtime.</li>
                        <li><strong>3. Public Holiday Management:</strong> Add any public holidays within your planning range. OT on these days will be calculated with a higher multiplier.</li>
                        <li><strong>4. OT Multiplier Settings:</strong> Adjust the overtime rates for different types of days (weekdays, off days, rest days, public holidays).</li>
                        <li><strong>5. Daily Overtime Entries:</strong>
                            <ul class="list-circle list-inside ml-4 mt-1 space-y-1">
                                <li>The **Allocation Strategy** is now set automatically:
                                    <ul>
                                        <li><strong>Target-Driven:</strong> Automatically selected when you set a "Target OT Pay". The calculator will allocate hours to meet your target. In this mode, daily OT hours are **randomized** to provide a more "humanized" distribution, while still aiming to hit the target.</li>
                                        <li><strong>Workload-Driven:</strong> Automatically selected when you have no target pay. Hours will be allocated for all days based on the "Workload Preset". In this mode, daily OT hours are **randomized** within the min/max ranges defined by the preset.</li>
                                    </ul>
                                </li>
                                <li>Select a **Workload Preset** (Light, Moderate, Heavy) to guide auto-allocation.</li>
                                <li>Click "Auto Allocate Hours" to generate entries. You will be prompted to either **auto allocate new entries (clearing existing)** or **fill remaining hours (keeping existing)**. For all newly allocated entries, the **start and end times are randomized**.</li>
                                <li>Click "Add OT Entry" to manually add entries for specific dates.</li>
                                <li>You can edit hours, dates, and types for each entry.</li>
                                <li>"Save Data" and "Load Data" buttons allow you to persist your entries.</li>
                            </ul>
                        </li>
                        <li><strong>6. Reset & Re-allocate All:</strong> Click this to clear all existing entries and perform a fresh auto-allocation.</li>
                        <li><strong>7. Calculation Summary:</strong> Review your total hours, pay per category, combined OT pay, and expected total salary.</li>
                        <li><strong>8. Export Summary:</strong> Save a text file with a detailed breakdown of your calculations.</li>
                    </ul>
                </div>
            </div>

            <!-- Employee Settings -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Employee Settings</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                    <div class="input-group">
                        <label for="basicSalary">Basic Monthly Salary (RM)</label>
                        <div class="input-with-clear">
                            <input type="number" id="basicSalary" value="3700.00" min="0" step="0.01" class="shadow-sm">
                            <button type="button" class="clear-input-btn" aria-label="Clear Basic Monthly Salary">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="targetOTPaySelect">Target OT Pay (RM) (Optional)</label>
                        <select id="targetOTPaySelect" class="shadow-sm mb-2">
                            <option value="">No Target</option>
                            <!-- Options will be dynamically added by JavaScript -->
                            <option value="custom">Other (Enter Manually)</option>
                        </select>
                        <div class="input-with-clear">
                            <input type="number" id="customTargetOTPayInput" class="shadow-sm hidden" placeholder="Enter custom target pay">
                            <button type="button" class="clear-input-btn hidden" id="clearCustomTargetOTPayBtn" aria-label="Clear Custom Target OT Pay">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
                <p class="text-sm text-gray-600 mt-4">
                    Working Schedule: 5 days/week, Saturday: Off Day, Sunday: Rest Day.
                    For payroll, employer uses 26 working days monthly.
                </p>
            </div>

            <!-- Date Range Container (Now a single input for range) -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">OT Planning Date Range</h3>
                <div class="input-group">
                    <label for="dateRangeInput">Select Date Range</label>
                    <div class="flex items-center gap-2">
                        <input type="text" id="dateRangeInput" class="shadow-sm flex-grow" placeholder="Click to select date range" readonly>
                        <button type="button" id="setThisMonthBtn" class="btn btn-secondary p-2" aria-label="Set date range to this month">
                            This Month
                        </button>
                    </div>
                    <div id="dateRangeError" class="error-message"></div>
                </div>
            </div>

            <!-- Public Holiday Management (Collapsible) -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <div class="collapsible-header" data-target="publicHolidaysContent">
                    <h3 class="text-xl font-bold text-gray-800">Public Holiday Management</h3>
                    <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="publicHolidaysContent" class="collapsible-content">
                    <div class="flex flex-col sm:flex-row gap-4 mb-4">
                        <div class="input-group flex-grow">
                            <label for="publicHolidayDate">Add Public Holiday Date</label>
                            <div class="flex items-center gap-2">
                                <input type="date" id="publicHolidayDate" class="shadow-sm flex-grow">
                                <button type="button" id="setPublicHolidayTodayBtn" class="btn btn-secondary p-2" aria-label="Set public holiday date to today">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <button id="addPublicHolidayDateBtn" class="btn btn-secondary mt-auto" aria-label="Add public holiday">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                            </svg>
                            Add Holiday
                        </button>
                    </div>
                    <ul id="publicHolidaysList" class="list-disc list-inside ml-4 text-gray-700">
                        <!-- Public holidays will be listed here -->
                    </ul>
                </div>
            </div>

            <!-- OT Multiplier Settings (Collapsible) -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <div class="collapsible-header" data-target="otMultiplierContent">
                    <h3 class="text-xl font-bold text-gray-800">OT Multiplier Settings</h3>
                    <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="otMultiplierContent" class="collapsible-content">
                    <div id="otMultiplierInputs" class="grid grid-cols-1 md:grid-cols-2 gap-5 mb-4">
                        <!-- Multiplier inputs will be dynamically generated here -->
                    </div>
                    <button id="resetMultipliersBtn" class="btn btn-secondary" aria-label="Reset OT multipliers to default">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-8a1 1 0 011-1h3a1 1 0 110 2H4a1 1 0 01-1-1zm11 0a1 1 0 011-1h3a1 1 0 110 2h-3a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Reset to Default Multipliers
                    </button>
                </div>
            </div>

            <!-- Daily OT Entries -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Daily Overtime Entries</h3>
                <div class="input-group mb-4">
                    <label for="allocationStrategy">Allocation Strategy
                        <span class="tooltip-container">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <span class="tooltip-content">This is set automatically based on Target OT Pay.</span>
                        </span>
                    </label>
                    <select id="allocationStrategy" class="shadow-sm" aria-describedby="allocationStrategyDescription">
                        <option value="Target-Driven">Target-Driven (using Workload Presets)</option>
                        <option value="Workload-Driven">Workload-Driven (Fill All Days)</option>
                    </select>
                    <p id="allocationStrategyDescription" class="text-sm text-gray-600 mt-2"></p>
                </div>
                <div id="workloadPresetGroup" class="input-group mb-4">
                    <label for="workloadPreset">Workload Preset for Auto Allocation
                        <span class="tooltip-container">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                            </svg>
                            <span class="tooltip-content">Defines min/max hours for different day types.</span>
                        </span>
                    </label>
                    <select id="workloadPreset" class="shadow-sm" aria-describedby="workloadPresetDescription">
                        <option value="Moderate Workload">Moderate Workload</option>
                        <option value="Light Workload">Light Workload</option>
                        <option value="Heavy Workload">Heavy Workload</option>
                    </select>
                    <p id="workloadPresetDescription" class="text-sm text-gray-600 mt-2"></p>
                </div>
                <!-- Dynamic Workload Preset Details -->
                <div id="workloadPresetDetails" class="text-sm text-gray-700 mb-4 p-3 bg-gray-100 rounded-md border border-gray-200">
                    <!-- Details will be inserted here by JavaScript -->
                </div>

                <div class="flex flex-col sm:flex-row gap-4 mb-4">
                    <button id="autoAllocateBtn" class="btn btn-secondary flex-grow" aria-label="Auto allocate hours">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-8a1 1 0 011-1h3a1 1 0 110 2H4a1 1 0 01-1-1zm11 0a1 1 0 011-1h3a1 1 0 110 2h-3a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Auto Allocate Hours
                        <span id="autoAllocateLoading" class="loading-indicator hidden" aria-live="polite">Allocating...</span>
                    </button>
                </div>

                <div id="otEntriesContainer">
                    <!-- OT entry rows will be added here by JavaScript -->
                    <p id="noEntriesMessage" class="no-entries-message hidden">No OT entries yet. Click "Add OT Entry" or "Auto Allocate Hours" to get started!</p>
                </div>
                <div class="flex flex-col sm:flex-row gap-4 mt-4">
                    <button id="addOTEntryBtn" class="btn btn-secondary flex-grow" aria-label="Add new OT entry">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        Add OT Entry
                    </button>
                    <button id="clearAllEntriesBtn" class="btn btn-danger flex-grow" aria-label="Clear all OT entries">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                    </svg>
                        Clear All Entries
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row gap-4 mt-4">
                    <button id="saveDataBtn" class="btn btn-primary flex-grow" aria-label="Save current data">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M7 3a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1V4a1 1 0 00-1-1H7z" />
                            <path fill-rule="evenodd" d="M18 8H2a2 2 0 00-2 2v8a2 2 0 002 2h16a2 2 0 002-2v-8a2 2 0 00-2-2zM4 13a1 1 0 011-1h10a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3z" clip-rule="evenodd" />
                        </svg>
                        Save Data
                        <span id="saveDataStatus" class="status-message" aria-live="polite"></span>
                    </button>
                    <button id="loadDataBtn" class="btn btn-secondary flex-grow" aria-label="Load saved data">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Load Data
                        <span id="loadDataStatus" class="status-message" aria-live="polite"></span>
                    </button>
                </div>
            </div>

            <!-- Firebase Toggle Button -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mt-6 flex items-center justify-between">
                <label for="firebaseToggle" class="text-xl font-bold text-gray-800 cursor-pointer">
                    Enable Firebase (Save/Load)
                </label>
                <label class="toggle-switch">
                    <input type="checkbox" id="firebaseToggle">
                    <span class="slider"></span>
                </label>
            </div>
            <p id="firebaseStatusMessage" class="text-sm text-gray-600 mt-2 text-center"></p>

            <!-- NEW: Reset & Re-allocate All button moved here -->
            <button id="resetAndReallocateBtn" class="btn btn-danger w-full mt-4" aria-label="Reset all and re-allocate">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M4 2a1 1 0 011 1v2.118a1 1 0 01-.293.707l-2.118 2.118A1 1 0 012 8v8a2 2 0 002 2h12a2 2 0 002-2V8a1 1 0 01-.293-.707l-2.118-2.118A1 1 0 0115 5.118V3a1 1 0 011-1h-2a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H7a1 1 0 01-1-1V1a1 1 0 10-2 0v1a1 1 0 01-1 1H4zm2 5V4h8v3H6zm-2 4h12V9H4v2zm0 2h12v3H4v-3z" clip-rule="evenodd" />
                </svg>
                Reset & Re-allocate All
            </button>
        </div>

        <!-- Results Section (Moved to a sticky sidebar) -->
        <div class="summary-sidebar">
            <div id="results" class="results-section">
                <h3 class="text-2xl font-bold text-gray-900 mb-4">Calculation Summary</h3>
                <!-- Changed to inline display -->
                <div class="summary-inline-group">
                    <strong>Total OT Hours by Type:</strong>
                    <span id="totalHoursByType" class="text-gray-700"></span>
                </div>
                <div class="summary-inline-group">
                    <strong>Total Pay per OT Category:</strong>
                    <span id="totalPayByCategory" class="text-gray-700"></span>
                </div>
                <!-- End of changes for inline display -->
                <p class="text-base font-bold text-gray-900 mt-2">Allocation Strategy: <span id="allocationStrategySummary" class="text-gray-700"></span></p>
                <p class="text-xl font-bold text-gray-900 mt-6">Combined OT Pay: <span id="combinedOTPay" class="text-indigo-600">RM 0.00</span></p>
                <p class="text-xl font-bold text-gray-900 mt-2">Target OT Pay: <span id="targetOTPayDisplay" class="text-green-600">RM 0.00</span></p>
                <p class="text-xl font-bold mt-2">Difference from Target: <span id="differenceFromTarget">RM 0.00</span></p>
                <p class="text-xl font-bold mt-2">Total Monthly OT Hours: <span id="totalMonthlyOTHoursDisplay">0.0 hours</span></p>
                <!-- New: Expected Salary Pay -->
                <p class="text-xl font-bold text-gray-900 mt-2">Expected Salary Pay: <span id="expectedSalaryPayDisplay" class="text-indigo-600">RM 0.00</span></p>

                <!-- Chart for OT Distribution -->
                <h4 class="text-lg font-bold text-gray-800 mt-6 mb-2">OT Pay Distribution</h4>
                <div class="chart-container">
                    <canvas id="otDistributionChart" class="w-full h-full"></canvas>
                    <p id="chartPlaceholder" class="chart-placeholder absolute hidden">No OT data to display. Add entries and calculate!</p>
                </div>

                <button id="exportSummaryBtn" class="btn btn-secondary mt-6" aria-label="Export OT summary to text file">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l2.293-2.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    Export Summary
                </button>
            </div>
        </div>
    </div>

    <!-- Message Box HTML -->
    <div id="messageBox" class="message-box hidden" role="dialog" aria-modal="true" aria-labelledby="messageBoxTitle" aria-describedby="messageBoxContent">
        <h4 id="messageBoxTitle"></h4>
        <p id="messageBoxContent"></p>
        <div class="message-box-buttons">
            <button id="messageBoxCancelBtn" class="btn btn-cancel hidden">Cancel</button>
            <button id="messageBoxConfirmBtn" class="hidden">Confirm</button>
            <button id="messageBoxCloseBtn">OK</button>
        </div>
    </div>

    <!-- NEW: Detailed OT Entry Modal -->
    <div id="addDetailedOTEntryModal" class="manual-entry-modal hidden" role="dialog" aria-modal="true" aria-labelledby="detailedEntryModalTitle">
        <div class="manual-entry-modal-content">
            <h4 id="detailedEntryModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Add Detailed OT Entry</h4>
            <div class="input-group">
                <label for="detailedEntryDate">Select Date</label>
                <input type="date" id="detailedEntryDate" class="shadow-sm">
                <div id="detailedEntryDateError" class="error-message text-left"></div>
            </div>
            <div class="input-group">
                <label for="detailedEntryHours">Hours</label>
                <input type="number" id="detailedEntryHours" value="2.0" min="0.5" step="0.5" class="shadow-sm">
                <div id="detailedEntryHoursError" class="error-message text-left"></div>
            </div>
            <div class="input-group">
                <label for="detailedEntryStartTime">Start Time</label>
                <input type="time" id="detailedEntryStartTime" value="18:00" class="shadow-sm">
                <div id="detailedEntryStartTimeError" class="error-message text-left"></div>
            </div>
            <div class="input-group">
                <label for="detailedEntryEndTime">End Time (Calculated)</label>
                <input type="time" id="detailedEntryEndTime" class="shadow-sm" readonly>
            </div>
            <div class="modal-buttons">
                <button id="cancelDetailedEntryBtn" class="btn btn-cancel">Cancel</button>
                <button id="confirmDetailedEntryBtn" class="btn btn-primary">Add Entry</button>
            </div>
        </div>
    </div>

    <!-- NEW: Allocation Choice Modal -->
    <div id="allocationChoiceModal" class="manual-entry-modal hidden allocation-choice-modal" role="dialog" aria-modal="true" aria-labelledby="allocationChoiceModalTitle">
        <div class="manual-entry-modal-content">
            <h4 id="allocationChoiceModalTitle" class="text-2xl font-bold text-gray-900 mb-4">Auto-Allocation Options</h4>
            <p class="text-gray-700 mb-6">How would you like to allocate overtime hours?</p>
            <div class="modal-buttons">
                <button id="clearAndAllocateBtn" class="btn btn-danger">
                    Auto Allocate
                </button>
                <button id="fillRemainingBtn" class="btn btn-primary mt-4">
                    Fill Remaining Hours
                </button>
                <button id="cancelAllocationChoiceBtn" class="btn btn-secondary mt-4">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Global Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-[3000] hidden">
        <div class="loader ease-linear rounded-full border-8 border-t-8 border-gray-200 h-16 w-16"></div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer"></div>

    <script type="module">
        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        // Flatpickr JS and Chart.js are now loaded globally via separate <script> tags in the head.

        // --- Configuration Constants (Moved to global scope for easy access if needed, but could be inside IIFE) ---
        const DEFAULT_OT_MULTIPLIERS = { // Store original defaults
            'Normal OT (Weekdays)': 1.5,
            'Off Day (Saturday)': 1.5,
            'Rest Day (Sunday) — 1st 8h': 0.5,
            'Rest Day (Sunday) — after 8h': 2.0,
            'Public Holiday': 2.0
        };

        const PREDEFINED_TARGET_PAYS = [
            1000.00,
            2000.00,
            3000.00,
            4000.00,
            5000.00
        ];

        const CONFIG = {
            WORKING_DAYS_MONTHLY: 26,
            STANDARD_WORK_HOURS_DAILY: 8,
            MAX_DAILY_OT_HOURS: 8, // Max 8 hours OT per day as per typical regulations
            ALLOCATION_PRECISION: 0.01, // Small value to handle floating point comparisons
            OT_MULTIPLIERS: { ...DEFAULT_OT_MULTIPLIERS }, // Current multipliers, can be changed by user
            // Define preferred allocation ranges for auto-allocation based on workload presets
            WORKLOAD_PRESETS: {
                'Light Workload': {
                    'Normal OT (Weekdays)': { minHours: 1, maxHours: 5 }, // Increased from 4
                    'Off Day (Saturday)': { minHours: 2, maxHours: 5 },
                    'Rest Day (Sunday) — 1st 8h': { minHours: 2, maxHours: 6 },
                    'Rest Day (Sunday) — after 8h': { minHours: 0.5, maxHours: 3 }
                },
                'Moderate Workload': {
                    'Normal OT (Weekdays)': { minHours: 2, maxHours: 7 }, // Increased from 6
                    'Off Day (Saturday)': { minHours: 3, maxHours: 8 },
                    'Rest Day (Sunday) — 1st 8h': { minHours: 4, maxHours: 8 },
                    'Rest Day (Sunday) — after 8h': { minHours: 1, maxHours: 6 }
                },
                'Heavy Workload': {
                    'Normal OT (Weekdays)': { minHours: 3, maxHours: 6 },
                    'Off Day (Saturday)': { minHours: 5, maxHours: 8 },
                    'Rest Day (Sunday) — 1st 8h': { minHours: 6, maxHours: 8 },
                    'Rest Day (Sunday) — after 8h': { minHours: 3, maxHours: 8 }
                }
            },
            // Define base allocation steps (these will be overridden by presets for min/max hours)
            ALLOCATION_STEPS: [
                { type: 'Normal OT (Weekdays)', days: [1, 2, 3, 4, 5] }, // Mon-Fri
                { type: 'Off Day (Saturday)', days: [6] }, // Saturday
                { type: 'Rest Day (Sunday) — 1st 8h', days: [0] },
                { type: 'Rest Day (Sunday) — after 8h', days: [0] },
            ]
        };

        // --- Main Application Logic (Encapsulated in an IIFE) ---
        (async () => {
            let db;
            let auth;
            let userId;
            let isAuthReady = false; // Flag to ensure Firestore operations wait for auth
            let isFirebaseEnabled = JSON.parse(localStorage.getItem('isFirebaseEnabled') || 'true'); // Default to true if not set
            let publicHolidayDatePickerInstance; // Flatpickr instance for public holiday date picker
            let detailedDatePickerInstance; // NEW: Flatpickr instance for detailed entry date picker
            let detailedStartTimePickerInstance; // NEW: Flatpickr instance for detailed entry start time
            let dateRangePickerInstance; // NEW: Flatpickr instance for the date range input

            // --- State Variables ---
            let otEntries = []; // Stores objects like { id, date, hours, type, startTime, endTime, isNew }
            let publicHolidays = []; // Stores public holiday dates as YYYY-MM-DD strings
            let entryCounter = 0; // To generate unique IDs for each entry row
            let selectedWorkloadPreset = 'Moderate Workload'; // Default value
            let selectedAllocationStrategy = 'Target-Driven'; // Default value


            // --- DOM Elements (declared globally for easier access in functions) ---
            let basicSalaryInput;
            let clearBasicSalaryBtn;
            let targetOTPaySelect;
            let customTargetOTPayInput;
            let clearCustomTargetOTPayBtn;
            let dateRangeInput; // Changed from startDateInput/endDateInput
            let dateRangeError; // New error element for date range
            let setThisMonthBtn; // New button for setting current month
            let publicHolidayDateInput;
            let addPublicHolidayDateBtn;
            let publicHolidaysList;
            let otMultiplierInputsContainer;
            let resetMultipliersBtn;
            let allocationStrategySelect;
            let allocationStrategyDescription;
            let workloadPresetSelect;
            let workloadPresetGroup; // Parent div for workloadPresetSelect
            let workloadPresetDescription;
            let workloadPresetDetails;
            let otEntriesContainer;
            let noEntriesMessage;
            let addOTEntryBtn;
            let autoAllocateBtn;
            let autoAllocateLoading;
            let resetAndReallocateBtn;
            let clearAllEntriesBtn;
            // Removed calculateBtn
            let saveDataBtn;
            let loadDataBtn;
            let resultsSection;
            let totalHoursByTypeElem;
            let totalPayByCategoryElem;
            let combinedOTPayElem;
            let targetOTPayDisplayElem;
            let differenceFromTargetElem;
            let totalMonthlyOTHoursDisplay;
            let expectedSalaryPayDisplay;
            let exportSummaryBtn;
            let userIdDisplay;
            let allocationStrategySummary; // NEW: For displaying allocation strategy in summary

            let messageBox;
            let messageBoxTitle;
            let messageBoxContent;
            let messageBoxCloseBtn;
            let messageBoxConfirmBtn;
            let messageBoxCancelBtn;

            let addDetailedOTEntryModal;
            let detailedEntryModalTitle;
            let detailedEntryDate;
            let detailedEntryDateError;
            let detailedEntryHours;
            let detailedEntryHoursError;
            let detailedEntryStartTime;
            let detailedEntryStartTimeError;
            let detailedEntryEndTime;
            let confirmDetailedEntryBtn;
            let cancelDetailedEntryBtn;

            let allocationChoiceModal;
            let clearAndAllocateBtn;
            let fillRemainingBtn;
            let cancelAllocationChoiceBtn;

            let setPublicHolidayTodayBtn;

            let collapsibleHeaders;
            let publicHolidaysContent;
            let otMultiplierContent;
            let howToUseContent;

            let saveDataStatus;
            let loadDataStatus;

            let firebaseToggle;
            let firebaseStatusMessage;

            let loadingOverlay; // Global loading overlay
            let toastContainer; // Toast notification container
            let otDistributionChartInstance; // Chart.js instance
            let chartPlaceholder; // New chart placeholder element


            // --- Utility Functions ---

            /**
             * Debounce function to limit how often a function can run.
             * @param {Function} func - The function to debounce.
             * @param {number} delay - The delay in milliseconds.
             * @returns {Function} The debounced function.
             */
            function debounce(func, delay) {
                let timeout;
                return function(...args) {
                    const context = this;
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(context, args), delay);
                };
            }

            /**
             * Yields control to the browser event loop, preventing UI freezes.
             * @returns {Promise<void>} A promise that resolves after a short delay.
             */
            async function yieldControl() {
                return new Promise(resolve => setTimeout(resolve, 0));
            }

            /**
             * Displays a custom message box.
             * @param {string} title - The title of the message box.
             * @param {string} message - The content message.
             * @param {string} type - 'info' (default) or 'confirm'.
             * @param {function} [confirmCallback] - Callback function for 'confirm' type when confirmed.
             */
            function showMessageBox(title, message, type = 'info', confirmCallback = null) {
                if (type === 'info') {
                    showToast(message, 'info'); // Use toast for simple info messages
                    return;
                }

                messageBoxTitle.textContent = title;
                messageBoxContent.textContent = message;

                // Reset buttons visibility
                messageBoxCloseBtn.classList.add('hidden');
                messageBoxConfirmBtn.classList.add('hidden');
                messageBoxCancelBtn.classList.add('hidden');

                if (type === 'confirm') {
                    messageBoxConfirmBtn.onclick = () => {
                        messageBox.classList.add('hidden');
                        messageBox.classList.remove('show');
                        if (confirmCallback) {
                            confirmCallback();
                        }
                        // Return focus to the element that triggered the modal
                        if (window.lastFocusedElement) {
                            window.lastFocusedElement.focus();
                        }
                    };
                    messageBoxCancelBtn.onclick = () => {
                        messageBox.classList.add('hidden');
                        messageBox.classList.remove('show');
                        // Return focus to the element that triggered the modal
                        if (window.lastFocusedElement) {
                            window.lastFocusedElement.focus();
                        }
                    };
                    messageBoxConfirmBtn.classList.remove('hidden');
                    messageBoxCancelBtn.classList.remove('hidden');
                } else { // 'info' type (should be handled by toast, but fallback)
                    messageBoxCloseBtn.onclick = () => {
                        messageBox.classList.add('hidden');
                        messageBox.classList.remove('show');
                        // Return focus to the element that triggered the modal
                        if (window.lastFocusedElement) {
                            window.lastFocusedElement.focus();
                        }
                    };
                    messageBoxCloseBtn.classList.remove('hidden');
                }
                messageBox.classList.remove('hidden');
                messageBox.classList.add('show'); // Add show class for animation
                // Store the currently focused element before showing the modal
                window.lastFocusedElement = document.activeElement;
                // Focus the first interactive element in the modal
                messageBoxConfirmBtn.focus();
            }

            /**
             * Displays a temporary toast notification.
             * @param {string} message - The message to display.
             * @param {'info'|'success'|'error'|'warning'} type - The type of toast.
             */
            function showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.classList.add('toast', type);
                toast.textContent = message;
                toastContainer.appendChild(toast);

                // Force reflow to ensure the animation plays
                void toast.offsetWidth;

                toast.classList.add('show');

                setTimeout(() => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => {
                        toast.remove();
                    }, { once: true });
                }, 3000); // Toast disappears after 3 seconds
            }

            /**
             * Displays the global loading overlay.
             */
            function showLoadingOverlay() {
                loadingOverlay.classList.remove('hidden');
                loadingOverlay.style.opacity = '0'; // Start transparent
                // Force reflow
                void loadingOverlay.offsetWidth;
                loadingOverlay.style.opacity = '1'; // Fade in
            }

            /**
             * Hides the global loading overlay.
             */
            function hideLoadingOverlay() {
                loadingOverlay.style.opacity = '0'; // Fade out
                loadingOverlay.addEventListener('transitionend', function handler() {
                    loadingOverlay.classList.add('hidden');
                    loadingOverlay.removeEventListener('transitionend', handler);
                }, { once: true });
            }


            /**
             * Displays a temporary status message next to a button.
             * @param {HTMLElement} statusElement - The span element to display the status.
             * @param {string} message - The message to display.
             * @param {string} type - 'loading', 'success', or 'error'.
             */
            function showStatusMessage(statusElement, message, type) {
                statusElement.textContent = message;
                statusElement.className = `status-message show ${type}`;
                // For accessibility, ensure the message is announced if it's dynamic status
                statusElement.setAttribute('aria-live', 'polite');
                if (type !== 'loading') {
                    setTimeout(() => {
                        statusElement.classList.remove('show');
                        statusElement.removeAttribute('aria-live'); // Remove aria-live when hidden
                    }, 2000); // Hide after 2 seconds for success/error
                }
            }

            /**
             * Populates the target OT pay dropdown with predefined values.
             */
            function populateTargetOTPayDropdown() {
                // Clear existing options except "No Target" and "Other"
                targetOTPaySelect.innerHTML = '<option value="">No Target</option>';
                PREDEFINED_TARGET_PAYS.forEach(amount => {
                    const option = document.createElement('option');
                    option.value = amount.toFixed(2);
                    option.textContent = `RM ${amount.toFixed(2)}`;
                    targetOTPaySelect.appendChild(option);
                });
                const otherOption = document.createElement('option');
                otherOption.value = 'custom';
                otherOption.textContent = 'Other (Enter Manually)';
                targetOTPaySelect.appendChild(otherOption);
            }

            /**
             * Handles the change event for the target OT pay dropdown.
             * Shows/hides the custom input field and its clear button.
             */
            function handleTargetOTPayChange() {
                if (targetOTPaySelect.value === 'custom') {
                    customTargetOTPayInput.classList.remove('hidden');
                    clearCustomTargetOTPayBtn.classList.remove('hidden');
                    customTargetOTPayInput.focus();
                } else {
                    customTargetOTPayInput.classList.add('hidden');
                    clearCustomTargetOTPayBtn.classList.add('hidden');
                    customTargetOTPayInput.value = ''; // Clear custom input when not in use
                }
                updateAllocationStrategyBasedOnTarget(); // NEW: Update strategy based on target change
                calculateAndDisplayResults(); // Recalculate on target change
            }

            /**
             * Retrieves the current target OT pay value, handling both dropdown and custom input.
             * @returns {number | null} The target OT pay as a number, or null if no target is set.
             */
            function getTargetOTPayValue() {
                if (targetOTPaySelect.value === 'custom') {
                    const customValue = parseFloat(customTargetOTPayInput.value);
                    return isNaN(customValue) ? null : customValue;
                } else if (targetOTPaySelect.value === '') {
                    return null;
                } else {
                    return parseFloat(targetOTPaySelect.value);
                }
            }

            /**
             * Calculates the basic hourly rate.
             * @param {number} monthlySalary - The employee's basic monthly salary.
             * @returns {number} The calculated basic hourly rate.
             */
            function calculateHourlyRate(monthlySalary) {
                if (monthlySalary <= 0) return 0;
                return monthlySalary / CONFIG.WORKING_DAYS_MONTHLY / CONFIG.STANDARD_WORK_HOURS_DAILY;
            }

            /**
             * Calculates the OT pay for a given entry.
             * @param {number} hours - The number of OT hours.
             * @param {string} type - The type of OT (e.g., 'Normal OT (Weekdays)').
             * @param {string} date - The date of the OT entry (YYYY-MM-DD).
             * @returns {number} The calculated OT pay.
             */
            function calculateOT(hourlyRate, hours, type, date) {
                let multiplier = CONFIG.OT_MULTIPLIERS[type];

                // Override multiplier if it's a public holiday and the type is not already Public Holiday
                if (isPublicHoliday(date) && type !== 'Public Holiday') {
                    multiplier = CONFIG.OT_MULTIPLIERS['Public Holiday'];
                }
                
                if (multiplier === undefined) {
                    console.warn(`Unknown OT type or multiplier for type: ${type}`);
                    return 0; // Return 0 if multiplier is not found
                }

                return hourlyRate * multiplier * hours;
            }

            /**
             * Formats a number to RM currency string.
             * @param {number} amount - The amount to format.
             * @returns {string} Formatted currency string (e.g., "RM 123.45").
             */
            function formatCurrency(amount) {
                return `RM ${amount.toFixed(2)}`;
            }

            /**
             * Gets the current date in YYYY-MM-DD format.
             * @returns {string} The current date string.
             */
            function getTodayDateString() {
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            /**
             * Generates a random time (HH:MM) within a given hour range, at 15-minute intervals.
             * @param {number} minHour - The minimum hour (inclusive).
             * @param {number} maxHour - The maximum hour (exclusive).
             * @returns {string} The random time in "HH:MM" format.
             */
            function getRandomTime(minHour, maxHour) {
                const hours = Math.floor(Math.random() * (maxHour - minHour)) + minHour;
                const minutesOptions = [0, 15, 30, 45];
                const minutes = minutesOptions[Math.floor(Math.random() * minutesOptions.length)];
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }

            /**
             * Adds hours to a given time string (HH:MM) and returns a new time string.
             * Handles crossing midnight (though for OT, typically hours reset per day).
             * @param {string} startTimeStr - The start time in "HH:MM" format.
             * @param {number} hoursToAdd - The hours to add (can be decimal like 3.5).
             * @returns {string} The new time in "HH:MM" format.
             */
            function addHoursToTime(startTimeStr, hoursToAdd) {
                if (!startTimeStr) return ''; // Handle cases where start time is not set
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                let totalMinutes = startHour * 60 + startMinute + (hoursToAdd * 60);

                let newHour = Math.floor(totalMinutes / 60) % 24; // % 24 to handle midnight crossing
                let newMinute = Math.round(totalMinutes % 60);

                // Handle cases like 59.9 minutes becoming 60, or 60.1 minutes becoming 60.
                if (newMinute === 60) {
                    newMinute = 0;
                    newHour = (newHour + 1) % 24;
                }

                return `${String(newHour).padStart(2, '0')}:${String(newMinute).padStart(2, '0')}`;
            }

            /**
             * Calculates and updates the suggested start and end times for a given OT entry.
             * This function modifies the entry object directly.
             * @param {Object} entry - The OT entry object to update.
             * @param {string} [prevEndTimeForDay] - Optional: The end time of a previous OT entry on the same day, for chaining.
             */
            function calculateSuggestedTimes(entry, prevEndTimeForDay = null) {
                let suggestedStartTime = '';

                if (entry.type === 'Normal OT (Weekdays)') {
                    // Start anytime after 6 PM (18:00)
                    suggestedStartTime = getRandomTime(18, 20); // Random between 6 PM and 7:45 PM
                } else if (entry.type === 'Off Day (Saturday)' || entry.type === 'Public Holiday' || entry.type === 'Rest Day (Sunday) — 1st 8h') {
                    // Start anytime after 9 AM (09:00)
                    suggestedStartTime = getRandomTime(9, 11); // Random between 9 AM and 10:45 AM
                } else if (entry.type === 'Rest Day (Sunday) — after 8h') {
                    // If there's a preceding entry for the same day, use its end time
                    if (prevEndTimeForDay) {
                        suggestedStartTime = prevEndTimeForDay;
                    } else {
                        // Otherwise, start anytime after 5 PM (17:00)
                        suggestedStartTime = getRandomTime(17, 19); // Random between 5 PM and 6:45 PM
                    }
                }

                // Ensure a default start time if none of the above conditions were met
                if (!suggestedStartTime) {
                    suggestedStartTime = '09:00'; // Default to 9 AM if type is unrecognized or logic fails
                }

                entry.startTime = suggestedStartTime;
                entry.endTime = addHoursToTime(entry.startTime, entry.hours);
            }


            /**
             * Clears all existing OT entry rows from the UI and the internal state.
             * This is a helper function used by `clearDailyOTEntries` and `autoAllocateHours`.
             */
            function clearOTEntries() {
                otEntries = [];
                otEntriesContainer.innerHTML = '';
                entryCounter = 0; // Reset counter when clearing
                noEntriesMessage.classList.remove('hidden'); // Show no entries message
            }

            /**
             * Helper to determine the default OT type based on date (day of week).
             * This is used for grouping purposes in the UI.
             * @param {string} dateString - The date string (YYYY-MM-DD).
             * @returns {string} The default OT type for that date.
             */
            function getDefaultOTTypeForDate(dateString) {
                const date = new Date(dateString);
                const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                if (isPublicHoliday(dateString)) {
                    return 'Public Holiday';
                } else if (dayOfWeek === 0) { // Sunday
                    return 'Rest Day (Sunday) — 1st 8h'; // Default to 1st 8h for grouping Sundays
                } else if (dayOfWeek === 6) { // Saturday
                    return 'Off Day (Saturday)';
                } else { // Weekday (Monday to Friday)
                    return 'Normal OT (Weekdays)';
                }
            }

            /**
             * Renders the OT entries from the `otEntries` array to the UI, grouped by OT type.
             * This function is responsible for updating the display, not modifying the `otEntries` array itself.
             * It now uses requestAnimationFrame to prevent UI freezes during rendering of many entries.
             */
            async function renderOTEntries() {
                otEntriesContainer.innerHTML = ''; // Clear current UI

                // NEW: Filter entries to only display those within the current date range
                const selectedDates = dateRangePickerInstance.selectedDates;
                const startDate = selectedDates[0] ? new Date(selectedDates[0].toISOString().split('T')[0]) : null;
                const endDate = selectedDates[1] ? new Date(selectedDates[1].toISOString().split('T')[0]) : null;

                let entriesToDisplay = otEntries;
                if (startDate && endDate) {
                    entriesToDisplay = otEntries.filter(entry => {
                        const entryDate = new Date(entry.date);
                        // Compare dates without time components
                        return entryDate.setHours(0,0,0,0) >= startDate.setHours(0,0,0,0) && entryDate.setHours(0,0,0,0) <= endDate.setHours(0,0,0,0);
                    });
                }

                if (entriesToDisplay.length === 0) {
                    noEntriesMessage.classList.remove('hidden');
                } else {
                    noEntriesMessage.classList.add('hidden');
                }

                // Augment entries with a displayType for grouping
                const entriesWithDisplayType = entriesToDisplay.map(entry => { // Use entriesToDisplay here
                    let resolvedDisplayType;
                    if (isPublicHoliday(entry.date)) {
                        resolvedDisplayType = 'Public Holiday';
                    } else {
                        // If not a public holiday, group based on the actual day of the week
                        resolvedDisplayType = getDefaultOTTypeForDate(entry.date);
                    }
                    return { ...entry, displayType: resolvedDisplayType };
                });

                // Group entries by their resolved displayType
                const groupedEntries = entriesWithDisplayType.reduce((acc, entry) => {
                    if (!acc[entry.displayType]) {
                        acc[entry.displayType] = [];
                    }
                    acc[entry.displayType].push(entry);
                    return acc;
                }, {});

                // Define a preferred order for displaying OT types, ensuring Public Holiday is included
                const preferredOrder = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday' // Ensure Public Holiday is in the display order
                ];

                // Render each group
                for (const displayType of preferredOrder) { // Iterate over displayType
                    if (groupedEntries[displayType] && groupedEntries[displayType].length > 0) {
                        const groupSection = document.createElement('div');
                        groupSection.classList.add('ot-group-section');

                        const groupTitle = document.createElement('h4');
                        groupTitle.textContent = displayType; // Use displayType for group title
                        groupSection.appendChild(groupTitle);

                        // Sort entries within each group by date
                        groupedEntries[displayType].sort((a, b) => new Date(a.date) - new Date(b.date));

                        for (const entry of groupedEntries[displayType]) {
                            // Use requestAnimationFrame to yield control for each entry
                            await new Promise(resolve => requestAnimationFrame(() => {
                                const entryId = entry.id;
                                const newRow = document.createElement('div');
                                newRow.classList.add('ot-entry-row', 'flex', 'flex-col', 'gap-4');
                                newRow.setAttribute('data-id', entryId);

                                if (entry.isNew) {
                                    newRow.classList.add('highlight-new');
                                    setTimeout(() => {
                                        newRow.classList.remove('highlight-new');
                                        // Remove the isNew flag after highlighting
                                        const entryIndex = otEntries.findIndex(e => e.id === entryId);
                                        if (entryIndex !== -1) {
                                            delete otEntries[entryIndex].isNew;
                                        }
                                    }, 2000);
                                }

                                // Determine the type that should be selected in the dropdown
                                const typeToDisplayInDropdown = isPublicHoliday(entry.date) ? 'Public Holiday' : entry.type;

                                newRow.innerHTML = `
                                    <!-- Date and Hours (1st line) -->
                                    <div class="grid grid-cols-2 gap-4 items-end">
                                        <div class="input-group">
                                            <label for="${entryId}-date">Date${entry.isNew ? '<span class="new-badge">New</span>' : ''}</label>
                                            <input type="date" id="${entryId}-date" value="${entry.date}" class="shadow-sm">
                                        </div>
                                        <div class="input-group">
                                            <label for="${entryId}-hours">Hours</label>
                                            <input type="number" id="${entryId}-hours" value="${entry.hours.toFixed(1)}" min="0" step="0.5" class="shadow-sm">
                                            <div id="${entryId}-hours-error" class="error-message"></div>
                                        </div>
                                    </div>

                                    <!-- Start Time & End Time (2nd line) -->
                                    <div class="flex gap-4">
                                        <div class="input-group flex-1">
                                            <label for="${entryId}-start-time">Start Time</label>
                                            <input type="time" id="${entryId}-start-time" value="${entry.startTime}" class="shadow-sm"> <!-- Removed readonly -->
                                            <div id="${entryId}-start-time-error" class="error-message"></div>
                                        </div>
                                        <div class="input-group flex-1">
                                            <label for="${entryId}-end-time">End Time</label>
                                            <input type="time" id="${entryId}-end-time" class="shadow-sm" readonly>
                                        </div>
                                    </div>

                                    <!-- OT Type and Remove Button (3rd line) -->
                                    <div class="grid grid-cols-[1.8fr_auto] gap-4 items-end"> <!-- Adjusted grid for OT Type and Remove -->
                                        <div class="input-group">
                                            <label for="${entryId}-type">OT Type</label>
                                            <select id="${entryId}-type" class="shadow-sm">
                                                ${Object.keys(DEFAULT_OT_MULTIPLIERS).map(otType => `
                                                    <option value="${otType}">${otType}</option>
                                                `).join('')}
                                            </select>
                                        </div>
                                        <div class="remove-btn-container flex justify-end">
                                            <button type="button" class="btn btn-danger btn-sm remove-ot-entry-btn" data-id="${entryId}" aria-label="Remove OT entry for ${entry.date}">
                                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                                    <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                `;
                                groupSection.appendChild(newRow);

                                // Explicitly set the value of the select element after it's in the DOM
                                const typeSelect = newRow.querySelector(`#${entryId}-type`);
                                if (typeSelect) {
                                    typeSelect.value = typeToDisplayInDropdown; // Set the value here
                                }

                                // Explicitly set the value for the end time input
                                const endTimeInput = newRow.querySelector(`#${entryId}-end-time`);
                                if (endTimeInput) {
                                    endTimeInput.value = entry.endTime;
                                }

                                // Initialize Flatpickr for each date input in the rendered entries
                                const dateInput = newRow.querySelector(`#${entryId}-date`);
                                if (dateInput) {
                                    // Disable all dates that are already used by other entries
                                    const disabledDates = otEntries
                                        .filter(e => e.id !== entryId) // Exclude the current entry's date
                                        .map(e => e.date);

                                    window.flatpickr(dateInput, {
                                        dateFormat: "Y-m-d",
                                        minDate: dateRangePickerInstance.selectedDates[0] ? dateRangePickerInstance.selectedDates[0] : null, // Enforce planning range
                                        maxDate: dateRangePickerInstance.selectedDates[1] ? dateRangePickerInstance.selectedDates[1] : null,   // Enforce planning range
                                        disable: disabledDates,
                                        onChange: function(selectedDates, dateStr, instance) {
                                            // Manually trigger the updateOTEntry logic
                                            updateOTEntry(entryId, 'date', dateStr);
                                        }
                                    });
                                }

                                // Initialize Flatpickr for start time input
                                const startTimeInput = newRow.querySelector(`#${entryId}-start-time`);
                                if (startTimeInput) {
                                    window.flatpickr(startTimeInput, {
                                        enableTime: true,
                                        noCalendar: true,
                                        dateFormat: "H:i",
                                        time_24hr: true,
                                        minuteIncrement: 15,
                                        onChange: function(selectedDates, dateStr, instance) {
                                            updateOTEntry(entryId, 'startTime', dateStr);
                                        }
                                    });
                                }

                                // Re-attach event listeners for hours and type
                                const hoursInput = newRow.querySelector(`#${entryId}-hours`);
                                const hoursError = newRow.querySelector(`#${entryId}-hours-error`);
                                hoursInput.addEventListener('input', (e) => {
                                    const value = parseFloat(e.target.value);
                                    // Validation for hours
                                    if (isNaN(value) || value < 0) {
                                        hoursInput.classList.add('input-error');
                                        hoursError.textContent = 'Hours must be a positive number.';
                                    } else if (value > CONFIG.MAX_DAILY_OT_HOURS) {
                                        hoursInput.classList.add('input-error');
                                        hoursError.textContent = `Max hours per day is ${CONFIG.MAX_DAILY_OT_HOURS}.`;
                                    }
                                    else {
                                        hoursInput.classList.remove('input-error');
                                        hoursError.textContent = '';
                                        updateOTEntry(entryId, 'hours', value);
                                    }
                                });
                                newRow.querySelector(`#${entryId}-type`).addEventListener('change', (e) => {
                                    updateOTEntry(entryId, 'type', e.target.value);
                                });
                                newRow.querySelector(`.remove-ot-entry-btn`).addEventListener('click', () => removeOTEntryRow(entryId));
                                resolve(); // Resolve the promise after rendering this entry
                            }));
                        }
                        otEntriesContainer.appendChild(groupSection);
                    }
                }
            }


            /**
             * Adds a new OT entry to the `otEntries` array and then re-renders the UI.
             * This is for manual "Add OT Entry" button clicks.
             * @param {string} selectedDate - The date selected by the user from the modal.
             * @param {number} hours - The hours duration.
             * @param {string} startTime - The start time.
             * @param {string} endTime - The end time.
             */
            function addNewDetailedOTEntry(selectedDate, hours, startTime, endTime) {
                const newEntry = {
                    id: `ot-entry-${entryCounter++}`, // Generate a new unique ID
                    date: selectedDate,
                    hours: hours,
                    type: getDefaultOTTypeForDate(selectedDate), // Auto-set type based on date
                    startTime: startTime,
                    endTime: endTime,
                    isNew: true     // Mark as new
                };
                otEntries.push(newEntry);
                renderOTEntries(); // Re-render the entire list
                calculateAndDisplayResults(); // Recalculate after adding an entry

                // Find the newly added row and scroll it into view with a highlight
                setTimeout(() => {
                    const newRowElement = otEntriesContainer.querySelector(`[data-id="${newEntry.id}"]`);
                    if (newRowElement) {
                        newRowElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100); // Small delay to ensure DOM update
            }

            /**
             * Updates an OT entry in the otEntries array and its corresponding DOM elements.
             * @param {string} id - The ID of the entry to update.
             * @param {string} field - The field to update ('date', 'hours', 'type', 'startTime').
             * @param {*} value - The new value for the field.
             */
            function updateOTEntry(id, field, value) {
                const index = otEntries.findIndex(entry => entry.id === id);
                if (index === -1) return;

                const originalEntry = { ...otEntries[index] }; // Clone for potential revert

                if (field === 'date') {
                    const newDate = value;
                    const selectedDates = dateRangePickerInstance.selectedDates;
                    const startDate = selectedDates[0] ? new Date(selectedDates[0].toISOString().split('T')[0]) : null;
                    const endDate = selectedDates[1] ? new Date(selectedDates[1].toISOString().split('T')[0]) : null;
                    const newDateObj = new Date(newDate);

                    // Validate against planning date range
                    if (startDate && endDate && (newDateObj.setHours(0,0,0,0) < startDate.setHours(0,0,0,0) || newDateObj.setHours(0,0,0,0) > endDate.setHours(0,0,0,0))) {
                        showToast(`Date ${newDate} is outside the current planning range (${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}). Please choose a date within the range.`, 'error');
                        // Revert the date input in the UI
                        document.querySelector(`#${id}-date`).value = originalEntry.date;
                        return; // Prevent update
                    }

                    // Check for duplicate date across ALL entries (excluding the current one being edited)
                    const isDuplicate = otEntries.some(entry =>
                        entry.id !== id && entry.date === newDate
                    );

                    if (isDuplicate) {
                        showMessageBox(
                            'Duplicate Date Warning',
                            `An OT entry already exists for ${newDate}. Each date can only have one OT entry. Please choose a different date or adjust the existing entry.`,
                            'info'
                        );
                        // Revert the date input in the UI
                        document.querySelector(`#${id}-date`).value = originalEntry.date;
                        return; // Prevent update
                    }

                    otEntries[index].date = newDate;
                    otEntries[index].type = getDefaultOTTypeForDate(newDate); // Auto-adjust type based on new date

                } else if (field === 'hours') {
                    const newHours = parseFloat(value);
                    if (newHours <= 0) { // If hours become 0 or less, remove the entry
                        otEntries.splice(index, 1);
                        showToast('Entry removed as hours were set to 0 or less.', 'info');
                    } else {
                        otEntries[index].hours = newHours;
                        // Recalculate end time if hours change
                        otEntries[index].endTime = addHoursToTime(otEntries[index].startTime, otEntries[index].hours);
                    }
                } else if (field === 'startTime') {
                    otEntries[index].startTime = value;
                    // Recalculate end time if start time changes
                    otEntries[index].endTime = addHoursToTime(otEntries[index].startTime, otEntries[index].hours);
                } else { // For 'type' field
                    otEntries[index][field] = value;
                }

                // Always re-render the entire list if date or type changed, as this affects grouping
                // For hours/startTime changes, we also re-render to update endTime and ensure consistency
                renderOTEntries(); // This will re-render and should pick up the updated endTime
                calculateAndDisplayResults(); // Recalculate after any entry update
            }


            /**
             * Removes an OT entry from the otEntries array and then re-renders the UI.
             * @param {string} id - The ID of the entry to remove.
             */
            function removeOTEntryRow(id) {
                showMessageBox(
                    'Confirm Removal',
                    'Are you sure you want to remove this OT entry? This action cannot be undone.',
                    'confirm',
                    () => {
                        otEntries = otEntries.filter(entry => entry.id !== id);
                        renderOTEntries(); // Re-render the entire list after removal
                        calculateAndDisplayResults(); // Recalculate after removing an entry
                        showToast('Entry Removed', 'success');
                    }
                );
            }

            /**
             * Function to clear all daily OT entries and reset the results section.
             */
            function clearDailyOTEntries() {
                showMessageBox(
                    'Confirm Clear All',
                    'Are you sure you want to clear all daily OT entries? This action cannot be undone.',
                    'confirm',
                    () => {
                        clearOTEntries(); // Use the helper function to clear all rows and state
                        showToast('All entries cleared!', 'success');
                        calculateAndDisplayResults(); // Recalculate after clearing entries
                    }
                );
            }

            /**
             * Main function to calculate and display OT results.
             */
            function calculateAndDisplayResults() { // Removed debounce from here
                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = getTargetOTPayValue();
                // Get dates from the single date range input
                const selectedDates = dateRangePickerInstance.selectedDates;
                const startDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : '';
                const endDate = selectedDates[1] ? selectedDates[1].toISOString().split('T')[0] : '';

                if (isNaN(basicSalary) || basicSalary <= 0) {
                    // Set all display elements to 0 or N/A if basic salary is not valid
                    totalHoursByTypeElem.innerHTML = '';
                    totalPayByCategoryElem.innerHTML = '';
                    combinedOTPayElem.textContent = formatCurrency(0);
                    totalMonthlyOTHoursDisplay.textContent = `0.0 hours`;
                    expectedSalaryPayDisplay.textContent = formatCurrency(0);
                    targetOTPayDisplayElem.textContent = "N/A (No target set)";
                    targetOTPayDisplayElem.classList.remove('text-green-600');
                    targetOTPayDisplayElem.classList.add('text-gray-600');

                    differenceFromTargetElem.textContent = "N/A (No target set)";
                    differenceFromTargetElem.classList.remove('text-green-600', 'text-red-600');
                    differenceFromTargetElem.classList.add('text-gray-600');
                    allocationStrategySummary.textContent = selectedAllocationStrategy; // Still display strategy

                    updateChart([], []); // Clear chart
                    return; // Exit if basic salary is invalid, no further calculation possible
                }

                const hourlyRate = calculateHourlyRate(basicSalary);

                let totalHoursByType = {};
                let totalPayByCategory = {};
                let combinedOTPay = 0;
                let totalMonthlyOTHours = 0;

                // Initialize categories including Public Holiday
                for (const type in CONFIG.OT_MULTIPLIERS) {
                    totalHoursByType[type] = 0;
                    totalPayByCategory[type] = 0;
                }
                // Ensure 'Public Holiday' is always initialized, even if not in DEFAULT_OT_MULTIPLIERS keys
                if (!totalHoursByType['Public Holiday']) {
                    totalHoursByType['Public Holiday'] = 0;
                    totalPayByCategory['Public Holiday'] = 0;
                }

                otEntries.forEach((entry, index) => {
                    const hours = parseFloat(entry.hours);
                    const type = entry.type;
                    const date = entry.date;

                    // Only include entries within the current planning range for calculation
                    const entryDate = new Date(date);
                    const rangeStart = new Date(startDate);
                    const rangeEnd = new Date(endDate);
                    if (startDate && endDate && (entryDate.setHours(0,0,0,0) < rangeStart.setHours(0,0,0,0) || entryDate.setHours(0,0,0,0) > rangeEnd.setHours(0,0,0,0))) {
                        return; // Skip this entry if it's outside the current range
                    }


                    if (isNaN(hours) || hours <= 0) {
                        return;
                    }

                    const categoryForSumming = isPublicHoliday(date) ? 'Public Holiday' : type;
                    const multiplier = isPublicHoliday(date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : CONFIG.OT_MULTIPLIERS[type];

                    if (multiplier === undefined) {
                        console.warn(`Unknown OT type or multiplier for type: ${type} on date ${date}. Skipping entry.`);
                        return;
                    }

                    const dailyOTPay = calculateOT(hourlyRate, hours, type, date);

                    totalHoursByType[categoryForSumming] += hours;
                    totalPayByCategory[categoryForSumming] += dailyOTPay;
                    combinedOTPay += dailyOTPay;
                    totalMonthlyOTHours += hours;
                });

                const expectedSalaryPay = basicSalary + combinedOTPay;

                // Display Results for totalHoursByType
                let hoursSummaryHtml = [];
                const displayOrderForSummary = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday'
                ];
                displayOrderForSummary.forEach(type => {
                    if (totalHoursByType[type] > 0) {
                        hoursSummaryHtml.push(`<span class="summary-inline-item">${type}: ${totalHoursByType[type].toFixed(1)}h</span>`);
                    }
                });
                totalHoursByTypeElem.innerHTML = hoursSummaryHtml.join('');


                // Display Results for totalPayByCategory
                let paySummaryHtml = [];
                let chartLabels = [];
                let chartData = [];
                const chartColors = [
                    '#6366f1', // Indigo-500
                    '#ef4444', // Red-500
                    '#f59e0b', // Amber-500
                    '#10b981', // Emerald-500
                    '#3b82f6'  // Blue-500
                ];
                let colorIndex = 0;

                displayOrderForSummary.forEach(type => {
                    if (totalPayByCategory[type] > 0) {
                        paySummaryHtml.push(`<span class="summary-inline-item">${type}: ${formatCurrency(totalPayByCategory[type])}</span>`);
                        chartLabels.push(type);
                        chartData.push(totalPayByCategory[type]);
                    }
                });
                totalPayByCategoryElem.innerHTML = paySummaryHtml.join('');

                // Update the chart
                updateChart(chartLabels, chartData, chartColors);


                combinedOTPayElem.textContent = formatCurrency(combinedOTPay);
                totalMonthlyOTHoursDisplay.textContent = `${totalMonthlyOTHours.toFixed(1)} hours`;
                expectedSalaryPayDisplay.textContent = formatCurrency(expectedSalaryPay);
                allocationStrategySummary.textContent = selectedAllocationStrategy; // NEW: Display strategy in summary

                const isTargetOptional = targetOTPay === null || targetOTPay <= 0;

                if (isTargetOptional) {
                    targetOTPayDisplayElem.textContent = "N/A (No target set)";
                    targetOTPayDisplayElem.classList.remove('text-green-600');
                    targetOTPayDisplayElem.classList.add('text-gray-600');

                    differenceFromTargetElem.textContent = "N/A (No target set)";
                    differenceFromTargetElem.classList.remove('text-green-600', 'text-red-600');
                    differenceFromTargetElem.classList.add('text-gray-600');
                } else {
                    targetOTPayDisplayElem.textContent = formatCurrency(targetOTPay);
                    targetOTPayDisplayElem.classList.remove('text-gray-600');
                    targetOTPayDisplayElem.classList.add('text-green-600');

                    const difference = combinedOTPay - targetOTPay;
                    differenceFromTargetElem.textContent = formatCurrency(difference);
                    if (difference >= 0) {
                        differenceFromTargetElem.classList.remove('text-red-600', 'text-gray-600');
                        differenceFromTargetElem.classList.add('text-green-600');
                    } else {
                        differenceFromTargetElem.classList.remove('text-green-600', 'text-gray-600');
                        differenceFromTargetElem.classList.add('text-red-600');
                    }
                }
            } // Removed debounce from here

            /**
             * Updates the Chart.js instance with new data.
             * @param {Array<string>} labels - Labels for the chart segments.
             * @param {Array<number>} data - Data values for the chart segments.
             * @param {Array<string>} colors - Colors for the chart segments.
             */
            function updateChart(labels, data, colors) {
                const ctx = document.getElementById('otDistributionChart').getContext('2d');

                if (data.length === 0 || data.every(val => val === 0)) {
                    // No data or all data is zero, hide chart and show placeholder
                    if (otDistributionChartInstance) {
                        otDistributionChartInstance.destroy(); // Destroy existing chart
                        otDistributionChartInstance = null;
                    }
                    chartPlaceholder.classList.remove('hidden');
                } else {
                    // Data exists, hide placeholder and show chart
                    chartPlaceholder.classList.add('hidden');
                    if (otDistributionChartInstance) {
                        otDistributionChartInstance.data.labels = labels;
                        otDistributionChartInstance.data.datasets[0].data = data;
                        otDistributionChartInstance.data.datasets[0].backgroundColor = colors;
                        otDistributionChartInstance.update();
                    } else {
                        otDistributionChartInstance = new Chart(ctx, {
                            type: 'pie', // Or 'bar' if preferred
                            data: {
                                labels: labels,
                                datasets: [{
                                    label: 'OT Pay (RM)',
                                    data: data,
                                    backgroundColor: colors,
                                    hoverOffset: 4
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                plugins: {
                                    legend: {
                                        position: 'right',
                                        labels: {
                                            font: {
                                                family: "Inter",
                                            }
                                        }
                                    },
                                    tooltip: {
                                        callbacks: {
                                            label: function(context) {
                                                let label = context.label || '';
                                                if (label) {
                                                    label += ': ';
                                                }
                                                if (context.parsed !== null) {
                                                    label += formatCurrency(context.parsed);
                                                }
                                            }
                                        },
                                        bodyFont: {
                                            family: "Inter",
                                        },
                                        titleFont: {
                                            family: "Inter",
                                        }
                                    }
                                }
                            }
                        });
                    }
                }
            }

            /**
             * Generates a random number within a given range, rounded to the nearest 0.5.
             * It now explicitly picks from discrete 0.5-hour increments within the range.
             * @param {number} min - The minimum value.
             * @param {number} max - The maximum value.
             * @returns {number} The random number.
             */
            function getRandomHours(min, max) {
                // Ensure min and max are aligned to 0.5 increments for calculation
                // Math.ceil for min to ensure we start at or above the min
                const minAdjusted = Math.ceil(min * 2) / 2;
                // Math.floor for max to ensure we end at or below the max
                const maxAdjusted = Math.floor(max * 2) / 2;

                if (minAdjusted > maxAdjusted) {
                    // If the adjusted range is invalid (e.g., min=2.1, max=2.4 -> minAdjusted=2.5, maxAdjusted=2.0)
                    // Try to return the closest valid 0.5 increment within the original range if possible
                    const closestValid = Math.round(min * 2) / 2;
                    if (closestValid >= min && closestValid <= max) {
                        return closestValid;
                    }
                    // Fallback if no valid 0.5 increment exists in the original range
                    return min; // Or throw an error, depending on desired behavior for impossible ranges
                }

                // Calculate all possible 0.5-hour increments between minAdjusted and maxAdjusted
                const possibleHours = [];
                // Use a small epsilon to handle floating point inaccuracies when comparing with maxAdjusted
                for (let h = minAdjusted; h <= maxAdjusted + CONFIG.ALLOCATION_PRECISION; h += 0.5) {
                    possibleHours.push(parseFloat(h.toFixed(1))); // Ensure float precision to avoid issues like 2.4999999999999996
                }

                if (possibleHours.length === 0) {
                    // This case should ideally be caught by minAdjusted > maxAdjusted, but as a safeguard
                    return Math.round(min * 2) / 2;
                }

                // Pick a random index from the possible hours
                const randomIndex = Math.floor(Math.random() * possibleHours.length);
                return possibleHours[randomIndex];
            }

            /**
             * Adds or updates an OT entry in the otEntries array for auto-allocation.
             * This function assumes one OT entry per date. If an entry for the given date
             * already exists, its hours are updated. Otherwise, a new entry is added.
             * The type for new entries is determined by getDefaultOTTypeForDate.
             * @param {string} date - The date of the OT entry.
             * @param {number} hours - The hours to add/set for the OT entry.
             * @param {string} [suggestedTypeFromAllocationStep] - (Optional) The type suggested by the allocation step. This is mostly for internal consistency during allocation, but the actual stored type for new entries is derived from the date.
             */
            function addOrUpdateOTEntry(date, hours, suggestedTypeFromAllocationStep) { // Kept suggestedTypeFromAllocationStep for clarity, though not directly used for stored type
                const existingEntryIndex = otEntries.findIndex(entry => entry.date === date);
                const roundedHours = parseFloat(hours.toFixed(1)); // Ensure precision

                if (roundedHours <= 0) {
                    // If hours are 0 or less, and an entry exists, remove it.
                    // If no entry exists, do nothing (don't add a 0-hour entry).
                    if (existingEntryIndex !== -1) {
                        otEntries.splice(existingEntryIndex, 1); // Remove the entry
                    }
                    return; // Do not add/update with 0 or negative hours
                }

                if (existingEntryIndex !== -1) {
                    // Update existing entry's hours
                    otEntries[existingEntryIndex].hours = roundedHours;
                    // Recalculate end time for updated entry
                    otEntries[existingEntryIndex].endTime = addHoursToTime(otEntries[existingEntryIndex].startTime, otEntries[existingEntryIndex].hours);
                } else {
                    // Add new entry
                    const newEntry = {
                        id: `ot-entry-${entryCounter++}`,
                        date: date,
                        hours: roundedHours,
                        type: getDefaultOTTypeForDate(date),
                        startTime: '', // Will be calculated by calculateAndAssignTimes
                        endTime: '',    // Will be calculated by calculateAnd2AssignTimes
                    };
                    // Calculate initial times for new entry
                    calculateSuggestedTimes(newEntry);
                    otEntries.push(newEntry);
                }
                // Removed renderOTEntries() and calculateAndDisplayResults() from here
            }

            /**
             * Initializes the list of available days within the planning range.
             * @param {string} startDateStr - The start date string (YYYY-MM-DD).
             * @param {string} endDateStr - The end date string (YYYY-MM-DD).
             * @returns {Array<Object>} An array of day objects { date: 'YYYY-MM-DD', dayOfWeek: number }.
             */
            function initializePlanningDays(startDateStr, endDateStr) {
                const days = [];
                let currentDate = new Date(startDateStr);
                const endDateTime = new Date(endDateStr).getTime();

                while (currentDate.getTime() <= endDateTime) {
                    days.push({
                        date: currentDate.toISOString().split('T')[0],
                        dayOfWeek: currentDate.getDay() // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                // Shuffle days to distribute OT more evenly across the period, rather than front-loading
                days.sort(() => Math.random() - 0.5);
                return days;
            }

            /**
             * Calculates and assigns start/end times for all entries in otEntries, ensuring chaining for same-day entries.
             */
            function calculateAndAssignTimes() {
                // Sort entries by date and then by their original ID (to maintain creation order for same-day entries)
                otEntries.sort((a, b) => {
                    const dateComparison = new Date(a.date) - new Date(b.date);
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    // If dates are the same, sort by the numeric part of the ID to maintain original creation order
                    return parseInt(a.id.split('-')[2]) - parseInt(b.id.split('-')[2]);
                });

                const lastEndTimeOnDay = {}; // To track end time for chaining on the same day
                otEntries.forEach(entry => {
                    let prevEndTime = lastEndTimeOnDay[entry.date] || null;
                    // Only calculate if entry.startTime is empty (auto-allocated)
                    // If startTime is already set (manual entry), use it
                    if (!entry.startTime || !entry.endTime) { // This condition is key
                        calculateSuggestedTimes(entry, prevEndTime);
                    } else {
                        // If times are already set, ensure endTime is correct based on current hours and startTime
                        entry.endTime = addHoursToTime(entry.startTime, entry.hours);
                    }
                    lastEndTimeOnDay[entry.date] = entry.endTime; // Update last end time for this day
                });
            }

            /**
             * Updates the display of workload preset details based on the selected preset.
             */
            function updateWorkloadPresetDetails() {
                selectedWorkloadPreset = workloadPresetSelect.value; // Update the global variable
                const presetDetails = CONFIG.WORKLOAD_PRESETS[selectedWorkloadPreset];
                let html = `<strong>${selectedWorkloadPreset} Details:</strong><ul class="list-disc list-inside ml-4">`;

                // Order for display
                const displayOrder = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h'
                ];

                displayOrder.forEach(type => {
                    const detail = presetDetails[type];
                    if (detail) {
                        // All workload preset details for OT types now use minHours/maxHours
                        html += `<li>${type}: ${detail.minHours.toFixed(1)} - ${detail.maxHours.toFixed(1)} hours</li>`;
                    }
                });
                html += `</ul>`;
                workloadPresetDetails.innerHTML = html;

                // Update the workload preset description
                workloadPresetDescription.textContent = `This preset suggests daily OT hours for different day types to guide auto-allocation.`;
            }

            /**
             * Updates the display of allocation strategy description.
             */
            function updateAllocationStrategyDisplay() {
                selectedAllocationStrategy = allocationStrategySelect.value; // Update the global variable
                if (selectedAllocationStrategy === 'Target-Driven') {
                    allocationStrategyDescription.textContent = 'The calculator will try to allocate hours to reach your "Target OT Pay" with randomized daily hours.';
                    workloadPresetGroup.classList.add('hidden'); // Hide workload preset dropdown
                    workloadPresetDetails.classList.add('hidden'); // Hide workload preset details
                } else if (selectedAllocationStrategy === 'Workload-Driven') {
                    allocationStrategyDescription.textContent = 'Hours will be allocated for all days in your range according to the "Workload Preset", with randomized daily hours.';
                    workloadPresetGroup.classList.remove('hidden'); // Show workload preset dropdown
                    workloadPresetDetails.classList.remove('hidden'); // Show workload preset details
                }
                calculateAndDisplayResults(); // Update summary with new strategy
            }

            /**
             * NEW: Automatically sets the allocation strategy based on whether a target OT pay is set.
             * Disables the dropdown if a target is set to prevent manual override.
             */
            function updateAllocationStrategyBasedOnTarget() {
                const targetOTPay = getTargetOTPayValue();
                const isTargetSet = targetOTPay !== null && targetOTPay > 0;

                if (isTargetSet) {
                    if (allocationStrategySelect.value !== 'Target-Driven') {
                        showToast('Target Pay detected. Allocation strategy automatically set to "Target-Driven".', 'info');
                    }
                    allocationStrategySelect.value = 'Target-Driven';
                    allocationStrategySelect.disabled = true;
                } else {
                    // If there's no target, default to Workload-Driven and allow user to change it.
                    allocationStrategySelect.value = 'Workload-Driven';
                    allocationStrategySelect.disabled = false;
                }
                // Update the descriptive text below the dropdown and hide/show workload preset
                updateAllocationStrategyDisplay();
            }

            /**
             * Expands a collapsible content section smoothly.
             * @param {HTMLElement} contentElement - The content div to expand.
             * @param {HTMLElement} iconElement - The icon element to rotate.
             */
            function expandCollapsible(contentElement, iconElement) {
                contentElement.style.maxHeight = 'none'; // Temporarily set to none to get actual scrollHeight
                const scrollHeight = contentElement.scrollHeight;
                contentElement.style.maxHeight = '0'; // Reset to 0 for the transition
                contentElement.classList.remove('collapsed');
                // Force reflow to ensure the browser registers the height before transition
                contentElement.offsetWidth;
                contentElement.style.maxHeight = scrollHeight + "px";
                if (iconElement) iconElement.classList.add('rotated');

                // After transition, set max-height to 'none' to allow dynamic content changes
                contentElement.addEventListener('transitionend', function handler() {
                    contentElement.style.maxHeight = 'none'; // Use 'none' for auto height after transition
                    contentElement.removeEventListener('transitionend', handler);
                }, { once: true }); // Use { once: true } to automatically remove the listener
            }

            /**
             * Collapses a collapsible content section smoothly.
             * @param {HTMLElement} contentElement - The content div to collapse.
             * @param {HTMLElement} iconElement - The icon element to rotate.
             */
            function collapseCollapsible(contentElement, iconElement) {
                // Set max-height to current scrollHeight before adding 'collapsed'
                contentElement.style.maxHeight = contentElement.scrollHeight + "px";
                // Force reflow to ensure the browser registers the height before transition
                contentElement.offsetWidth;
                contentElement.classList.add('collapsed'); // Corrected from contentContent
                if (iconElement) iconElement.classList.remove('rotated');

                // Clear max-height after transition to allow it to be re-calculated if expanded again
                contentElement.addEventListener('transitionend', function handler() {
                    // This check ensures we only clear if it's still collapsed (prevents issues if expanded during transition)
                    if (contentElement.classList.contains('collapsed')) {
                        contentElement.style.maxHeight = '0'; // Ensure it stays 0 after transition
                    }
                    contentElement.removeEventListener('transitionend', handler);
                }, { once: true }); // Use { once: true } to automatically remove the listener
            }

            /**
             * Updates the Flatpickr instance for the public holiday date picker.
             * This function is called when the date range changes.
             */
            function updatePublicHolidayDatePicker() {
                if (publicHolidayDatePickerInstance) {
                    const selectedDates = dateRangePickerInstance.selectedDates;
                    const startDate = selectedDates[0] ? `${selectedDates[0].getFullYear()}-${String(selectedDates[0].getMonth() + 1).padStart(2, '0')}-${String(selectedDates[0].getDate()).padStart(2, '0')}` : null;
                    const endDate = selectedDates[1] ? `${selectedDates[1].getFullYear()}-${String(selectedDates[1].getMonth() + 1).padStart(2, '0')}-${String(selectedDates[1].getDate()).padStart(2, '0')}` : null;

                    publicHolidayDatePickerInstance.set('minDate', startDate);
                    publicHolidayDatePickerInstance.set('maxDate', endDate);
                    publicHolidayDatePickerInstance.redraw(); // Redraw to apply new min/max dates
                }
            }


            /**
             * Adds a public holiday to the list.
             */
            function addPublicHoliday() {
                const date = publicHolidayDateInput.value;
                const selectedDates = dateRangePickerInstance.selectedDates;
                const startDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : '';
                const endDate = selectedDates[1] ? selectedDates[1].toISOString().split('T')[0] : '';

                if (!date) {
                    showToast('Please select a date for the public holiday.', 'error');
                    return;
                }

                // Validate against the OT Planning Date Range
                if (!startDate || !endDate || new Date(date) < new Date(startDate) || new Date(date) > new Date(endDate)) {
                    showToast(`Public Holiday date must be within the OT Planning Date Range (${startDate || 'Not Set'} to ${endDate || 'Not Set'}). Please set a valid date range first.`, 'error');
                    return;
                }

                if (publicHolidays.includes(date)) {
                    showToast(`${date} is already in the public holidays list.`, 'warning');
                    return;
                }
                publicHolidays.push(date);
                publicHolidays.sort(); // Keep sorted for consistency
                renderPublicHolidays(); // This should re-render the list

                // --- FIX: Ensure collapsible section expands correctly using new helper ---
                const header = document.querySelector('.collapsible-header[data-target="publicHolidaysContent"]');
                const icon = header ? header.querySelector('.collapsible-icon') : null;
                if (publicHolidaysContent.classList.contains('collapsed')) {
                    expandCollapsible(publicHolidaysContent, icon);
                }
                // --- END FIX ---

                // After adding a public holiday, re-render all OT entries to update their grouping/PH indicator
                renderOTEntries();
                calculateAndDisplayResults(); // Recalculate after adding holiday
                showToast('Public Holiday added successfully!', 'success');
            }

            /**
             * Removes a public holiday from the list.
             * @param {string} dateToRemove - The date string to remove.
             */
            function removePublicHoliday(dateToRemove) {
                showMessageBox(
                    'Confirm Removal',
                    `Are you sure you want to remove ${dateToRemove} from public holidays?`,
                    'confirm',
                    () => {
                        publicHolidays = publicHolidays.filter(date => date !== dateToRemove);
                        renderPublicHolidays();
                        // After removing a public holiday, re-render all OT entries to update their grouping/PH indicator
                        renderOTEntries();
                        calculateAndDisplayResults(); // Recalculate after removing holiday
                        showToast('Holiday Removed', 'success');
                    }
                );
            }

            /**
             * Renders the list of public holidays.
             */
            function renderPublicHolidays() {
                publicHolidaysList.innerHTML = '';
                if (publicHolidays.length === 0) {
                    publicHolidaysList.innerHTML = '<li class="text-gray-500">No public holidays added yet.</li>';
                    return;
                }
                publicHolidays.forEach(date => {
                    const li = document.createElement('li');
                    li.classList.add('flex', 'justify-between', 'items-center', 'py-1');
                    li.innerHTML = `
                        <span>${date}</span>
                        <button type="button" class="text-red-500 hover:text-red-700 ml-4" data-date="${date}" aria-label="Remove public holiday ${date}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    `;
                    publicHolidaysList.appendChild(li);
                    li.querySelector('button').addEventListener('click', (e) => {
                        removePublicHoliday(e.currentTarget.dataset.date);
                    });
                });
            }

            /**
             * Checks if a given date is a public holiday.
             * @param {string} date - The date string (YYYY-MM-DD) to check.
             * @returns {boolean} True if it's a public holiday, false otherwise.
             */
            function isPublicHoliday(date) {
                return publicHolidays.includes(date);
            }

            /**
             * Renders the OT multiplier input fields.
             */
            function renderOTMultiplierInputs() {
                otMultiplierInputsContainer.innerHTML = '';
                // Order for display
                const displayOrder = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday'
                ];

                displayOrder.forEach(type => {
                    const inputGroup = document.createElement('div');
                    inputGroup.classList.add('input-group');
                    inputGroup.innerHTML = `
                        <label for="multiplier-${type.replace(/[^0-9A-Za-z]/g, '')}">${type} Multiplier</label>
                        <input type="number" id="multiplier-${type.replace(/[^0-9A-Za-z]/g, '')}" value="${(CONFIG.OT_MULTIPLIERS[type] || 0).toFixed(2)}" min="0" step="0.1" class="shadow-sm">
                    `;
                    otMultiplierInputsContainer.appendChild(inputGroup);

                    // Add event listener to update CONFIG.OT_MULTIPLIERS on input change
                    inputGroup.querySelector('input').addEventListener('input', debounce((e) => {
                        const value = parseFloat(e.target.value);
                        if (!isNaN(value) && value >= 0) {
                            CONFIG.OT_MULTIPLIERS[type] = value;
                            calculateAndDisplayResults(); // Recalculate after multiplier change
                        }
                    }, 150)); // Debounce by 150ms
                });
            }

            /**
             * Resets OT multipliers to their default values.
             */
            function resetMultipliersToDefault() {
                showMessageBox(
                    'Confirm Reset Multipliers',
                    'Are you sure you want to reset all OT multipliers to their default values?',
                    'confirm',
                    () => {
                        Object.assign(CONFIG.OT_MULTIPLIERS, DEFAULT_OT_MULTIPLIERS);
                        renderOTMultiplierInputs(); // Re-render to show default values
                        showToast('OT multipliers have been reset to their default values.', 'success');
                        calculateAndDisplayResults(); // Recalculate after resetting multipliers
                    }
                );
            }

            /**
             * Main function for auto-allocating OT hours.
             * @param {boolean} clearExisting - If true, clears all existing entries before allocation.
             */
            async function performAutoAllocation(clearExisting) {
                showLoadingOverlay(); // Show global loading overlay
                autoAllocateLoading.classList.remove('hidden'); // Show loading indicator
                autoAllocateLoading.setAttribute('aria-live', 'polite'); // Announce loading

                try {
                    const basicSalary = parseFloat(basicSalaryInput.value);
                    const targetOTPay = getTargetOTPayValue();
                    
                    const selectedDates = dateRangePickerInstance.selectedDates;
                    const startDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : '';
                    const endDate = selectedDates[1] ? selectedDates[1].toISOString().split('T')[0] : '';

                    // Basic validation
                    if (isNaN(basicSalary) || basicSalary <= 0) {
                        showToast('Please enter a valid Basic Monthly Salary for auto-allocation.', 'error');
                        return;
                    }
                    if (!startDate || !endDate) {
                        showToast('Please select a Start and End Date for the planning range.', 'error');
                        return;
                    }
                    if (new Date(startDate) > new Date(endDate)) {
                        showToast('Start Date cannot be after End Date.', 'error');
                        return;
                    }

                    let currentAllocatedPay = 0;
                    const hoursAllocatedPerDay = {}; // Map to track total hours for each day (including existing)
                    const sundayFirst8hAllocated = new Map(); // Map to track 0.5x hours for Sundays

                    if (clearExisting) {
                        clearOTEntries(); // This clears otEntries array and UI
                    } else {
                        // NEW: Filter existing entries to only include those within the current date range
                        const rangeStart = new Date(startDate);
                        const rangeEnd = new Date(endDate);
                        otEntries = otEntries.filter(entry => {
                            const entryDate = new Date(entry.date);
                            return entryDate.setHours(0,0,0,0) >= rangeStart.setHours(0,0,0,0) && entryDate.setHours(0,0,0,0) <= rangeEnd.setHours(0,0,0,0);
                        });

                        // If not clearing, pre-populate current state from existing entries
                        otEntries.forEach(entry => {
                            const hours = parseFloat(entry.hours);
                            const type = entry.type;
                            const date = entry.date;

                            if (isNaN(hours) || hours <= 0) {
                                console.warn(`Skipping existing entry ${entry.id} due to invalid hours: ${hours}`);
                                return;
                            }

                            const dailyOTPay = calculateOT(calculateHourlyRate(basicSalary), hours, type, date);
                            currentAllocatedPay += dailyOTPay;
                            hoursAllocatedPerDay[date] = (hoursAllocatedPerDay[date] || 0) + hours;
                            if (type === 'Rest Day (Sunday) — 1st 8h') {
                                sundayFirst8hAllocated.set(date, (sundayFirst8hAllocated.get(date) || 0) + hours);
                            }
                        });
                    }

                    const hourlyRate = calculateHourlyRate(basicSalary);
                    const allDaysInPlanningRange = initializePlanningDays(startDate, endDate); // Already shuffled

                    const isTargetProvided = targetOTPay !== null && targetOTPay > 0;

                    if (selectedAllocationStrategy === 'Target-Driven') {
                        if (!isTargetProvided) {
                            showToast('Please enter a valid Target OT Pay (> RM0) for Target-Driven allocation.', 'error');
                            return;
                        }

                        let remainingTargetPay = targetOTPay - currentAllocatedPay;
                        if (remainingTargetPay <= CONFIG.ALLOCATION_PRECISION) {
                            showToast('Your target OT pay has already been met or exceeded with existing entries. No further auto-allocation needed.', 'info');
                            calculateAndDisplayResults();
                            return;
                        }

                        // Group days by type for prioritized allocation
                        const weekdayDays = allDaysInPlanningRange.filter(day => day.dayOfWeek >= 1 && day.dayOfWeek <= 5 && !isPublicHoliday(day.date));
                        const saturdayDays = allDaysInPlanningRange.filter(day => day.dayOfWeek === 6 && !isPublicHoliday(day.date));
                        const publicHolidayDays = allDaysInPlanningRange.filter(day => isPublicHoliday(day.date));
                        const sundayDays = allDaysInPlanningRange.filter(day => day.dayOfWeek === 0 && !isPublicHoliday(day.date)); // Exclude PH Sundays

                        // Shuffle each group to maintain some randomness within priority
                        weekdayDays.sort(() => Math.random() - 0.5);
                        saturdayDays.sort(() => Math.random() - 0.5);
                        publicHolidayDays.sort(() => Math.random() - 0.5);
                        sundayDays.sort(() => Math.random() - 0.5);

                        // Define the priority order for allocation
                        const prioritizedDayGroups = [
                            { type: 'Public Holiday', days: publicHolidayDays }, // Higher priority
                            { type: 'Rest Day (Sunday) — after 8h', days: sundayDays }, // Higher priority
                            { type: 'Off Day (Saturday)', days: saturdayDays },
                            { type: 'Normal OT (Weekdays)', days: weekdayDays },
                            { type: 'Rest Day (Sunday) — 1st 8h', days: sundayDays } // Lower priority
                        ];

                        // Loop through priority groups until target is met or no more hours can be allocated
                        for (const group of prioritizedDayGroups) {
                            if (currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) break; // Target met

                            for (const day of group.days) {
                                if (currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) break; // Target met

                                let maxHoursCanAdd = CONFIG.MAX_DAILY_OT_HOURS - (hoursAllocatedPerDay[day.date] || 0);
                                if (maxHoursCanAdd <= 0) continue; // Day is already full

                                let typeToUse = group.type;
                                let multiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                                let hoursForThisType = maxHoursCanAdd; // Default, will be adjusted for Sunday

                                // Specific logic for Sunday types
                                if (day.dayOfWeek === 0 && !isPublicHoliday(day.date)) { // Ensure it's a non-PH Sunday
                                    const currentSunday1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                                    const totalHoursOnSunday = (hoursAllocatedPerDay[day.date] || 0);

                                    if (group.type === 'Rest Day (Sunday) — 1st 8h') {
                                        if (currentSunday1st8h >= 8) continue; // 0.5x already full for this Sunday
                                        typeToUse = 'Rest Day (Sunday) — 1st 8h';
                                        multiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                                        hoursForThisType = Math.min(maxHoursCanAdd, 8 - currentSunday1st8h);
                                    } else if (group.type === 'Rest Day (Sunday) — after 8h') {
                                        if (totalHoursOnSunday < 8) {
                                            continue; // Cannot allocate 2.0x until 0.5x is full
                                        }
                                        typeToUse = 'Rest Day (Sunday) — after 8h';
                                        multiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                                        hoursForThisType = maxHoursCanAdd;
                                    } else {
                                        continue; // Skip if group type doesn't match Sunday logic
                                    }
                                } else if (isPublicHoliday(day.date) && group.type !== 'Public Holiday') {
                                    // If this day is a Public Holiday, but the current group is not 'Public Holiday', skip.
                                    continue;
                                } else if (!isPublicHoliday(day.date) && group.type === 'Public Holiday') {
                                    // If this day is NOT a Public Holiday, but the current group is 'Public Holiday', skip.
                                    continue;
                                }


                                if (!multiplier) {
                                    console.warn(`No multiplier found for type: ${typeToUse}. Skipping allocation for ${day.date}.`);
                                    continue;
                                }

                                const payPerHalfHour = hourlyRate * multiplier * 0.5;
                                let remainingTargetPayForThisIteration = targetOTPay - currentAllocatedPay;

                                let hoursToAllocate = 0;

                                // Precision allocation when very close to target
                                if (remainingTargetPayForThisIteration <= payPerHalfHour + CONFIG.ALLOCATION_PRECISION) {
                                    hoursToAllocate = remainingTargetPayForThisIteration / (hourlyRate * multiplier);
                                    hoursToAllocate = Math.max(0, Math.round(hoursToAllocate * 2) / 2); // Round to nearest 0.5
                                    hoursToAllocate = Math.min(hoursToAllocate, hoursForThisType); // Cap by what's available for this type
                                } else {
                                    // Aggressive allocation when still far from target
                                    const remainingDaysForAllocation = allDaysInPlanningRange.filter(d => {
                                        // Count days that are not yet full and are suitable for this group's type
                                        const currentHoursOnDay = hoursAllocatedPerDay[d.date] || 0;
                                        if (currentHoursOnDay >= CONFIG.MAX_DAILY_OT_HOURS) return false;

                                        // Check if the day is applicable to the current group type
                                        const dayOfWeek = new Date(d.date).getDay();
                                        const isPH = isPublicHoliday(d.date);

                                        if (group.type === 'Normal OT (Weekdays)' && (dayOfWeek >= 1 && dayOfWeek <= 5) && !isPH) return true;
                                        if (group.type === 'Off Day (Saturday)' && dayOfWeek === 6 && !isPH) return true;
                                        if (group.type === 'Public Holiday' && isPH) return true;
                                        if (group.type === 'Rest Day (Sunday) — 1st 8h' && dayOfWeek === 0 && !isPH && (sundayFirst8hAllocated.get(d.date) || 0) < 8) return true;
                                        if (group.type === 'Rest Day (Sunday) — after 8h' && dayOfWeek === 0 && !isPH && (hoursAllocatedPerDay[d.date] || 0) >= 8) return true;
                                        return false;
                                    }).length;

                                    let targetHoursPerRemainingDay = 0;
                                    if (remainingDaysForAllocation > 0 && hourlyRate * multiplier > 0) {
                                        targetHoursPerRemainingDay = (remainingTargetPayForThisIteration / (hourlyRate * multiplier)) / remainingDaysForAllocation;
                                    }

                                    // Determine a base amount to allocate, prioritizing hitting the target
                                    let baseHours = Math.min(targetHoursPerRemainingDay, hoursForThisType);

                                    // Ensure baseHours is at least the minimum from the preset, but not more than max daily OT
                                    const preset = CONFIG.WORKLOAD_PRESETS[selectedWorkloadPreset][typeToUse] || { minHours: 0.5, maxHours: CONFIG.MAX_DAILY_OT_HOURS };
                                    
                                    // Ensure baseHours is within a reasonable range, favoring the higher end to hit target
                                    baseHours = Math.max(preset.minHours, Math.min(baseHours, CONFIG.MAX_DAILY_OT_HOURS));

                                    // Introduce randomness around this base, but still cap by available hours for the day
                                    // Let's make the random range tighter around the base, or always lean towards the max if target is far.
                                    let minRand = Math.max(preset.minHours, baseHours - 1.0); // Allow some flexibility downwards
                                    let maxRand = Math.min(preset.maxHours, baseHours + 1.0, hoursForThisType); // Allow some flexibility upwards

                                    // Ensure minRand doesn't exceed maxRand
                                    minRand = Math.min(minRand, maxRand);

                                    // If target is still very far, always try to allocate near the max possible for the day
                                    // Define a threshold (e.g., 10% of the original target)
                                    const originalTarget = getTargetOTPayValue(); // Get the original target value
                                    const highTargetThreshold = originalTarget * 0.1; 

                                    if (remainingTargetPayForThisIteration > highTargetThreshold) {
                                        // If remaining target is still high, push minRand towards the higher end of possible hours
                                        minRand = Math.max(minRand, hoursForThisType * 0.8); // Try to allocate at least 80% of max possible for this type
                                        maxRand = hoursForThisType; // Maximize allocation
                                    }

                                    hoursToAllocate = getRandomHours(minRand, maxRand);
                                    hoursToAllocate = Math.min(hoursToAllocate, hoursForThisType); // Final cap by what's truly available for this type on this day
                                }

                                hoursToAllocate = parseFloat(hoursToAllocate.toFixed(2)); // Round to 2 decimal places for final precision

                                if (hoursToAllocate > CONFIG.ALLOCATION_PRECISION) {
                                    addOrUpdateOTEntry(day.date, hoursToAllocate, typeToUse);
                                    const payAdded = calculateOT(hourlyRate, hoursToAllocate, typeToUse, day.date);
                                    currentAllocatedPay += payAdded;
                                    hoursAllocatedPerDay[day.date] = (hoursAllocatedPerDay[day.date] || 0) + hoursToAllocate;
                                    if (typeToUse === 'Rest Day (Sunday) — 1st 8h') {
                                        sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToAllocate);
                                    }
                                }
                                await yieldControl(); // Yield control after processing each day/attempt
                            }
                        }

                        // Final check and message
                        if (currentAllocatedPay < targetOTPay - CONFIG.ALLOCATION_PRECISION) {
                            showToast(`The target OT pay of ${formatCurrency(targetOTPay)} was not fully met (${formatCurrency(currentAllocatedPay)}). You may need to manually add more hours or increase the planning date range.`, 'warning');
                        } else {
                            showToast('Overtime hours have been automatically allocated to meet your target pay with randomized hours. Please review and adjust as needed.', 'success');
                        }

                    } else if (selectedAllocationStrategy === 'Workload-Driven') {
                        // Get the base allocation steps and apply preset overrides
                        let currentAllocationSteps = JSON.parse(JSON.stringify(CONFIG.ALLOCATION_STEPS));
                        currentAllocationSteps.forEach(step => {
                            const presetOverrides = CONFIG.WORKLOAD_PRESETS[selectedWorkloadPreset][step.type];
                            if (presetOverrides) {
                                step.minHours = presetOverrides.minHours;
                                step.maxHours = presetOverrides.maxHours;
                            }
                        });

                        // Filter out days that are already fully allocated (MAX_DAILY_OT_HOURS reached)
                        const availableDaysForAllocation = allDaysInPlanningRange.filter(day => {
                            return (hoursAllocatedPerDay[day.date] || 0) < CONFIG.MAX_DAILY_OT_HOURS;
                        });

                        availableDaysForAllocation.sort((a, b) => new Date(a.date) - new Date(b.date)); // Ensure sorted by date for consistent allocation

                        for (const day of availableDaysForAllocation) {
                            let maxHoursRemaining = CONFIG.MAX_DAILY_OT_HOURS - (hoursAllocatedPerDay[day.date] || 0); // Use 0 if no hours yet
                            if (maxHoursRemaining <= 0) {
                                continue;
                            }

                            // Iterate through applicable steps for the current day
                            const applicableStepsForDay = currentAllocationSteps.filter(step => step.days.includes(day.dayOfWeek));

                            for (const step of applicableStepsForDay) {
                                if (maxHoursRemaining <= 0) break;

                                let hoursToAllocate = 0;
                                // Logic for Sunday 1st 8h and after 8h
                                if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                    const current1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                                    const remainingFor1st8h = 8 - current1st8h;
                                    hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                                    hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining, remainingFor1st8h);
                                } else if (step.type === 'Rest Day (Sunday) — after 8h') {
                                    const totalHoursOnSunday = (hoursAllocatedPerDay[day.date] || 0);
                                    if (totalHoursOnSunday < 8) {
                                        continue; // Skip 2.0x if 0.5x hasn't been fully allocated yet
                                    }
                                    hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                                    hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                                } else if (step.hours !== undefined) { // Fixed hours (e.g., if we had any other fixed hours type)
                                    hoursToAllocate = getRandomHours(step.minHours, step.maxHours); // Use range for fixed hours too
                                    hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                                } else { // Range-based hours for other types
                                    hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                                    hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                                }

                                if (hoursToAllocate > 0) {
                                    addOrUpdateOTEntry(day.date, hoursToAllocate, step.type);
                                    hoursAllocatedPerDay[day.date] = (hoursAllocatedPerDay[day.date] || 0) + hoursToAllocate;
                                    if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                        sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToAllocate);
                                    }
                                    maxHoursRemaining = CONFIG.MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date]; // Update remaining hours
                                }
                            }
                            await yieldControl(); // Yield control after processing each day
                        }
                        showToast('Overtime hours have been allocated based on the selected workload preset for all days in the range.', 'success');
                    }

                    // Phase 3: Calculate and assign final start/end times for all entries
                    calculateAndAssignTimes();

                    // Clear all 'isNew' flags after auto-allocation
                    otEntries.forEach(entry => {
                        delete entry.isNew;
                    });

                    await renderOTEntries(); // Await the asynchronous rendering
                    calculateAndDisplayResults(); // Update results after auto-allocation
                } catch (error) {
                    console.error("Error during auto-allocation:", error);
                    showToast('An error occurred during auto-allocation. Please check console.', 'error');
                } finally {
                    hideLoadingOverlay(); // Hide global loading overlay
                    autoAllocateLoading.classList.add('hidden'); // Hide loading indicator
                    autoAllocateLoading.removeAttribute('aria-live'); // Remove aria-live when hidden
                }
            }


            /**
             * Exports the summary to a text file.
             */
            function exportSummary() {
                try {
                    const basicSalary = parseFloat(basicSalaryInput.value);
                    const targetOTPay = getTargetOTPayValue();
                    
                    const selectedDates = dateRangePickerInstance.selectedDates;
                    const startDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : '';
                    const endDate = selectedDates[1] ? selectedDates[1].toISOString().split('T')[0] : '';
                    
                    const hourlyRate = calculateHourlyRate(basicSalary);

                    let summaryText = `--- OT Calculation Summary ---\n\n`;
                    summaryText += `Employee Settings:\n`;
                    summaryText += `  Basic Monthly Salary: ${formatCurrency(basicSalary)}\n`;
                    summaryText += `  Hourly Rate: RM ${hourlyRate.toFixed(2)}/hour\n\n`;

                    summaryText += `OT Planning Period: ${startDate} to ${endDate}\n`;
                    summaryText += `Allocation Strategy: ${selectedAllocationStrategy}\n`; // NEW: Include allocation strategy
                    summaryText += `Target OT Pay: ${targetOTPay === null ? 'N/A' : formatCurrency(targetOTPay)}\n\n`;

                    summaryText += `OT Multipliers Used:\n`;
                    for (const type in CONFIG.OT_MULTIPLIERS) {
                        summaryText += `  ${type}: ${CONFIG.OT_MULTIPLIERS[type].toFixed(2)}x\n`;
                    }
                    summaryText += `\n`;

                    // Group entries by type for export
                    const groupedEntriesForExport = {};
                    const exportOrder = [
                        'Normal OT (Weekdays)',
                        'Off Day (Saturday)',
                        'Rest Day (Sunday) — 1st 8h',
                        'Rest Day (Sunday) — after 8h',
                        'Public Holiday'
                    ];

                    // Filter entries for export to only include those within the current date range
                    const rangeStart = new Date(startDate);
                    const rangeEnd = new Date(endDate);
                    const entriesForExport = otEntries.filter(entry => {
                        const entryDate = new Date(entry.date);
                        return entryDate.setHours(0,0,0,0) >= rangeStart.setHours(0,0,0,0) && entryDate.setHours(0,0,0,0) <= rangeEnd.setHours(0,0,0,0);
                    });


                    // Populate groupedEntriesForExport
                    entriesForExport.forEach(entry => {
                        const typeToGroup = isPublicHoliday(entry.date) ? 'Public Holiday' : entry.type;
                        if (!groupedEntriesForExport[typeToGroup]) {
                            groupedEntriesForExport[typeToGroup] = [];
                        }
                        groupedEntriesForExport[typeToGroup].push(entry);
                    });

                    summaryText += `Daily OT Entries:\n`;
                    if (entriesForExport.length === 0) {
                        summaryText += `  No entries recorded for the selected range.\n`; // Updated message
                    } else {
                        exportOrder.forEach(typeGroup => {
                            if (groupedEntriesForExport[typeGroup] && groupedEntriesForExport[typeGroup].length > 0) {
                                summaryText += `\n--- ${typeGroup} ---\n`;
                                // Sort entries within each group by date for chronological display within type
                                groupedEntriesForExport[typeGroup].sort((a, b) => new Date(a.date) - new Date(b.date));
                                groupedEntriesForExport[typeGroup].forEach(entry => {
                                    summaryText += `  Date: ${entry.date}, Hours: ${entry.hours.toFixed(1)}h, Type: ${entry.type}`;
                                    if (isPublicHoliday(entry.date)) {
                                        summaryText += ` (Public Holiday)`;
                                    }
                                    if (entry.startTime && entry.endTime) {
                                        summaryText += `, Time: ${entry.startTime} - ${entry.endTime}`;
                                    }
                                    summaryText += `\n`;
                                });
                            }
                        });
                    }
                    summaryText += `\n`;

                    // Recalculate for export to ensure consistency
                    let totalHoursByType = {};
                    let totalPayByCategory = {};
                    let combinedOTPay = 0;
                    let totalMonthlyOTHours = 0;

                    // Initialize categories including Public Holiday
                    for (const type in CONFIG.OT_MULTIPLIERS) {
                        totalHoursByType[type] = 0;
                        totalPayByCategory[type] = 0;
                    }
                    if (!totalHoursByType['Public Holiday']) {
                        totalHoursByType['Public Holiday'] = 0;
                        totalPayByCategory['Public Holiday'] = 0;
                    }

                    entriesForExport.forEach(entry => { // Use entriesForExport for calculation
                        const hours = parseFloat(entry.hours);
                        const type = entry.type;
                        const date = entry.date;
                        if (isNaN(hours) || hours <= 0) return;

                        // Determine the category for summing hours and pay in the summary
                        const categoryForSumming = isPublicHoliday(date) ? 'Public Holiday' : entry.type; // Use entry.type for calculation, not display type

                        const multiplier = isPublicHoliday(date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : CONFIG.OT_MULTIPLIERS[type];
                        if (multiplier === undefined) return;

                        const dailyOTPay = calculateOT(hourlyRate, hours, type, date);

                        totalHoursByType[categoryForSumming] += hours;
                        totalPayByCategory[categoryForSumming] += dailyOTPay;
                        combinedOTPay += dailyOTPay;
                        totalMonthlyOTHours += hours;
                    });

                    const expectedSalaryPay = basicSalary + combinedOTPay; // Calculate for export

                    summaryText += `Total OT Hours by Type:\n`;
                    let hoursSummaryExport = [];
                    const displayOrderForSummaryExport = [
                        'Normal OT (Weekdays)',
                        'Off Day (Saturday)',
                        'Rest Day (Sunday) — 1st 8h',
                        'Rest Day (Sunday) — after 8h',
                        'Public Holiday'
                    ];
                    displayOrderForSummaryExport.forEach(type => {
                        if (totalHoursByType[type] > 0) {
                            hoursSummaryExport.push(`${type}: ${totalHoursByType[type].toFixed(1)}h`);
                        }
                    });
                    summaryText += `  ${hoursSummaryExport.join(', ')}\n`;
                    summaryText += `\n`;

                    summaryText += `Total Pay per OT Category:\n`;
                    let paySummaryExport = [];
                    displayOrderForSummaryExport.forEach(type => {
                        if (totalPayByCategory[type] > 0) {
                            totalPayByCategory[type] = parseFloat(totalPayByCategory[type].toFixed(2)); // Round to 2 decimal places for display
                            paySummaryExport.push(`${type}: ${formatCurrency(totalPayByCategory[type])}`);
                        }
                    });
                    summaryText += `  ${paySummaryExport.join(', ')}\n`;
                    summaryText += `\n`;

                    summaryText += `Combined OT Pay: ${formatCurrency(combinedOTPay)}\n`;
                    const difference = combinedOTPay - (targetOTPay === null ? 0 : targetOTPay);
                    summaryText += `Difference from Target: ${targetOTPay === null ? 'N/A (No target set)' : formatCurrency(difference)}\n`;
                    summaryText += `Total Monthly OT Hours: ${totalMonthlyOTHours.toFixed(1)} hours\n`;
                    summaryText += `Expected Salary Pay (Calculated): ${formatCurrency(expectedSalaryPay)}\n`;
                    summaryText += `\n--- End of Summary ---`;

                    const blob = new Blob([summaryText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'ot_summary.txt';
                    document.body.appendChild(a);
                    a.click();

                    showToast('Your OT summary is being downloaded.', 'info');

                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 250);

                } catch (error) {
                    console.error("Error during export summary:", error);
                    showToast('Failed to export summary. Please check your browser console for details.', 'error');
                }
            }

            /**
             * Saves the current application data to Firestore.
             */
            async function saveOTEntries() {
                if (!isFirebaseEnabled) {
                    showToast('Firebase functions (Save/Load) are currently disabled. Please enable them to use this feature.', 'warning');
                    return;
                }
                if (!isAuthReady || !userId) {
                    showToast('Firebase authentication not ready. Please try again in a moment.', 'error');
                    return;
                }
                showLoadingOverlay();
                showStatusMessage(saveDataStatus, 'Saving...', 'loading');

                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');

                    // Before saving, clear the 'isNew' flag for all entries
                    const cleanedOtEntries = otEntries.map(entry => {
                        const newEntry = { ...entry };
                        delete newEntry.isNew; // Remove the isNew flag
                        return newEntry;
                    });

                    const dataToSave = {
                        basicSalary: parseFloat(basicSalaryInput.value),
                        targetOTPay: getTargetOTPayValue(),
                        // Save date range from the Flatpickr instance
                        startDate: dateRangePickerInstance.selectedDates[0] ? dateRangePickerInstance.selectedDates[0].toISOString().split('T')[0] : '',
                        endDate: dateRangePickerInstance.selectedDates[1] ? dateRangePickerInstance.selectedDates[1].toISOString().split('T')[0] : '',
                        workloadPreset: workloadPresetSelect.value,
                        allocationStrategy: allocationStrategySelect.value,
                        otEntries: JSON.stringify(cleanedOtEntries), // Stringify cleaned array
                        publicHolidays: JSON.stringify(publicHolidays), // Save public holidays
                        customMultipliers: JSON.stringify(CONFIG.OT_MULTIPLIERS) // Save custom multipliers
                    };

                    await setDoc(docRef, dataToSave);
                    // Update the local state to reflect that 'isNew' flags are cleared
                    otEntries = cleanedOtEntries;
                    renderOTEntries(); // Re-render to remove "New" badges
                    showStatusMessage(saveDataStatus, 'Saved!', 'success');
                    showToast('Data saved successfully!', 'success');
                } catch (e) {
                    console.error("Error saving document: ", e);
                    showStatusMessage(saveDataStatus, 'Save Failed!', 'error');
                    showToast('Failed to save data. Please try again.', 'error');
                } finally {
                    hideLoadingOverlay();
                }
            }

            /**
             * Loads the application data from Firestore.
             * @param {boolean} showMessageBoxOnSuccess - Whether to show a message box on successful load.
             */
            async function loadOTEntries(showMessageBoxOnSuccess = true) {
                if (!isFirebaseEnabled) {
                    if (showMessageBoxOnSuccess) {
                        showToast('Firebase functions (Save/Load) are currently disabled. Please enable them to use this feature.', 'warning');
                    }
                    return;
                }
                if (!isAuthReady || !userId) {
                    if (showMessageBoxOnSuccess) {
                        showToast('Firebase authentication not ready. Please try again in a moment.', 'error');
                    }
                    return;
                }
                if (showMessageBoxOnSuccess) {
                    showLoadingOverlay();
                    showStatusMessage(loadDataStatus, 'Loading...', 'loading');
                }

                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists()) {
                        const loadedData = docSnap.data();
                        basicSalaryInput.value = parseFloat(loadedData.basicSalary);
                        
                        // Set targetOTPaySelect and customTargetOTPayInput values
                        const loadedTargetOTPay = loadedData.targetOTPay;
                        if (loadedTargetOTPay === null) {
                            targetOTPaySelect.value = ''; // "No Target"
                            customTargetOTPayInput.classList.add('hidden');
                            clearCustomTargetOTPayBtn.classList.add('hidden');
                            customTargetOTPayInput.value = '';
                        } else if (PREDEFINED_TARGET_PAYS.includes(loadedTargetOTPay)) {
                            targetOTPaySelect.value = loadedTargetOTPay.toFixed(2);
                            customTargetOTPayInput.classList.add('hidden');
                            clearCustomTargetOTPayBtn.classList.add('hidden');
                            customTargetOTPayInput.value = '';
                        } else {
                            targetOTPaySelect.value = 'custom'; // "Other (Enter Manually)"
                            customTargetOTPayInput.classList.remove('hidden');
                            clearCustomTargetOTPayBtn.classList.remove('hidden');
                            customTargetOTPayInput.value = loadedTargetOTPay.toFixed(2);
                        }
                        
                        // Set the date range using Flatpickr instance
                        if (loadedData.startDate && loadedData.endDate) {
                            dateRangePickerInstance.setDate([loadedData.startDate, loadedData.endDate], true);
                        } else {
                            dateRangePickerInstance.clear();
                        }

                        workloadPresetSelect.value = loadedData.workloadPreset || 'Moderate Workload';
                        allocationStrategySelect.value = loadedData.allocationStrategy || 'Target-Driven';
                        otEntries = JSON.parse(loadedData.otEntries || '[]');
                        publicHolidays = JSON.parse(loadedData.publicHolidays || '[]');
                        // Load custom multipliers, falling back to defaults if not present
                        Object.assign(CONFIG.OT_MULTIPLIERS, JSON.parse(loadedData.customMultipliers || '{}'));
                        // Ensure all default multipliers are present if not in loaded data
                        Object.assign(CONFIG.OT_MULTIPLIERS, { ...DEFAULT_OT_MULTIPLIERS, ...CONFIG.OT_MULTIPLIERS });


                        // Reset entryCounter to avoid ID conflicts if new entries are added later
                        entryCounter = otEntries.length > 0 ? Math.max(...otEntries.map(e => parseInt(e.id.split('-')[2]))) + 1 : 0;

                        calculateAndAssignTimes();
                        await renderOTEntries(); // Await the asynchronous rendering
                        renderPublicHolidays();

                        // --- NEW: Expand public holidays section if data is loaded ---
                        if (publicHolidays.length > 0) {
                            const header = document.querySelector('.collapsible-header[data-target="publicHolidaysContent"]');
                            const icon = header ? header.querySelector('.collapsible-icon') : null;
                            expandCollapsible(publicHolidaysContent, icon);
                        }
                        // --- END NEW ---

                        renderOTMultiplierInputs();
                        calculateAndDisplayResults();
                        if (showMessageBoxOnSuccess) {
                            showStatusMessage(loadDataStatus, 'Loaded!', 'success');
                            showToast('Data loaded successfully!', 'success');
                        }
                    } else {
                        // If no data, initialize with default values for current month and add one entry
                        const today = new Date();
                        const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                        const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

                        // Set date range picker to current month
                        dateRangePickerInstance.setDate([firstDayOfMonth, lastDayOfMonth], true);


                        workloadPresetSelect.value = 'Moderate Workload';
                        allocationStrategySelect.value = 'Target-Driven';
                        targetOTPaySelect.value = '';
                        customTargetOTPayInput.classList.add('hidden');
                        clearCustomTargetOTPayBtn.classList.add('hidden');

                        renderPublicHolidays();
                        renderOTMultiplierInputs();
                        await renderOTEntries(); // Await the asynchronous rendering
                        calculateAndDisplayResults();
                        if (showMessageBoxOnSuccess) {
                            showStatusMessage(loadDataStatus, 'No saved data found.', 'info');
                        }
                    }
                } catch (e) {
                    console.error("Error loading document: ", e);
                    if (showMessageBoxOnSuccess) {
                        showStatusMessage(loadDataStatus, 'Load Failed!', 'error');
                        showToast('Failed to load data. Please try again.', 'error');
                    }
                } finally {
                    // Ensure workload preset details are updated even if loading fails or no data is found
                    updateWorkloadPresetDetails();
                    updateAllocationStrategyDisplay();
                    updateAllocationStrategyBasedOnTarget(); // NEW: Set strategy based on loaded data
                    hideLoadingOverlay();
                }
            }

            /**
             * Shows the modal for adding a new detailed OT entry.
             * Initializes or updates the Flatpickr and time picker instances.
             */
            function showAddDetailedEntryModal() {
                const selectedDates = dateRangePickerInstance.selectedDates;
                const startDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : '';
                const endDate = selectedDates[1] ? selectedDates[1].toISOString().split('T')[0] : '';

                if (!startDate || !endDate || new Date(startDate) > new Date(endDate)) {
                    showToast('Please set a valid "OT Planning Date Range" before adding a manual entry.', 'error');
                    return;
                }

                // Clear previous errors and styling
                detailedEntryDateError.textContent = '';
                detailedEntryHoursError.textContent = '';
                detailedEntryStartTimeError.textContent = '';
                detailedEntryDate.classList.remove('input-error');
                detailedEntryHours.classList.remove('input-error');
                detailedEntryStartTime.classList.remove('input-error');

                // Calculate available dates before opening the modal
                const allDatesInRange = [];
                let currentCheckDate = new Date(startDate);
                const endCheckDate = new Date(endDate);
                while (currentCheckDate.getTime() <= endCheckDate.getTime()) {
                    allDatesInRange.push(currentCheckDate.toISOString().split('T')[0]);
                    currentCheckDate.setDate(currentCheckDate.getDate() + 1);
                }

                // Filter out dates that already have an OT entry (i.e., dates present in otEntries)
                const availableDatesForSelection = allDatesInRange.filter(dateString => {
                    return !otEntries.some(entry => entry.date === dateString);
                });

                if (availableDatesForSelection.length === 0) {
                    showToast('All dates in the current planning range already have an OT entry. Please adjust your date range or clear existing entries to add more.', 'info');
                    return; // Prevent modal from opening
                }

                // Initialize or update Flatpickr for date
                if (!detailedDatePickerInstance) {
                    detailedDatePickerInstance = window.flatpickr(detailedEntryDate, {
                        dateFormat: "Y-m-d",
                        minDate: startDate,
                        maxDate: endDate,
                        disable: otEntries.map(entry => entry.date), // Disable dates that already have an entry
                        defaultDate: availableDatesForSelection[0] || getTodayDateString(), // Set default to first available date
                        onChange: function(selectedDates, dateStr, instance) {
                            detailedEntryDateError.textContent = '';
                            detailedEntryDate.classList.remove('input-error');
                        }
                    });
                } else {
                    detailedDatePickerInstance.set('minDate', startDate);
                    detailedDatePickerInstance.set('maxDate', endDate);
                    detailedDatePickerInstance.set('disable', otEntries.map(entry => entry.date)); // Update disabled dates
                    detailedDatePickerInstance.setDate(availableDatesForSelection[0] || getTodayDateString()); // Set default to first available date
                    detailedDatePickerInstance.redraw();
                }

                // Initialize or update Flatpickr for time
                if (!detailedStartTimePickerInstance) {
                    detailedStartTimePickerInstance = window.flatpickr(detailedEntryStartTime, {
                        enableTime: true,
                        noCalendar: true,
                        dateFormat: "H:i",
                        time_24hr: true,
                        defaultHour: 18, // Default to 6 PM
                        defaultMinute: 0,
                        minuteIncrement: 15,
                        onChange: function(selectedDates, dateStr, instance) {
                            detailedEntryStartTimeError.textContent = '';
                            detailedEntryStartTime.classList.remove('input-error');
                            updateDetailedEntryEndTime();
                        }
                    });
                } else {
                    detailedStartTimePickerInstance.setDate('18:00', false); // Reset to default 6 PM
                }

                // Set default hours and calculate end time
                detailedEntryHours.value = '2.0';
                updateDetailedEntryEndTime();

                addDetailedOTEntryModal.classList.remove('hidden');
                addDetailedOTEntryModal.classList.add('show');
                window.lastFocusedElement = document.activeElement;
                detailedEntryDate.focus();
            }

            /**
             * Hides the detailed OT entry modal.
             */
            function hideAddDetailedEntryModal() {
                addDetailedOTEntryModal.classList.add('hidden');
                addDetailedOTEntryModal.classList.remove('show');
                if (window.lastFocusedElement) {
                    window.lastFocusedElement.focus();
                }
            }

            /**
             * Updates the calculated end time in the detailed entry modal.
             */
            function updateDetailedEntryEndTime() {
                const startTime = detailedEntryStartTime.value;
                const hours = parseFloat(detailedEntryHours.value);

                if (startTime && !isNaN(hours) && hours > 0) {
                    detailedEntryEndTime.value = addHoursToTime(startTime, hours);
                } else {
                    detailedEntryEndTime.value = '';
                }
            }

            /**
             * Handles confirming the detailed OT entry from the modal.
             */
            function handleConfirmDetailedEntry() {
                const selectedDate = detailedEntryDate.value;
                const hours = parseFloat(detailedEntryHours.value);
                const startTime = detailedEntryStartTime.value;
                const endTime = detailedEntryEndTime.value;

                // Clear previous errors
                detailedEntryDateError.textContent = '';
                detailedEntryHoursError.textContent = '';
                detailedEntryStartTimeError.textContent = '';
                detailedEntryDate.classList.remove('input-error');
                detailedEntryHours.classList.remove('input-error');
                detailedEntryStartTime.classList.remove('input-error');

                let isValid = true;

                if (!selectedDate) {
                    detailedEntryDateError.textContent = 'Please select a date.';
                    detailedEntryDate.classList.add('input-error');
                    isValid = false;
                }

                if (isNaN(hours) || hours <= 0) {
                    detailedEntryHoursError.textContent = 'Hours must be a positive number.';
                    detailedEntryHours.classList.add('input-error');
                    isValid = false;
                } else if (hours > CONFIG.MAX_DAILY_OT_HOURS) {
                    detailedEntryHoursError.textContent = `Max hours per day is ${CONFIG.MAX_DAILY_OT_HOURS}.`;
                    detailedEntryHours.classList.add('input-error');
                    isValid = false;
                }

                if (!startTime) {
                    detailedEntryStartTimeError.textContent = 'Please set a start time.';
                    detailedEntryStartTime.classList.add('input-error');
                    isValid = false;
                }

                const selectedDates = dateRangePickerInstance.selectedDates;
                const startDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : '';
                const endDate = selectedDates[1] ? selectedDates[1].toISOString().split('T')[0] : '';

                const selectedDateTime = new Date(selectedDate).setHours(0,0,0,0);
                const startDateTime = new Date(startDate).setHours(0,0,0,0);
                const endDateTime = new Date(endDate).setHours(0,0,0,0);

                if (selectedDateTime < startDateTime || selectedDateTime > endDateTime) {
                    detailedEntryDateError.textContent = `Date must be within ${startDate} and ${endDate}.`;
                    detailedEntryDate.classList.add('input-error');
                    isValid = false;
                }

                // Check for duplicate date across ALL existing entries
                const isDateAlreadyUsed = otEntries.some(entry => entry.date === selectedDate);
                if (isDateAlreadyUsed) {
                    detailedEntryDateError.textContent = `An OT entry already exists for ${selectedDate}. Each date can only have one OT entry.`;
                    detailedEntryDate.classList.add('input-error');
                    isValid = false;
                }

                if (!isValid) {
                    return;
                }

                addNewDetailedOTEntry(selectedDate, hours, startTime, endTime);
                hideAddDetailedEntryModal();
                showToast(`New OT entry added for ${selectedDate} (${hours}h, ${startTime}-${endTime}).`, 'success');
            }

            /**
             * Updates the Flatpickr instance for the manual entry date picker.
             * This function is called when the date range or OT entries change.
             */
            function updateManualEntryDatePicker() {
                // This function is now specifically for the detailed entry modal's date picker
                if (detailedDatePickerInstance) {
                    const selectedDates = dateRangePickerInstance.selectedDates;
                    const startDate = selectedDates[0] ? selectedDates[0].toISOString().split('T')[0] : null;
                    const endDate = selectedDates[1] ? selectedDates[1].toISOString().split('T')[0] : null;

                    detailedDatePickerInstance.set('minDate', startDate);
                    detailedDatePickerInstance.set('maxDate', endDate);
                    // Disable dates that already have an entry
                    detailedDatePickerInstance.set('disable', otEntries.map(entry => entry.date));
                    detailedDatePickerInstance.redraw();
                }
            }

            /**
             * Shows the allocation choice modal.
             */
            function showAllocationChoiceModal() {
                allocationChoiceModal.classList.remove('hidden');
                allocationChoiceModal.classList.add('show');
                window.lastFocusedElement = document.activeElement;
                clearAndAllocateBtn.focus();
            }

            /**
             * Hides the allocation choice modal.
             */
            function hideAllocationChoiceModal() {
                allocationChoiceModal.classList.add('hidden');
                allocationChoiceModal.classList.remove('show');
                if (window.lastFocusedElement) {
                    window.lastFocusedElement.focus();
                }
            }

            /**
             * Initializes Firebase if enabled.
             */
            async function initializeFirebase() {
                if (!isFirebaseEnabled) {
                    firebaseStatusMessage.textContent = 'Firebase (Save/Load) is currently disabled.';
                    userIdDisplay.classList.add('hidden');
                    return;
                }

                firebaseStatusMessage.textContent = 'Initializing Firebase...';
                try {
                    const firebaseConfigString = typeof __firebase_config !== 'undefined' ? __firebase_config : '{}';
                    const firebaseConfig = JSON.parse(firebaseConfigString);

                    if (Object.keys(firebaseConfig).length === 0) {
                        throw new Error("Firebase configuration is empty or invalid. Please ensure __firebase_config is set correctly.");
                    }

                    const app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            isAuthReady = true;
                            userIdDisplay.textContent = `User ID: ${userId}`;
                            userIdDisplay.classList.remove('hidden');
                            firebaseStatusMessage.textContent = 'Firebase enabled and connected.';
                            await loadOTEntries(false); // Load data once authenticated, don't show message box on initial load
                        } else {
                            try {
                                const anonymousUser = await signInAnonymously(auth);
                                userId = anonymousUser.user.uid;
                                isAuthReady = true;
                                userIdDisplay.textContent = `User ID: ${userId}`;
                                userIdDisplay.classList.remove('hidden');
                                firebaseStatusMessage.textContent = 'Firebase enabled and connected (anonymous).';
                                await loadOTEntries(false); // Load data once authenticated, don't show message box on initial load
                            } catch (error) {
                                console.error("Anonymous sign-in failed:", error);
                                firebaseStatusMessage.textContent = 'Firebase connection failed. Check console.';
                                showToast('Failed to sign in. This is often due to a network issue or a problem with your Firebase project setup. Please check your internet connection and ensure your Firebase project is correctly configured. Data saving/loading may not work.', 'error');
                            }
                        }
                        updateFirebaseButtonStates(); // Update button states after auth state is known
                    });
                } catch (error) {
                    console.error("Firebase initialization failed:", error);
                    firebaseStatusMessage.textContent = `Firebase init failed: ${error.message}.`;
                    showToast(`Firebase could not be initialized: ${error.message || 'Unknown error'}. Data saving/loading will not work. Please ensure your Firebase configuration is valid.`, 'error');
                    isFirebaseEnabled = false; // Force disable if init fails
                    firebaseToggle.checked = false;
                    localStorage.setItem('isFirebaseEnabled', 'false');
                    updateFirebaseButtonStates(); // Update button states to disabled
                    userIdDisplay.classList.add('hidden');
                }
            }

            /**
             * Updates the enabled/disabled state of Firebase-related buttons.
             */
            function updateFirebaseButtonStates() {
                saveDataBtn.disabled = !isFirebaseEnabled || !isAuthReady;
                loadDataBtn.disabled = !isFirebaseEnabled || !isAuthReady;
            }

            /**
             * Handles the change event for the Firebase toggle switch.
             */
            async function handleFirebaseToggleChange() {
                isFirebaseEnabled = firebaseToggle.checked;
                localStorage.setItem('isFirebaseEnabled', isFirebaseEnabled);

                if (isFirebaseEnabled) {
                    await initializeFirebase();
                } else {
                    db = null;
                    auth = null;
                    userId = null;
                    isAuthReady = false;
                    userIdDisplay.classList.add('hidden');
                    firebaseStatusMessage.textContent = 'Firebase (Save/Load) is now disabled.';
                }
                updateFirebaseButtonStates();
            }


            document.addEventListener('DOMContentLoaded', async () => {
                // --- DOM Elements Assignment ---
                basicSalaryInput = document.getElementById('basicSalary');
                clearBasicSalaryBtn = basicSalaryInput.nextElementSibling;
                targetOTPaySelect = document.getElementById('targetOTPaySelect');
                customTargetOTPayInput = document.getElementById('customTargetOTPayInput');
                clearCustomTargetOTPayBtn = document.getElementById('clearCustomTargetOTPayBtn');
                
                dateRangeInput = document.getElementById('dateRangeInput');
                dateRangeError = document.getElementById('dateRangeError');
                setThisMonthBtn = document.getElementById('setThisMonthBtn');

                publicHolidayDateInput = document.getElementById('publicHolidayDate');
                addPublicHolidayDateBtn = document.getElementById('addPublicHolidayDateBtn');
                publicHolidaysList = document.getElementById('publicHolidaysList');
                otMultiplierInputsContainer = document.getElementById('otMultiplierInputs');
                resetMultipliersBtn = document.getElementById('resetMultipliersBtn');
                allocationStrategySelect = document.getElementById('allocationStrategy');
                allocationStrategyDescription = document.getElementById('allocationStrategyDescription');
                workloadPresetSelect = document.getElementById('workloadPreset');
                workloadPresetGroup = document.getElementById('workloadPresetGroup'); // Assign the new element
                workloadPresetDescription = document.getElementById('workloadPresetDescription');
                workloadPresetDetails = document.getElementById('workloadPresetDetails');
                otEntriesContainer = document.getElementById('otEntriesContainer');
                noEntriesMessage = document.getElementById('noEntriesMessage');
                addOTEntryBtn = document.getElementById('addOTEntryBtn');
                autoAllocateBtn = document.getElementById('autoAllocateBtn');
                autoAllocateLoading = document.getElementById('autoAllocateLoading');
                resetAndReallocateBtn = document.getElementById('resetAndReallocateBtn');
                clearAllEntriesBtn = document.getElementById('clearAllEntriesBtn');
                // Removed calculateBtn = document.getElementById('calculateBtn');
                saveDataBtn = document.getElementById('saveDataBtn');
                loadDataBtn = document.getElementById('loadDataBtn');
                resultsSection = document.getElementById('results');
                totalHoursByTypeElem = document.getElementById('totalHoursByType');
                totalPayByCategoryElem = document.getElementById('totalPayByCategory');
                combinedOTPayElem = document.getElementById('combinedOTPay');
                targetOTPayDisplayElem = document.getElementById('targetOTPayDisplay');
                differenceFromTargetElem = document.getElementById('differenceFromTarget');
                totalMonthlyOTHoursDisplay = document.getElementById('totalMonthlyOTHoursDisplay');
                expectedSalaryPayDisplay = document.getElementById('expectedSalaryPayDisplay');
                exportSummaryBtn = document.getElementById('exportSummaryBtn');
                userIdDisplay = document.getElementById('userIdDisplay');
                allocationStrategySummary = document.getElementById('allocationStrategySummary'); // NEW: Assign element

                messageBox = document.getElementById('messageBox');
                messageBoxTitle = document.getElementById('messageBoxTitle');
                messageBoxContent = document.getElementById('messageBoxContent');
                messageBoxCloseBtn = document.getElementById('messageBoxCloseBtn');
                messageBoxConfirmBtn = document.getElementById('messageBoxConfirmBtn');
                messageBoxCancelBtn = document.getElementById('messageBoxCancelBtn');

                addDetailedOTEntryModal = document.getElementById('addDetailedOTEntryModal');
                detailedEntryModalTitle = document.getElementById('detailedEntryModalTitle');
                detailedEntryDate = document.getElementById('detailedEntryDate');
                detailedEntryDateError = document.getElementById('detailedEntryDateError');
                detailedEntryHours = document.getElementById('detailedEntryHours');
                detailedEntryHoursError = document.getElementById('detailedEntryHoursError');
                detailedEntryStartTime = document.getElementById('detailedEntryStartTime');
                detailedEntryStartTimeError = document.getElementById('detailedEntryStartTimeError');
                detailedEntryEndTime = document.getElementById('detailedEntryEndTime');
                confirmDetailedEntryBtn = document.getElementById('confirmDetailedEntryBtn');
                cancelDetailedEntryBtn = document.getElementById('cancelDetailedEntryBtn');

                allocationChoiceModal = document.getElementById('allocationChoiceModal');
                clearAndAllocateBtn = document.getElementById('clearAndAllocateBtn');
                fillRemainingBtn = document.getElementById('fillRemainingBtn');
                cancelAllocationChoiceBtn = document.getElementById('cancelAllocationChoiceBtn');

                setPublicHolidayTodayBtn = document.getElementById('setPublicHolidayTodayBtn');

                collapsibleHeaders = document.querySelectorAll('.collapsible-header');
                publicHolidaysContent = document.getElementById('publicHolidaysContent');
                otMultiplierContent = document.getElementById('otMultiplierContent');
                howToUseContent = document.getElementById('howToUseContent');

                saveDataStatus = document.getElementById('saveDataStatus');
                loadDataStatus = document.getElementById('loadDataStatus');

                firebaseToggle = document.getElementById('firebaseToggle');
                firebaseStatusMessage = document.getElementById('firebaseStatusMessage');

                loadingOverlay = document.getElementById('loadingOverlay');
                toastContainer = document.getElementById('toastContainer');
                chartPlaceholder = document.getElementById('chartPlaceholder'); // Assign the new element


                // --- Firebase Initialization ---
                // Set initial state of the toggle
                firebaseToggle.checked = isFirebaseEnabled;

                // Only attempt Firebase init if enabled
                if (isFirebaseEnabled) {
                    await initializeFirebase();
                } else {
                    firebaseStatusMessage.textContent = 'Firebase (Save/Load) is currently disabled.';
                    userIdDisplay.classList.add('hidden');
                }
                updateFirebaseButtonStates();


                // --- Event Listeners ---
                // Apply debounce directly to input event listeners
                basicSalaryInput.addEventListener('input', debounce(calculateAndDisplayResults, 150));
                // NEW: Modified listener for custom target pay input
                customTargetOTPayInput.addEventListener('input', debounce(() => {
                    updateAllocationStrategyBasedOnTarget();
                    calculateAndDisplayResults();
                }, 150));

                // Initialize Flatpickr for date range input
                dateRangePickerInstance = window.flatpickr(dateRangeInput, {
                    mode: "range",
                    dateFormat: "Y-m-d",
                    onChange: function(selectedDates, dateStr, instance) {
                        calculateAndDisplayResults();
                        updateManualEntryDatePicker();
                        updatePublicHolidayDatePicker();
                        dateRangeError.textContent = '';
                        dateRangeInput.classList.remove('input-error');
                    }
                });

                // Set default date range to current month
                const today = new Date();
                const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);
                dateRangePickerInstance.setDate([firstDayOfMonth, lastDayOfMonth], true);

                // Set "This Month" button listener
                setThisMonthBtn.addEventListener('click', () => {
                    const today = new Date();
                    const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                    const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);
                    dateRangePickerInstance.setDate([firstDayOfMonth, lastDayOfMonth], true);
                    showToast('Date range set to current month.', 'info');
                });


                // Modified autoAllocateBtn to show choice modal first
                autoAllocateBtn.addEventListener('click', showAllocationChoiceModal);
                // New listeners for the allocation choice modal buttons
                clearAndAllocateBtn.addEventListener('click', () => {
                    hideAllocationChoiceModal();
                    performAutoAllocation(true); // True to clear existing
                });
                fillRemainingBtn.addEventListener('click', () => {
                    hideAllocationChoiceModal();
                    performAutoAllocation(false); // False to keep existing
                });
                cancelAllocationChoiceBtn.addEventListener('click', hideAllocationChoiceModal);

                // NEW: Listener for the Reset & Re-allocate All button
                resetAndReallocateBtn.addEventListener('click', () => {
                    showMessageBox(
                        'Confirm Reset & Re-allocate',
                        'Are you sure you want to clear ALL existing OT entries and re-allocate from scratch? This action cannot be undone.',
                        'confirm',
                        () => performAutoAllocation(true) // Directly call with clearExisting = true
                    );
                });


                clearAllEntriesBtn.addEventListener('click', clearDailyOTEntries);
                // Removed calculateBtn.addEventListener('click', () => performAutoAllocation(false));
                exportSummaryBtn.addEventListener('click', exportSummary);
                saveDataBtn.addEventListener('click', saveOTEntries);
                loadDataBtn.addEventListener('click', () => loadOTEntries(true));
                workloadPresetSelect.addEventListener('change', updateWorkloadPresetDetails);
                // IMPORTANT CHANGE: Call updateAllocationStrategyBasedOnTarget directly when allocationStrategySelect changes
                allocationStrategySelect.addEventListener('change', updateAllocationStrategyBasedOnTarget);
                addPublicHolidayDateBtn.addEventListener('click', addPublicHoliday);
                resetMultipliersBtn.addEventListener('click', resetMultipliersToDefault);
                targetOTPaySelect.addEventListener('change', handleTargetOTPayChange);

                // Clear input buttons
                clearBasicSalaryBtn.addEventListener('click', () => {
                    basicSalaryInput.value = '';
                    calculateAndDisplayResults();
                    showToast('Basic Salary cleared.', 'info');
                });
                // NEW: Modified listener for clear custom target pay button
                clearCustomTargetOTPayBtn.addEventListener('click', () => { // Corrected variable name
                    customTargetOTPayInput.value = '';
                    updateAllocationStrategyBasedOnTarget();
                    calculateAndDisplayResults();
                    showToast('Custom Target OT Pay cleared.', 'info');
                });

                // "Today" button listener for public holiday
                setPublicHolidayTodayBtn.addEventListener('click', () => {
                    publicHolidayDateInput.value = getTodayDateString();
                    if (publicHolidayDatePickerInstance) {
                        publicHolidayDatePickerInstance.setDate(publicHolidayDateInput.value, true);
                    }
                    showToast('Public Holiday date set to today.', 'info');
                });

                // Collapsible section listeners
                collapsibleHeaders.forEach(header => {
                    header.addEventListener('click', () => {
                        const targetId = header.dataset.target;
                        const targetContent = document.getElementById(targetId);
                        const icon = header.querySelector('.collapsible-icon');

                        if (targetContent.classList.contains('collapsed')) {
                            expandCollapsible(targetContent, icon);
                        } else {
                            collapseCollapsible(targetContent, icon);
                        }
                    });
                });

                // Event listeners for NEW detailed entry modal buttons
                addOTEntryBtn.addEventListener('click', showAddDetailedEntryModal);
                confirmDetailedEntryBtn.addEventListener('click', handleConfirmDetailedEntry);
                cancelDetailedEntryBtn.addEventListener('click', hideAddDetailedEntryModal);
                detailedEntryHours.addEventListener('input', updateDetailedEntryEndTime);
                detailedEntryStartTime.addEventListener('input', updateDetailedEntryEndTime);

                // New: Firebase toggle listener
                firebaseToggle.addEventListener('change', handleFirebaseToggleChange);


                // Initial Setup
                populateTargetOTPayDropdown();
                renderOTMultiplierInputs();

                // Initialize Flatpickr for public holiday date picker
                publicHolidayDatePickerInstance = window.flatpickr(publicHolidayDateInput, {
                    dateFormat: "Y-m-d",
                });

                // Initialize collapsible sections to be collapsed by default
                howToUseContent.classList.add('collapsed');
                publicHolidaysContent.classList.add('collapsed');
                otMultiplierContent.classList.add('collapsed');

                // Initial call for new UX elements
                updateAllocationStrategyDisplay();
                updateWorkloadPresetDetails();
                updatePublicHolidayDatePicker();
                updateAllocationStrategyBasedOnTarget(); // NEW: Set initial strategy state
            });
        })(); // End of IIFE
    </script>
</body>
</html>
