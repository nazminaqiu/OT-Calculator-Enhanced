<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OT Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general body */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to allow scrolling */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .main-wrapper {
            display: flex;
            flex-direction: column; /* Default to column on small screens */
            gap: 25px;
            max-width: 1200px; /* Increased max-width to accommodate two columns */
            width: 100%;
        }
        @media (min-width: 1024px) { /* md breakpoint for two columns */
            .main-wrapper {
                flex-direction: row; /* Two columns on larger screens */
                align-items: flex-start;
            }
        }

        .form-content {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            flex: 2; /* Takes 2/3 of the space */
            width: 100%; /* Ensure it takes full width in column layout */
        }
        @media (min-width: 1024px) {
            .form-content {
                width: auto; /* Let flex handle width */
            }
        }

        .summary-sidebar {
            flex: 1; /* Takes 1/3 of the space */
            width: 100%; /* Ensure it takes full width in column layout */
            position: sticky; /* Make it sticky */
            top: 20px; /* Distance from the top when sticky */
            align-self: flex-start; /* Align to the top of the flex container */
            max-height: calc(100vh - 40px); /* Max height to fit viewport, considering padding */
            overflow-y: auto; /* Add scroll if content is too long */
            padding-bottom: 20px; /* Add some padding at the bottom */
        }
        @media (min-width: 1024px) {
            .summary-sidebar {
                width: auto; /* Let flex handle width */
            }
        }

        .input-group label {
            font-weight: 600;
            color: #374151; /* Darker gray for labels */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db; /* Light gray border */
            border-radius: 8px;
            font-size: 1rem;
            color: #4b5563; /* Medium gray for input text */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Light indigo shadow */
        }
        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background-color: #6366f1; /* Indigo */
            color: #ffffff;
        }
        .btn-primary:hover {
            background-color: #4f46e5; /* Darker indigo */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e0e7ff; /* Light indigo */
            color: #4f46e5; /* Darker indigo text */
        }
        .btn-secondary:hover {
            background-color: #c7d2fe; /* Even lighter indigo */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444; /* Red */
            color: #ffffff;
        }
        .btn-danger:hover {
            background-color: #dc2626; /* Darker red */
            transform: translateY(-1px);
        }
        .results-section {
            background-color: #f9fafb; /* Very light gray */
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #e5e7eb; /* Subtle border */
        }
        .results-section h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937; /* Darkest gray */
            margin-bottom: 15px;
        }
        .results-section p {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #374151;
        }
        .results-section p strong {
            color: #111827; /* Even darker for emphasis */
        }
        .ot-entry-row {
            display: grid;
            grid-template-columns: 1fr 0.5fr 1fr 1fr 1fr 0.1fr; /* Date, Hours, Type, Start Time, End Time, Remove Button */
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        .ot-entry-row .input-group {
            margin-bottom: 0; /* Override default margin for compact rows */
        }
        .ot-entry-row .input-group label {
            font-size: 0.85rem; /* Smaller labels for row items */
            margin-bottom: 4px;
        }
        .ot-entry-row input, .ot-entry-row select {
            padding: 8px;
            font-size: 0.9rem;
        }
        .message-box {
            position: fixed;
            top: 50% ;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
            min-width: 300px;
            max-width: 90%;
            border: 1px solid #d1d5db;
        }
        .message-box h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 15px;
        }
        .message-box p {
            font-size: 1.1rem;
            color: #4b5563;
            margin-bottom: 25px;
        }
        .message-box-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .message-box button {
            background-color: #6366f1;
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .message-box button:hover {
            background-color: #4f46e5;
        }
        .message-box .btn-cancel {
            background-color: #e5e7eb;
            color: #4b5563;
        }
        .message-box .btn-cancel:hover {
            background-color: #d1d5db;
        }


        /* Responsive adjustments */
        @media (max-width: 768px) {
            .form-content, .summary-sidebar {
                padding: 20px;
            }
            .ot-entry-row {
                grid-template-columns: 1fr; /* Stack columns on small screens */
            }
            .ot-entry-row .remove-btn-container {
                display: flex;
                justify-content: flex-end; /* Align remove button to the right */
                margin-top: 10px;
            }
        }
        .ot-group-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f0f4f8; /* Lighter background for groups */
            border-radius: 10px;
            border: 1px solid #e2e8f0;
        }
        .ot-group-section h4 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #2d3748; /* Darker text for group headings */
            margin-bottom: 10px;
            border-bottom: 1px solid #cbd5e0;
            padding-bottom: 5px;
        }
        .loading-indicator {
            margin-left: 10px;
            font-size: 0.9em;
            color: #6366f1;
            font-weight: 500;
        }
        #userIdDisplay {
            font-size: 0.8em;
            color: #6b7280;
            text-align: right;
            margin-top: -15px;
            margin-bottom: 15px;
            word-break: break-all; /* Ensures long IDs wrap */
        }

        /* New highlight CSS */
        .highlight-new {
            animation: highlightFade 2s ease-out forwards;
        }

        @keyframes highlightFade {
            from { background-color: #e0f2fe; } /* Light blue */
            to { background-color: #f9fafb; } /* Original background */
        }

        .new-badge {
            background-color: #10b981; /* Green-500 */
            color: white;
            padding: 2px 8px;
            border-radius: 9999px; /* Full rounded */
            font-size: 0.75rem; /* text-xs */
            font-weight: 600; /* font-semibold */
            margin-left: 8px; /* ml-2 */
            display: inline-block;
            vertical-align: middle;
        }

        /* Styles for inline summary display */
        .summary-inline-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Space between items */
            font-size: 1.0rem;
            color: #374151;
            margin-bottom: 8px;
        }
        .summary-inline-group strong {
            display: block; /* Ensure the strong tag is on its own line */
            width: 100%; /* Take full width */
            margin-bottom: 4px;
        }
        .summary-inline-item {
            display: inline-block;
            padding: 4px 8px;
            background-color: #e0e7ff; /* Light indigo background */
            border-radius: 6px;
            color: #4f46e5; /* Darker indigo text */
            font-weight: 500;
        }

        /* Collapsible section styles */
        .collapsible-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px 0;
            border-bottom: 1px solid #cbd5e0;
            margin-bottom: 15px;
        }
        .collapsible-header h3 {
            margin-bottom: 0; /* Override default margin */
        }
        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .collapsible-content.collapsed {
            max-height: 0;
        }
        .collapsible-icon {
            transition: transform 0.3s ease-out;
        }
        .collapsible-icon.rotated {
            transform: rotate(90deg);
        }

        /* Input validation styles */
        .input-error {
            border-color: #ef4444; /* Red border */
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.2); /* Light red shadow */
        }
        .error-message {
            color: #ef4444; /* Red text */
            font-size: 0.85rem;
            margin-top: 4px;
        }
    </style>
</head>
<body>
    <div class="main-wrapper">
        <div class="form-content">
            <h2 class="text-3xl font-extrabold text-center text-gray-900 mb-6">OT Calculator</h2>
            <div id="userIdDisplay" class="hidden"></div>

            <!-- Employee Settings -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Employee Settings</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                    <div class="input-group">
                        <label for="basicSalary">Basic Monthly Salary (RM)</label>
                        <input type="number" id="basicSalary" value="3700.00" min="0" step="0.01" class="shadow-sm">
                    </div>
                    <div class="input-group">
                        <label for="targetOTPaySelect">Target OT Pay (RM) (Optional)</label>
                        <select id="targetOTPaySelect" class="shadow-sm mb-2">
                            <option value="">No Target</option>
                            <!-- Options will be dynamically added by JavaScript -->
                            <option value="custom">Other (Enter Manually)</option>
                        </select>
                        <input type="number" id="customTargetOTPayInput" class="shadow-sm hidden" placeholder="Enter custom target pay">
                    </div>
                </div>
                <p class="text-sm text-gray-600 mt-4">
                    Working Schedule: 5 days/week, Saturday: Off Day, Sunday: Rest Day.
                    For payroll, employer uses 26 working days monthly.
                </p>
            </div>

            <!-- Date Range Container -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <h3 class="text-xl font-bold text-gray-800 mb-4">OT Planning Date Range</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                    <div class="input-group">
                        <label for="startDate">Start Date</label>
                        <div class="flex items-center gap-2">
                            <input type="date" id="startDate" class="shadow-sm flex-grow">
                            <button type="button" id="setStartDateTodayBtn" class="btn btn-secondary p-2" aria-label="Set start date to today">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                    <div class="input-group">
                        <label for="endDate">End Date</label>
                        <div class="flex items-center gap-2">
                            <input type="date" id="endDate" class="shadow-sm flex-grow">
                            <button type="button" id="setEndDateTodayBtn" class="btn btn-secondary p-2" aria-label="Set end date to today">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Public Holiday Management (Collapsible) -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <div class="collapsible-header" data-target="publicHolidaysContent">
                    <h3 class="text-xl font-bold text-gray-800">Public Holiday Management</h3>
                    <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="publicHolidaysContent" class="collapsible-content">
                    <div class="flex flex-col sm:flex-row gap-4 mb-4">
                        <div class="input-group flex-grow">
                            <label for="publicHolidayDate">Add Public Holiday Date</label>
                            <div class="flex items-center gap-2">
                                <input type="date" id="publicHolidayDate" class="shadow-sm flex-grow">
                                <button type="button" id="setPublicHolidayTodayBtn" class="btn btn-secondary p-2" aria-label="Set public holiday date to today">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                        <path fill-rule="evenodd" d="M6 2a1 1 0 00-1 1v1H4a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2h-1V3a1 1 0 10-2 0v1H7V3a1 1 0 00-1-1zm0 5a1 1 0 000 2h8a1 1 0 100-2H6z" clip-rule="evenodd" />
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <button id="addPublicHolidayBtn" class="btn btn-secondary mt-auto" aria-label="Add public holiday">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                            </svg>
                            Add Holiday
                        </button>
                    </div>
                    <ul id="publicHolidaysList" class="list-disc list-inside ml-4 text-gray-700">
                        <!-- Public holidays will be listed here -->
                    </ul>
                </div>
            </div>

            <!-- OT Multiplier Settings (Collapsible) -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200 mb-6">
                <div class="collapsible-header" data-target="otMultiplierContent">
                    <h3 class="text-xl font-bold text-gray-800">OT Multiplier Settings</h3>
                    <svg class="collapsible-icon h-6 w-6 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </div>
                <div id="otMultiplierContent" class="collapsible-content">
                    <div id="otMultiplierInputs" class="grid grid-cols-1 md:grid-cols-2 gap-5 mb-4">
                        <!-- Multiplier inputs will be dynamically generated here -->
                    </div>
                    <button id="resetMultipliersBtn" class="btn btn-secondary" aria-label="Reset OT multipliers to default">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-8a1 1 0 011-1h3a1 1 0 110 2H4a1 1 0 01-1-1zm11 0a1 1 0 011-1h3a1 1 0 110 2h-3a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Reset to Default Multipliers
                    </button>
                </div>
            </div>

            <!-- Daily OT Entries -->
            <div class="bg-gray-50 p-6 rounded-xl border border-gray-200">
                <h3 class="text-xl font-bold text-gray-800 mb-4">Daily Overtime Entries</h3>
                <div class="input-group mb-4">
                    <label for="allocationStrategy">Allocation Strategy</label>
                    <select id="allocationStrategy" class="shadow-sm">
                        <option value="Target-Driven">Target-Driven (using Workload Presets)</option>
                        <option value="Workload-Driven">Workload-Driven (Fill All Days)</option>
                    </select>
                </div>
                <div class="input-group mb-4">
                    <label for="workloadPreset">Workload Preset for Auto Allocation</label>
                    <select id="workloadPreset" class="shadow-sm">
                        <option value="Moderate Workload">Moderate Workload</option>
                        <option value="Light Workload">Light Workload</option>
                        <option value="Heavy Workload">Heavy Workload</option>
                    </select>
                </div>
                <!-- Dynamic Workload Preset Details -->
                <div id="workloadPresetDetails" class="text-sm text-gray-700 mb-4 p-3 bg-gray-100 rounded-md border border-gray-200">
                    <!-- Details will be inserted here by JavaScript -->
                </div>

                <button id="autoAllocateBtn" class="btn btn-secondary w-full mb-4" aria-label="Auto allocate hours">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-8a1 1 0 011-1h3a1 1 0 110 2H4a1 1 0 01-1-1zm11 0a1 1 0 011-1h3a1 1 0 110 2h-3a1 1 0 01-1-1z" clip-rule="evenodd" />
                    </svg>
                    Auto Allocate Hours
                    <span id="autoAllocateLoading" class="loading-indicator hidden">Allocating...</span>
                </button>
                <div id="otEntriesContainer">
                    <!-- OT entry rows will be added here by JavaScript -->
                </div>
                <div class="flex flex-col sm:flex-row gap-4 mt-4">
                    <button id="addOTEntryBtn" class="btn btn-secondary flex-grow" aria-label="Add new OT entry">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                        </svg>
                        Add OT Entry
                    </button>
                    <button id="clearAllEntriesBtn" class="btn btn-danger flex-grow" aria-label="Clear all OT entries">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                    </svg>
                        Clear All Entries
                    </button>
                </div>
                <div class="flex flex-col sm:flex-row gap-4 mt-4">
                    <button id="saveDataBtn" class="btn btn-primary flex-grow" aria-label="Save current data">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M7 3a1 1 0 00-1 1v1a1 1 0 001 1h6a1 1 0 001-1V4a1 1 0 00-1-1H7z" />
                            <path fill-rule="evenodd" d="M18 8H2a2 2 0 00-2 2v8a2 2 0 002 2h16a2 2 0 002-2v-8a2 2 0 00-2-2zM4 13a1 1 0 011-1h10a1 1 0 011 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-3z" clip-rule="evenodd" />
                        </svg>
                        Save Data
                    </button>
                    <button id="loadDataBtn" class="btn btn-secondary flex-grow" aria-label="Load saved data">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm0 4a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                        </svg>
                        Load Data
                    </button>
                </div>
            </div>

            <button id="calculateBtn" class="btn btn-primary w-full mt-4" aria-label="Calculate total OT pay">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path d="M2 11a1 1 0 011-1h14a1 1 0 011 1v4a1 1 0 01-1 1H3a1 1 0 01-1-1v-4z" />
                    <path fill-rule="evenodd" d="M14.5 4.5a3 3 0 11-6 0 3 3 0 016 0zm-6.293 3.293a1 1 0 011.414 0L10 8.586l.293-.293a1 1 0 011.414 0l.707.707a1 1 0 010 1.414L10 11.414l-.293.293a1 1 0 01-1.414 0l-.707-.707a1 1 0 010-1.414L9.414 9l-.293-.293a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                Calculate OT
            </button>
        </div>

        <!-- Results Section (Moved to a sticky sidebar) -->
        <div class="summary-sidebar">
            <div id="results" class="results-section">
                <h3 class="text-2xl font-bold text-gray-900 mb-4">Calculation Summary</h3>
                <!-- Changed to inline display -->
                <div class="summary-inline-group">
                    <strong>Total OT Hours by Type:</strong>
                    <span id="totalHoursByType" class="text-gray-700"></span>
                </div>
                <div class="summary-inline-group">
                    <strong>Total Pay per OT Category:</strong>
                    <span id="totalPayByCategory" class="text-gray-700"></span>
                </div>
                <!-- End of changes for inline display -->
                <p class="text-xl font-bold text-gray-900 mt-6">Combined OT Pay: <span id="combinedOTPay" class="text-indigo-600">RM 0.00</span></p>
                <p class="text-xl font-bold text-gray-900 mt-2">Target OT Pay: <span id="targetOTPayDisplay" class="text-green-600">RM 0.00</span></p>
                <p class="text-xl font-bold mt-2">Difference from Target: <span id="differenceFromTarget">RM 0.00</span></p>
                <p class="text-xl font-bold mt-2">Total Monthly OT Hours: <span id="totalMonthlyOTHoursDisplay">0.0 hours</span></p>
                <!-- New: Expected Salary Pay -->
                <p class="text-xl font-bold text-gray-900 mt-2">Expected Salary Pay: <span id="expectedSalaryPayDisplay" class="text-indigo-600">RM 0.00</span></p>
                <button id="exportSummaryBtn" class="btn btn-secondary mt-6" aria-label="Export OT summary to text file">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l2.293-2.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                    Export Summary
                </button>
            </div>
        </div>
    </div>

    <!-- Message Box HTML -->
    <div id="messageBox" class="message-box hidden">
        <h4 id="messageBoxTitle"></h4>
        <p id="messageBoxContent"></p>
        <div class="message-box-buttons">
            <button id="messageBoxCancelBtn" class="btn btn-cancel hidden">Cancel</button>
            <button id="messageBoxConfirmBtn" class="hidden">Confirm</button>
            <button id="messageBoxCloseBtn">OK</button>
        </div>
    </div>

    <script type="module">
        // Firebase SDK imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Configuration Constants (Moved to global scope) ---
        const DEFAULT_OT_MULTIPLIERS = { // Store original defaults
            'Normal OT (Weekdays)': 1.5,
            'Off Day (Saturday)': 1.5,
            'Rest Day (Sunday) — 1st 8h': 0.5,
            'Rest Day (Sunday) — after 8h': 2.0,
            'Public Holiday': 2.0
        };

        const PREDEFINED_TARGET_PAYS = [
            1000.00,
            2000.00,
            3000.00,
            4000.00,
            5000.00
        ];

        const CONFIG = {
            WORKING_DAYS_MONTHLY: 26,
            STANDARD_WORK_HOURS_DAILY: 8,
            MAX_DAILY_OT_HOURS: 8, // Max 8 hours OT per day as per typical regulations
            MAX_MONTHLY_OT_HOURS: 104, // Max 104 hours OT per month as per typical regulations
            ALLOCATION_PRECISION: 0.01, // Small value to handle floating point comparisons
            OT_MULTIPLIERS: { ...DEFAULT_OT_MULTIPLIERS }, // Current multipliers, can be changed by user
            // Define preferred allocation ranges for auto-allocation based on workload presets
            WORKLOAD_PRESETS: {
                'Light Workload': {
                    'Normal OT (Weekdays)': { minHours: 1, maxHours: 3 },
                    'Off Day (Saturday)': { minHours: 2, maxHours: 4 },
                    // Sunday 1st 8h now uses a range for flexibility
                    'Rest Day (Sunday) — 1st 8h': { minHours: 2, maxHours: 4 },
                    'Rest Day (Sunday) — after 8h': { minHours: 0.5, maxHours: 2 }
                },
                'Moderate Workload': {
                    'Normal OT (Weekdays)': { minHours: 2, maxHours: 4 },
                    'Off Day (Saturday)': { minHours: 3, maxHours: 5 },
                    // Sunday 1st 8h now uses a range for flexibility
                    'Rest Day (Sunday) — 1st 8h': { minHours: 4, maxHours: 6 },
                    'Rest Day (Sunday) — after 8h': { minHours: 1, maxHours: 3 }
                },
                'Heavy Workload': {
                    'Normal OT (Weekdays)': { minHours: 3, maxHours: 6 },
                    'Off Day (Saturday)': { minHours: 5, maxHours: 8 },
                    // Sunday 1st 8h now uses a range for flexibility
                    'Rest Day (Sunday) — 1st 8h': { minHours: 6, maxHours: 8 },
                    'Rest Day (Sunday) — after 8h': { minHours: 3, maxHours: 8 }
                }
            },
            // Define base allocation steps (these will be overridden by presets for min/max hours)
            ALLOCATION_STEPS: [
                { type: 'Normal OT (Weekdays)', days: [1, 2, 3, 4, 5] }, // Mon-Fri
                { type: 'Off Day (Saturday)', days: [6] }, // Saturday
                // Sunday 1st 8h now uses minHours/maxHours from presets, not a fixed 'hours: 8'
                { type: 'Rest Day (Sunday) — 1st 8h', days: [0] },
                { type: 'Rest Day (Sunday) — after 8h', days: [0] },
            ]
        };

        let db;
        let auth;
        let userId;
        let isAuthReady = false; // Flag to ensure Firestore operations wait for auth

        document.addEventListener('DOMContentLoaded', async () => {
            // --- DOM Elements ---
            const basicSalaryInput = document.getElementById('basicSalary');
            const targetOTPaySelect = document.getElementById('targetOTPaySelect'); // Changed to select
            const customTargetOTPayInput = document.getElementById('customTargetOTPayInput'); // Re-added custom input
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const publicHolidayDateInput = document.getElementById('publicHolidayDate');
            const addPublicHolidayBtn = document.getElementById('addPublicHolidayBtn');
            const publicHolidaysList = document.getElementById('publicHolidaysList');
            const otMultiplierInputsContainer = document.getElementById('otMultiplierInputs'); // New container for multipliers
            const resetMultipliersBtn = document.getElementById('resetMultipliersBtn'); // New reset button
            const allocationStrategySelect = document.getElementById('allocationStrategy'); // New strategy select
            const workloadPresetSelect = document.getElementById('workloadPreset');
            const workloadPresetDetails = document.getElementById('workloadPresetDetails'); // New element for details
            const otEntriesContainer = document.getElementById('otEntriesContainer');
            const addOTEntryBtn = document.getElementById('addOTEntryBtn');
            const autoAllocateBtn = document.getElementById('autoAllocateBtn');
            const autoAllocateLoading = document.getElementById('autoAllocateLoading'); // Loading indicator
            const clearAllEntriesBtn = document.getElementById('clearAllEntriesBtn');
            const calculateBtn = document.getElementById('calculateBtn');
            const saveDataBtn = document.getElementById('saveDataBtn');
            const loadDataBtn = document.getElementById('loadDataBtn');
            const resultsSection = document.getElementById('results');
            const totalHoursByTypeElem = document.getElementById('totalHoursByType');
            const totalPayByCategoryElem = document.getElementById('totalPayByCategory');
            const combinedOTPayElem = document.getElementById('combinedOTPay');
            const targetOTPayDisplayElem = document.getElementById('targetOTPayDisplay');
            const differenceFromTargetElem = document.getElementById('differenceFromTarget');
            const totalMonthlyOTHoursDisplay = document.getElementById('totalMonthlyOTHoursDisplay'); // New element
            const expectedSalaryPayDisplay = document.getElementById('expectedSalaryPayDisplay'); // New element for expected salary
            const exportSummaryBtn = document.getElementById('exportSummaryBtn');
            const userIdDisplay = document.getElementById('userIdDisplay'); // New element for user ID

            const messageBox = document.getElementById('messageBox');
            const messageBoxTitle = document.getElementById('messageBoxTitle');
            const messageBoxContent = document.getElementById('messageBoxContent');
            const messageBoxCloseBtn = document.getElementById('messageBoxCloseBtn');
            const messageBoxConfirmBtn = document.getElementById('messageBoxConfirmBtn'); // New confirm button
            const messageBoxCancelBtn = document.getElementById('messageBoxCancelBtn'); // New cancel button

            // Date "Today" buttons
            const setStartDateTodayBtn = document.getElementById('setStartDateTodayBtn');
            const setEndDateTodayBtn = document.getElementById('setEndDateTodayBtn');
            const setPublicHolidayTodayBtn = document.getElementById('setPublicHolidayTodayBtn');

            // Collapsible sections
            const collapsibleHeaders = document.querySelectorAll('.collapsible-header');

            // --- State Variables ---
            let otEntries = []; // Stores objects like { id, date, hours, type, startTime, endTime, isNew }
            let publicHolidays = []; // Stores public holiday dates as YYYY-MM-DD strings
            let entryCounter = 0; // To generate unique IDs for each entry row

            // --- Firebase Initialization ---
            try {
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Listen for auth state changes to set userId and load data
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        isAuthReady = true;
                        userIdDisplay.textContent = `User ID: ${userId}`;
                        userIdDisplay.classList.remove('hidden');
                        console.log("Firebase authenticated. User ID:", userId);
                        await loadOTEntries(); // Load data once authenticated
                    } else {
                        // Sign in anonymously if no user is logged in
                        try {
                            const anonymousUser = await signInAnonymously(auth);
                            userId = anonymousUser.user.uid;
                            isAuthReady = true;
                            userIdDisplay.textContent = `User ID: ${userId}`;
                            userIdDisplay.classList.remove('hidden');
                            console.log("Signed in anonymously. User ID:", userId);
                            await loadOTEntries(); // Load data once authenticated
                        } catch (error) {
                            console.error("Anonymous sign-in failed:", error);
                            showMessageBox('Authentication Error', 'Failed to sign in. Data saving/loading may not work.');
                        }
                    }
                });
            } catch (error) {
                console.error("Firebase initialization failed:", error);
                showMessageBox('Initialization Error', 'Firebase could not be initialized. Data saving/loading will not work.');
            }

            // --- Utility Functions ---

            /**
             * Displays a custom message box.
             * @param {string} title - The title of the message box.
             * @param {string} message - The content message.
             * @param {string} type - 'info' (default) or 'confirm'.
             * @param {function} [confirmCallback] - Callback function for 'confirm' type when confirmed.
             */
            function showMessageBox(title, message, type = 'info', confirmCallback = null) {
                messageBoxTitle.textContent = title;
                messageBoxContent.textContent = message;

                // Reset buttons visibility
                messageBoxCloseBtn.classList.add('hidden');
                messageBoxConfirmBtn.classList.add('hidden');
                messageBoxCancelBtn.classList.add('hidden');

                if (type === 'confirm') {
                    messageBoxConfirmBtn.classList.remove('hidden');
                    messageBoxCancelBtn.classList.remove('hidden');
                    messageBoxConfirmBtn.onclick = () => {
                        messageBox.classList.add('hidden');
                        if (confirmCallback) {
                            confirmCallback();
                        }
                    };
                    messageBoxCancelBtn.onclick = () => {
                        messageBox.classList.add('hidden');
                    };
                } else { // 'info' type
                    messageBoxCloseBtn.classList.remove('hidden');
                    messageBoxCloseBtn.onclick = () => {
                        messageBox.classList.add('hidden');
                    };
                }
                messageBox.classList.remove('hidden');
            }

            /**
             * Populates the target OT pay dropdown with predefined values.
             */
            function populateTargetOTPayDropdown() {
                // Clear existing options except "No Target" and "Other"
                targetOTPaySelect.innerHTML = '<option value="">No Target</option>';
                PREDEFINED_TARGET_PAYS.forEach(amount => {
                    const option = document.createElement('option');
                    option.value = amount.toFixed(2);
                    option.textContent = `RM ${amount.toFixed(2)}`;
                    targetOTPaySelect.appendChild(option);
                });
                const otherOption = document.createElement('option');
                otherOption.value = 'custom';
                otherOption.textContent = 'Other (Enter Manually)';
                targetOTPaySelect.appendChild(otherOption);
            }

            /**
             * Handles the change event for the target OT pay dropdown.
             * Shows/hides the custom input field.
             */
            function handleTargetOTPayChange() {
                if (targetOTPaySelect.value === 'custom') {
                    customTargetOTPayInput.classList.remove('hidden');
                    customTargetOTPayInput.focus();
                } else {
                    customTargetOTPayInput.classList.add('hidden');
                    customTargetOTPayInput.value = ''; // Clear custom input when not in use
                }
                calculateAndDisplayResults(); // Recalculate on target change
            }

            /**
             * Retrieves the current target OT pay value, handling both dropdown and custom input.
             * @returns {number | null} The target OT pay as a number, or null if no target is set.
             */
            function getTargetOTPayValue() {
                if (targetOTPaySelect.value === 'custom') {
                    const customValue = parseFloat(customTargetOTPayInput.value);
                    return isNaN(customValue) ? null : customValue;
                } else if (targetOTPaySelect.value === '') {
                    return null;
                } else {
                    return parseFloat(targetOTPaySelect.value);
                }
            }

            /**
             * Calculates the basic hourly rate.
             * @param {number} monthlySalary - The employee's basic monthly salary.
             * @returns {number} The calculated basic hourly rate.
             */
            function calculateHourlyRate(monthlySalary) {
                if (monthlySalary <= 0) return 0;
                return monthlySalary / CONFIG.WORKING_DAYS_MONTHLY / CONFIG.STANDARD_WORK_HOURS_DAILY;
            }

            /**
             * Calculates the OT pay for a given entry.
             * @param {number} hourlyRate - The basic hourly rate.
             * @param {number} hours - The number of OT hours.
             * @param {string} type - The type of OT (e.g., 'Normal OT (Weekdays)').
             * @param {string} date - The date of the OT entry (YYYY-MM-DD).
             * @returns {number} The calculated OT pay.
             */
            function calculateOT(hourlyRate, hours, type, date) {
                let multiplier = CONFIG.OT_MULTIPLIERS[type];

                // Override multiplier if it's a public holiday and the type is not already Public Holiday
                if (isPublicHoliday(date) && type !== 'Public Holiday') {
                    multiplier = CONFIG.OT_MULTIPLIERS['Public Holiday'];
                }
                
                if (multiplier === undefined) {
                    console.warn(`Unknown OT type or multiplier for type: ${type}`);
                    return 0; // Return 0 if multiplier is not found
                }

                return hourlyRate * multiplier * hours;
            }

            /**
             * Formats a number to RM currency string.
             * @param {number} amount - The amount to format.
             * @returns {string} Formatted currency string (e.g., "RM 123.45").
             */
            function formatCurrency(amount) {
                return `RM ${amount.toFixed(2)}`;
            }

            /**
             * Gets the current date in YYYY-MM-DD format.
             * @returns {string} The current date string.
             */
            function getTodayDateString() {
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            /**
             * Generates a random time (HH:MM) within a given hour range, at 15-minute intervals.
             * @param {number} minHour - The minimum hour (inclusive).
             * @param {number} maxHour - The maximum hour (exclusive).
             * @returns {string} The random time in "HH:MM" format.
             */
            function getRandomTime(minHour, maxHour) {
                const hours = Math.floor(Math.random() * (maxHour - minHour)) + minHour;
                const minutesOptions = [0, 15, 30, 45];
                const minutes = minutesOptions[Math.floor(Math.random() * minutesOptions.length)];
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }

            /**
             * Adds hours to a given time string (HH:MM) and returns a new time string.
             * Handles crossing midnight (though for OT, typically hours reset per day).
             * @param {string} startTimeStr - The start time in "HH:MM" format.
             * @param {number} hoursToAdd - The hours to add (can be decimal like 3.5).
             * @returns {string} The new time in "HH:MM" format.
             */
            function addHoursToTime(startTimeStr, hoursToAdd) {
                if (!startTimeStr) return ''; // Handle cases where start time is not set
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                let totalMinutes = startHour * 60 + startMinute + (hoursToAdd * 60);

                let newHour = Math.floor(totalMinutes / 60) % 24; // % 24 to handle midnight crossing
                let newMinute = Math.round(totalMinutes % 60);

                // Handle cases like 59.9 minutes becoming 60, or 60.1 minutes becoming 60.
                if (newMinute === 60) {
                    newMinute = 0;
                    newHour = (newHour + 1) % 24;
                }

                return `${String(newHour).padStart(2, '0')}:${String(newMinute).padStart(2, '0')}`;
            }

            /**
             * Calculates and updates the suggested start and end times for a given OT entry.
             * This function modifies the entry object directly.
             * @param {Object} entry - The OT entry object to update.
             * @param {string} [prevEndTimeForDay] - Optional: The end time of a previous OT entry on the same day, for chaining.
             */
            function calculateSuggestedTimes(entry, prevEndTimeForDay = null) {
                let suggestedStartTime = '';

                if (entry.type === 'Normal OT (Weekdays)') {
                    // Start anytime after 6 PM (18:00)
                    suggestedStartTime = getRandomTime(18, 20); // Random between 6 PM and 7:45 PM
                } else if (entry.type === 'Off Day (Saturday)' || entry.type === 'Public Holiday' || entry.type === 'Rest Day (Sunday) — 1st 8h') {
                    // Start anytime after 9 AM (09:00)
                    suggestedStartTime = getRandomTime(9, 11); // Random between 9 AM and 10:45 AM
                } else if (entry.type === 'Rest Day (Sunday) — after 8h') {
                    // If there's a preceding entry for the same day, use its end time
                    if (prevEndTimeForDay) {
                        suggestedStartTime = prevEndTimeForDay;
                    } else {
                        // Otherwise, start anytime after 5 PM (17:00)
                        suggestedStartTime = getRandomTime(17, 19); // Random between 5 PM and 6:45 PM
                    }
                }

                entry.startTime = suggestedStartTime;
                entry.endTime = addHoursToTime(entry.startTime, entry.hours);
            }


            /**
             * Clears all existing OT entry rows from the UI and the internal state.
             * This is a helper function used by `clearDailyOTEntries` and `autoAllocateHours`.
             */
            function clearOTEntries() {
                otEntries = [];
                otEntriesContainer.innerHTML = '';
                entryCounter = 0; // Reset counter when clearing
            }

            /**
             * Helper to determine the default OT type based on date (day of week).
             * This is used for grouping purposes in the UI.
             * @param {string} dateString - The date string (YYYY-MM-DD).
             * @returns {string} The default OT type for that date.
             */
            function getDefaultOTTypeForDate(dateString) {
                const date = new Date(dateString);
                const dayOfWeek = date.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                if (dayOfWeek === 0) { // Sunday
                    return 'Rest Day (Sunday) — 1st 8h'; // Default to 1st 8h for grouping Sundays
                } else if (dayOfWeek === 6) { // Saturday
                    return 'Off Day (Saturday)';
                } else { // Weekday (Monday to Friday)
                    return 'Normal OT (Weekdays)';
                }
            }

            /**
             * Renders the OT entries from the `otEntries` array to the UI, grouped by OT type.
             * This function is responsible for updating the display, not modifying the `otEntries` array itself.
             */
            function renderOTEntries() {
                otEntriesContainer.innerHTML = ''; // Clear current UI

                // Augment entries with a displayType for grouping
                const entriesWithDisplayType = otEntries.map(entry => {
                    let resolvedDisplayType;
                    if (isPublicHoliday(entry.date)) {
                        resolvedDisplayType = 'Public Holiday';
                    } else {
                        // If not a public holiday, group based on the actual day of the week
                        resolvedDisplayType = getDefaultOTTypeForDate(entry.date);
                    }
                    return { ...entry, displayType: resolvedDisplayType };
                });

                // Group entries by their resolved displayType
                const groupedEntries = entriesWithDisplayType.reduce((acc, entry) => {
                    if (!acc[entry.displayType]) {
                        acc[entry.displayType] = [];
                    }
                    acc[entry.displayType].push(entry);
                    return acc;
                }, {});

                // Define a preferred order for displaying OT types, ensuring Public Holiday is included
                const preferredOrder = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday' // Ensure Public Holiday is in the display order
                ];

                // Render each group
                preferredOrder.forEach(displayType => { // Iterate over displayType
                    if (groupedEntries[displayType] && groupedEntries[displayType].length > 0) {
                        const groupSection = document.createElement('div');
                        groupSection.classList.add('ot-group-section');

                        const groupTitle = document.createElement('h4');
                        groupTitle.textContent = displayType; // Use displayType for group title
                        groupSection.appendChild(groupTitle);

                        // Sort entries within each group by date
                        groupedEntries[displayType].sort((a, b) => new Date(a.date) - new Date(b.date));

                        groupedEntries[displayType].forEach(entry => {
                            const entryId = entry.id;
                            const newRow = document.createElement('div');
                            newRow.classList.add('ot-entry-row');
                            newRow.setAttribute('data-id', entryId);

                            // Add the 'highlight-new' class if isNew is true
                            if (entry.isNew) {
                                newRow.classList.add('highlight-new');
                                // Remove the highlight class after animation
                                setTimeout(() => {
                                    newRow.classList.remove('highlight-new');
                                }, 2000);
                            }

                            // The select dropdown still shows the original entry.type
                            // The (PH Rate Applied) indicator is added if applicable
                            newRow.innerHTML = `
                                <div class="input-group">
                                    <label for="${entryId}-date">Date${entry.isNew ? '<span class="new-badge">New</span>' : ''}</label>
                                    <input type="date" id="${entryId}-date" value="${entry.date}" class="shadow-sm">
                                </div>
                                <div class="input-group">
                                    <label for="${entryId}-hours">Hours</label>
                                    <input type="number" id="${entryId}-hours" value="${entry.hours.toFixed(1)}" min="0" step="0.5" class="shadow-sm">
                                    <div id="${entryId}-hours-error" class="error-message"></div>
                                </div>
                                <div class="input-group">
                                    <label for="${entryId}-type">OT Type</label>
                                    <select id="${entryId}-type" class="shadow-sm">
                                        ${Object.keys(DEFAULT_OT_MULTIPLIERS).map(otType => `
                                            <option value="${otType}" ${otType === entry.type ? 'selected' : ''}>${otType}</option>
                                        `).join('')}
                                    </select>
                                    ${isPublicHoliday(entry.date) ? '<span class="text-red-500 text-xs ml-1">(PH Rate Applied)</span>' : ''}
                                </div>
                                <div class="input-group">
                                    <label for="${entryId}-start-time">Start Time</label>
                                    <input type="time" id="${entryId}-start-time" value="${entry.startTime}" class="shadow-sm" readonly>
                                </div>
                                <div class="input-group">
                                    <label for="${entryId}-end-time">End Time</label>
                                    <input type="time" id="${entryId}-end-time" value="${entry.endTime}" class="shadow-sm" readonly>
                                </div>
                                <div class="remove-btn-container">
                                    <button type="button" class="btn btn-danger btn-sm remove-ot-entry-btn" data-id="${entryId}" aria-label="Remove OT entry for ${entry.date}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                            <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                                        </svg>
                                    </button>
                                </div>
                            `;
                            groupSection.appendChild(newRow);

                            // Re-attach event listeners to the newly created elements for granular updates
                            newRow.querySelector(`#${entryId}-date`).addEventListener('change', (e) => {
                                updateOTEntry(entryId, 'date', e.target.value);
                            });
                            const hoursInput = newRow.querySelector(`#${entryId}-hours`);
                            const hoursError = newRow.querySelector(`#${entryId}-hours-error`);
                            hoursInput.addEventListener('input', (e) => {
                                const value = parseFloat(e.target.value);
                                if (isNaN(value) || value < 0) {
                                    hoursInput.classList.add('input-error');
                                    hoursError.textContent = 'Hours must be a positive number.';
                                } else {
                                    hoursInput.classList.remove('input-error');
                                    hoursError.textContent = '';
                                    updateOTEntry(entryId, 'hours', value);
                                }
                            });
                            newRow.querySelector(`#${entryId}-type`).addEventListener('change', (e) => {
                                updateOTEntry(entryId, 'type', e.target.value);
                            });
                            newRow.querySelector(`.remove-ot-entry-btn`).addEventListener('click', () => removeOTEntryRow(entryId));
                        });
                        otEntriesContainer.appendChild(groupSection);
                    }
                });
            }


            /**
             * Adds a new OT entry to the `otEntries` array and then re-renders the UI.
             * This is for manual "Add OT Entry" button clicks.
             */
            function addNewManualOTEntry() {
                const newEntry = {
                    id: `ot-entry-${entryCounter++}`, // Generate a new unique ID
                    date: getTodayDateString(),
                    hours: 0,
                    type: 'Normal OT (Weekdays)',
                    startTime: '', // Will be calculated by calculateSuggestedTimes
                    endTime: '',    // Will be calculated by calculateSuggestedTimes
                    isNew: true     // Mark as new
                };
                // Calculate initial times for the new entry
                calculateSuggestedTimes(newEntry);
                otEntries.push(newEntry);
                renderOTEntries(); // Re-render the entire list
                calculateAndDisplayResults(); // Recalculate after adding an entry

                // Find the newly added row and scroll it into view with a highlight
                setTimeout(() => {
                    const newRowElement = otEntriesContainer.querySelector(`[data-id="${newEntry.id}"]`);
                    if (newRowElement) {
                        newRowElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // The highlight-new class is now added inside renderOTEntries
                    }
                }, 100); // Small delay to ensure DOM update
            }

            /**
             * Updates an OT entry in the otEntries array and its corresponding DOM elements.
             * @param {string} id - The ID of the entry to update.
             * @param {string} field - The field to update ('date', 'hours', 'type').
             * @param {*} value - The new value for the field.
             */
            function updateOTEntry(id, field, value) {
                const index = otEntries.findIndex(entry => entry.id === id);
                if (index !== -1) {
                    otEntries[index][field] = value;
                    // Do NOT set isNew flag here, it's only for newly added entries.

                    // Recalculate times for the updated entry
                    // Find any preceding entry on the same day to chain times
                    const entriesOnSameDay = otEntries.filter(e => e.date === otEntries[index].date).sort((a, b) => {
                        // Simple sort by ID for consistent order if times are not yet set
                        return parseInt(a.id.split('-')[2]) - parseInt(b.id.split('-')[2]);
                    });

                    let prevEndTimeForDay = null;
                    for (let i = 0; i < entriesOnSameDay.length; i++) {
                        if (entriesOnSameDay[i].id === id) {
                            calculateSuggestedTimes(otEntries[index], prevEndTimeForDay);
                            break;
                        }
                        prevEndTimeForDay = entriesOnSameDay[i].endTime;
                    }

                    // Always re-render the entire list if date or type changed, as this affects grouping
                    // This is the key change to ensure correct auto-grouping on date change.
                    renderOTEntries();
                    
                    calculateAndDisplayResults(); // Recalculate after any entry update
                }
            }


            /**
             * Removes an OT entry from the otEntries array and then re-renders the UI.
             * @param {string} id - The ID of the entry to remove.
             */
            function removeOTEntryRow(id) {
                showMessageBox(
                    'Confirm Removal',
                    'Are you sure you want to remove this OT entry? This action cannot be undone.',
                    'confirm',
                    () => {
                        otEntries = otEntries.filter(entry => entry.id !== id);
                        renderOTEntries(); // Re-render the entire list after removal
                        calculateAndDisplayResults(); // Recalculate after removing an entry
                        showMessageBox('Entry Removed', 'The OT entry has been removed.');
                    }
                );
            }

            /**
             * Function to clear all daily OT entries and reset the results section.
             */
            function clearDailyOTEntries() {
                showMessageBox(
                    'Confirm Clear All',
                    'Are you sure you want to clear all daily OT entries? This action cannot be undone.',
                    'confirm',
                    () => {
                        clearOTEntries(); // Use the helper function to clear all rows and state
                        addNewManualOTEntry(); // Add back one empty row for convenience
                        // resultsSection.classList.add('hidden'); // No longer hide, it's always visible
                        showMessageBox('Entries Cleared', 'All daily OT entries have been cleared.');
                        calculateAndDisplayResults(); // Recalculate after clearing entries
                    }
                );
            }

            /**
             * Main function to calculate and display OT results.
             */
            function calculateAndDisplayResults() {
                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = getTargetOTPayValue(); // Get value using new helper
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;

                // Basic validation for calculation only (not preventing user input)
                if (isNaN(basicSalary) || basicSalary <= 0) {
                    // We can still display partial results or zeros if salary is invalid
                    // showMessageBox('Input Error', 'Please enter a valid Basic Monthly Salary.');
                    // return;
                }
                if (!startDate || !endDate) {
                    // showMessageBox('Input Error', 'Please select both Start and End Dates for the planning range.');
                    // return;
                }
                if (new Date(startDate) > new Date(endDate)) {
                    // showMessageBox('Input Error', 'Start Date cannot be after End Date.');
                    // return;
                }
                // If otEntries is empty, calculation will naturally result in zeros.

                const hourlyRate = calculateHourlyRate(basicSalary);

                let totalHoursByType = {};
                let totalPayByCategory = {};
                let combinedOTPay = 0;
                let totalMonthlyOTHours = 0; // Track total monthly OT hours

                // Initialize categories including Public Holiday
                for (const type in CONFIG.OT_MULTIPLIERS) {
                    totalHoursByType[type] = 0;
                    totalPayByCategory[type] = 0;
                }
                // Ensure 'Public Holiday' is always initialized, even if not in DEFAULT_OT_MULTIPLIERS keys
                if (!totalHoursByType['Public Holiday']) {
                    totalHoursByType['Public Holiday'] = 0;
                    totalPayByCategory['Public Holiday'] = 0;
                }


                otEntries.forEach(entry => {
                    const hours = parseFloat(entry.hours);
                    const type = entry.type;
                    const date = entry.date;

                    if (isNaN(hours) || hours <= 0) {
                        return;
                    }

                    // Determine the category for summing hours and pay
                    const categoryForSumming = isPublicHoliday(date) ? 'Public Holiday' : type;

                    // Get multiplier, considering public holidays
                    const multiplier = isPublicHoliday(date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : CONFIG.OT_MULTIPLIERS[type];

                    if (multiplier === undefined) {
                        console.warn(`Unknown OT type or multiplier for type: ${type}`);
                        return;
                    }

                    const dailyOTPay = calculateOT(hourlyRate, hours, type, date);

                    totalHoursByType[categoryForSumming] += hours; // Sum based on resolved category
                    totalPayByCategory[categoryForSumming] += dailyOTPay; // Sum based on resolved category
                    combinedOTPay += dailyOTPay;
                    totalMonthlyOTHours += hours;
                });

                // Calculate Expected Salary Pay
                const expectedSalaryPay = basicSalary + combinedOTPay;

                // Monthly cap validation removed as per user request
                // if (totalMonthlyOTHours > CONFIG.MAX_MONTHLY_OT_HOURS) {
                //     showMessageBox('Monthly OT Limit Exceeded', `Total OT hours for the planning period (${totalMonthlyOTHours.toFixed(1)}h) exceed the monthly limit of ${CONFIG.MAX_MONTHLY_OT_HOURS} hours.`);
                // }


                // Display Results for totalHoursByType
                let hoursSummaryHtml = [];
                const displayOrderForSummary = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday'
                ];
                displayOrderForSummary.forEach(type => {
                    if (totalHoursByType[type] > 0) {
                        hoursSummaryHtml.push(`<span class="summary-inline-item">${type}: ${totalHoursByType[type].toFixed(1)}h</span>`);
                    }
                });
                totalHoursByTypeElem.innerHTML = hoursSummaryHtml.join('');


                // Display Results for totalPayByCategory
                let paySummaryHtml = [];
                displayOrderForSummary.forEach(type => { // Use the same order
                    if (totalPayByCategory[type] > 0) {
                        paySummaryHtml.push(`<span class="summary-inline-item">${type}: ${formatCurrency(totalPayByCategory[type])}</span>`);
                    }
                });
                totalPayByCategoryElem.innerHTML = paySummaryHtml.join('');


                combinedOTPayElem.textContent = formatCurrency(combinedOTPay);
                totalMonthlyOTHoursDisplay.textContent = `${totalMonthlyOTHours.toFixed(1)} hours`; // Display total monthly hours
                expectedSalaryPayDisplay.textContent = formatCurrency(expectedSalaryPay); // Display expected salary pay

                const isTargetOptional = targetOTPay === null || targetOTPay <= 0;

                if (isTargetOptional) {
                    targetOTPayDisplayElem.textContent = "N/A (No target set)";
                    targetOTPayDisplayElem.classList.remove('text-green-600');
                    targetOTPayDisplayElem.classList.add('text-gray-600');

                    differenceFromTargetElem.textContent = "N/A (No target set)";
                    differenceFromTargetElem.classList.remove('text-green-600', 'text-red-600');
                    differenceFromTargetElem.classList.add('text-gray-600');
                } else {
                    targetOTPayDisplayElem.textContent = formatCurrency(targetOTPay);
                    targetOTPayDisplayElem.classList.remove('text-gray-600');
                    targetOTPayDisplayElem.classList.add('text-green-600');

                    const difference = combinedOTPay - targetOTPay;
                    differenceFromTargetElem.textContent = formatCurrency(difference);
                    if (difference >= 0) {
                        differenceFromTargetElem.classList.remove('text-red-600', 'text-gray-600');
                        differenceFromTargetElem.classList.add('text-green-600');
                    } else {
                        differenceFromTargetElem.classList.remove('text-green-600', 'text-gray-600');
                        differenceFromTargetElem.classList.add('text-red-600');
                    }
                }

                // resultsSection.classList.remove('hidden'); // No longer hide, it's always visible
            }

            /**
             * Generates a random number within a given range, rounded to the nearest 0.5.
             * @param {number} min - The minimum value.
             * @param {number} max - The maximum value.
             * @returns {number} The random number.
             */
            function getRandomHours(min, max) {
                const random = Math.random() * (max - min) + min;
                return Math.round(random * 2) / 2; // Round to nearest 0.5
            }

            /**
             * Adds or updates an OT entry in the otEntries array.
             * If an entry for the given date and type already exists, its hours are updated.
             * Otherwise, a new entry is added.
             * @param {string} date - The date of the OT entry.
             * @param {number} hours - The hours to add/set for the OT entry.
             * @param {string} type - The type of OT.
             */
            function addOrUpdateOTEntry(date, hours, type) {
                const existingEntry = otEntries.find(entry => entry.date === date && entry.type === type);

                if (existingEntry) {
                    // Update existing entry's hours
                    existingEntry.hours += hours;
                } else {
                    // Add new entry
                    otEntries.push({
                        id: `ot-entry-${entryCounter++}`,
                        date: date,
                        hours: hours,
                        type: type,
                        startTime: '', // Will be calculated later
                        endTime: '',    // Will be calculated later
                        // Do NOT set isNew: true here, as per user request for auto-allocated entries
                    });
                }
            }

            /**
             * Initializes the list of available days within the planning range.
             * @param {string} startDateStr - The start date string (YYYY-MM-DD).
             * @param {string} endDateStr - The end date string (YYYY-MM-DD).
             * @returns {Array<Object>} An array of day objects { date: 'YYYY-MM-DD', dayOfWeek: number }.
             */
            function initializePlanningDays(startDateStr, endDateStr) {
                const days = [];
                let currentDate = new Date(startDateStr);
                const endDateTime = new Date(endDateStr).getTime();

                while (currentDate.getTime() <= endDateTime) {
                    days.push({
                        date: currentDate.toISOString().split('T')[0],
                        dayOfWeek: currentDate.getDay() // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                // Shuffle days to distribute OT more evenly across the period, rather than front-loading
                days.sort(() => Math.random() - 0.5);
                return days;
            }

            /**
             * Performs one pass of hour allocation based on predefined steps.
             * @param {Array<Object>} availableDays - List of days to allocate hours to.
             * @param {number} targetOTPay - The target OT pay.
             * @param {number} currentAllocatedPay - The current accumulated OT pay.
             * @param {number} hourlyRate - The employee's hourly rate.
             * @param {Array<Object>} allocationSteps - Array of preferred allocation rules.
             * @param {Object} hoursAllocatedPerDay - Map to track hours per day.
             * @param {Map<string, number>} sundayFirst8hAllocated - Map to track 0.5x hours allocated per Sunday.
             * @returns {number} The updated currentAllocatedPay.
             */
            function performAllocationPass(availableDays, targetOTPay, currentAllocatedPay, hourlyRate, allocationSteps, hoursAllocatedPerDay, sundayFirst8hAllocated) {
                for (const step of allocationSteps) {
                    if (currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) break;

                    const multiplier = CONFIG.OT_MULTIPLIERS[step.type];
                    if (!multiplier) continue;

                    const relevantDays = availableDays.filter(day => step.days.includes(day.dayOfWeek));

                    for (const day of relevantDays) {
                        if (currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) break;

                        const maxHoursForThisDay = CONFIG.MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date];
                        if (maxHoursForThisDay <= 0) continue;

                        let hoursToConsider = 0;
                        if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                            const current1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                            const remainingFor1st8h = 8 - current1st8h; // Max 8 hours for 1st 8h type
                            const suggestedHours = getRandomHours(step.minHours, step.maxHours);
                            hoursToConsider = Math.min(suggestedHours, maxHoursForThisDay, remainingFor1st8h);
                        } else if (step.hours !== undefined) {
                            hoursToConsider = Math.min(step.hours, maxHoursForThisDay);
                        } else {
                            const suggestedHours = getRandomHours(step.minHours, step.maxHours);
                            hoursToConsider = Math.min(suggestedHours, maxHoursForThisDay);
                        }

                        if (step.type === 'Rest Day (Sunday) — after 8h') {
                            const totalHoursOnSunday = hoursAllocatedPerDay[day.date];
                            if (totalHoursOnSunday < 8) {
                                // Only allocate 2.0x after 8 hours for the day have been reached
                                continue;
                            }
                        }

                        // Use the correct multiplier for public holidays during allocation
                        const currentMultiplier = isPublicHoliday(day.date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : multiplier;

                        const potentialPay = calculateOT(hourlyRate, hoursToConsider, step.type, day.date);

                        if (hoursToConsider > 0 && currentAllocatedPay + potentialPay <= targetOTPay + CONFIG.ALLOCATION_PRECISION) {
                            addOrUpdateOTEntry(day.date, hoursToConsider, step.type);
                            currentAllocatedPay += potentialPay;
                            hoursAllocatedPerDay[day.date] += hoursToConsider;
                            if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToConsider);
                            }
                        } else if (hoursToConsider > 0) { // If adding full hours exceeds target, try to add precisely
                            const remainingPayNeeded = targetOTPay - currentAllocatedPay;
                            const hoursToPreciselyAdd = remainingPayNeeded / (hourlyRate * currentMultiplier);
                            const finalHoursToAdd = Math.min(hoursToPreciselyAdd, hoursToConsider, maxHoursForThisDay);
                            if (finalHoursToAdd > 0) {
                                addOrUpdateOTEntry(day.date, finalHoursToAdd, step.type);
                                currentAllocatedPay = targetOTPay;
                                hoursAllocatedPerDay[day.date] += finalHoursToAdd;
                                if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                    sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + finalHoursToAdd);
                                }
                            }
                        }
                    }
                }
                return currentAllocatedPay;
            }

            /**
             * Fills any remaining gap in target pay using available OT types.
             * @param {Array<Object>} availableDays - List of days to allocate hours to.
             * @param {number} targetOTPay - The target OT pay.
             * @param {number} currentAllocatedPay - The current accumulated OT pay.
             * @param {number} hourlyRate - The employee's hourly rate.
             * @param {Object} hoursAllocatedPerDay - Map to track hours per day.
             * @param {Map<string, number>} sundayFirst8hAllocated - Map to track 0.5x hours allocated per Sunday.
             * @returns {number} The updated currentAllocatedPay.
             */
            function fillRemainingGap(availableDays, targetOTPay, currentAllocatedPay, hourlyRate, hoursAllocatedPerDay, sundayFirst8hAllocated) {
                const daysToFill = availableDays.slice().sort((a, b) => hoursAllocatedPerDay[a.date] - hoursAllocatedPerDay[b.date]);

                for (const day of daysToFill) {
                    if (currentAllocatedPay >= targetOTPay - CONFIG.ALLOCATION_PRECISION) break;

                    const maxHoursForThisDay = CONFIG.MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date];
                    if (maxHoursForThisDay <= 0) continue;

                    let hoursToConsider = 0;
                    let typeToUse = '';
                    let currentMultiplier = 0;

                    // Get preset details for the current workload
                    const presetDetails = CONFIG.WORKLOAD_PRESETS[workloadPresetSelect.value];

                    // Priority for Sunday: 1st 8h (0.5x) first, then after 8h (2.0x)
                    if (day.dayOfWeek === 0) { // It's a Sunday
                        const currentSunday1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                        const totalHoursOnSunday = hoursAllocatedPerDay[day.date];

                        if (currentSunday1st8h < 8) { // Still space for 1st 8h at 0.5x
                            typeToUse = 'Rest Day (Sunday) — 1st 8h';
                            currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                            const presetFor1st8h = presetDetails[typeToUse];
                            hoursToConsider = getRandomHours(presetFor1st8h.minHours, presetFor1st8h.maxHours);
                            hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay, 8 - currentSunday1st8h); // Cap at 8 hours for this type

                        } else if (totalHoursOnSunday < CONFIG.MAX_DAILY_OT_HOURS) { // After 1st 8h, consider after 8h
                            typeToUse = 'Rest Day (Sunday) — after 8h';
                            currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                            const presetForAfter8h = presetDetails[typeToUse];
                            hoursToConsider = getRandomHours(presetForAfter8h.minHours, presetForAfter8h.maxHours);
                            hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay);
                        }
                    } else if (day.dayOfWeek === 6) { // Saturday
                        typeToUse = 'Off Day (Saturday)';
                        currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                        const presetForOffDay = presetDetails[typeToUse];
                        hoursToConsider = getRandomHours(presetForOffDay.minHours, presetForOffDay.maxHours);
                        hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay);
                    } else if (day.dayOfWeek >= 1 && day.dayOfWeek <= 5) { // Weekday
                        typeToUse = 'Normal OT (Weekdays)';
                        currentMultiplier = CONFIG.OT_MULTIPLIERS[typeToUse];
                        const presetForNormalOT = presetDetails[typeToUse];
                        hoursToConsider = getRandomHours(presetForNormalOT.minHours, presetForNormalOT.maxHours);
                        hoursToConsider = Math.min(hoursToConsider, maxHoursForThisDay);
                    }

                    if (hoursToConsider > 0 && typeToUse && currentMultiplier > 0) { // Ensure typeToUse is not empty
                        // Use the correct multiplier for public holidays during allocation
                        const finalMultiplier = isPublicHoliday(day.date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : currentMultiplier;

                        const potentialPay = calculateOT(hourlyRate, hoursToConsider, typeToUse, day.date);
                        if (currentAllocatedPay + potentialPay <= targetOTPay + CONFIG.ALLOCATION_PRECISION) {
                            addOrUpdateOTEntry(day.date, hoursToConsider, typeToUse);
                            currentAllocatedPay += potentialPay;
                            hoursAllocatedPerDay[day.date] += hoursToConsider;
                            if (typeToUse === 'Rest Day (Sunday) — 1st 8h') {
                                sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToConsider);
                            }
                        } else {
                            const remainingPayNeeded = targetOTPay - currentAllocatedPay;
                            const hoursToPreciselyAdd = remainingPayNeeded / (hourlyRate * finalMultiplier);
                            const finalHoursToAdd = Math.min(hoursToPreciselyAdd, hoursToConsider);
                            if (finalHoursToAdd > 0) {
                                addOrUpdateOTEntry(day.date, finalHoursToAdd, typeToUse);
                                currentAllocatedPay = targetOTPay;
                                hoursAllocatedPerDay[day.date] += finalHoursToAdd;
                                if (typeToUse === 'Rest Day (Sunday) — 1st 8h') {
                                    sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + finalHoursToAdd);
                                }
                            }
                        }
                    }
                }
                return currentAllocatedPay;
            }

            /**
             * Calculates and assigns start/end times for all entries in otEntries, ensuring chaining for same-day entries.
             */
            function calculateAndAssignTimes() {
                // Sort entries by date and then by their original ID (to maintain creation order for same-day entries)
                otEntries.sort((a, b) => {
                    const dateComparison = new Date(a.date) - new Date(b.date);
                    if (dateComparison !== 0) {
                        return dateComparison;
                    }
                    // If dates are the same, sort by the numeric part of the ID to maintain original creation order
                    return parseInt(a.id.split('-')[2]) - parseInt(b.id.split('-')[2]);
                });

                const lastEndTimeOnDay = {}; // To track end time for chaining on the same day
                otEntries.forEach(entry => {
                    let prevEndTime = lastEndTimeOnDay[entry.date] || null;
                    calculateSuggestedTimes(entry, prevEndTime);
                    lastEndTimeOnDay[entry.date] = entry.endTime; // Update last end time for this day
                });
            }

            /**
             * Updates the display of workload preset details based on the selected preset.
             */
            function updateWorkloadPresetDetails() {
                const selectedPresetName = workloadPresetSelect.value;
                const presetDetails = CONFIG.WORKLOAD_PRESETS[selectedPresetName];
                let html = `<strong>${selectedPresetName} Details:</strong><ul class="list-disc list-inside ml-4">`;

                // Order for display
                const displayOrder = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h'
                ];

                displayOrder.forEach(type => {
                    const detail = presetDetails[type];
                    if (detail) {
                        // All workload preset details for OT types now use minHours/maxHours
                        html += `<li>${type}: ${detail.minHours.toFixed(1)} - ${detail.maxHours.toFixed(1)} hours</li>`;
                    }
                });
                html += `</ul>`;
                workloadPresetDetails.innerHTML = html;
            }

            /**
             * Adds a public holiday to the list.
             */
            function addPublicHoliday() {
                const date = publicHolidayDateInput.value;
                if (!date) {
                    showMessageBox('Input Error', 'Please select a date for the public holiday.');
                    return;
                }
                if (publicHolidays.includes(date)) {
                    showMessageBox('Duplicate Entry', `${date} is already in the public holidays list.`);
                    return;
                }
                publicHolidays.push(date);
                publicHolidays.sort(); // Keep sorted for consistency
                renderPublicHolidays();
                // After adding a public holiday, re-render all OT entries to update their grouping/PH indicator
                renderOTEntries();
                calculateAndDisplayResults(); // Recalculate after adding holiday
            }

            /**
             * Removes a public holiday from the list.
             * @param {string} dateToRemove - The date string to remove.
             */
            function removePublicHoliday(dateToRemove) {
                showMessageBox(
                    'Confirm Removal',
                    `Are you sure you want to remove ${dateToRemove} from public holidays?`,
                    'confirm',
                    () => {
                        publicHolidays = publicHolidays.filter(date => date !== dateToRemove);
                        renderPublicHolidays();
                        // After removing a public holiday, re-render all OT entries to update their grouping/PH indicator
                        renderOTEntries();
                        calculateAndDisplayResults(); // Recalculate after removing holiday
                        showMessageBox('Holiday Removed', `${dateToRemove} has been removed from public holidays.`);
                    }
                );
            }

            /**
             * Renders the list of public holidays.
             */
            function renderPublicHolidays() {
                publicHolidaysList.innerHTML = '';
                if (publicHolidays.length === 0) {
                    publicHolidaysList.innerHTML = '<li class="text-gray-500">No public holidays added yet.</li>';
                    return;
                }
                publicHolidays.forEach(date => {
                    const li = document.createElement('li');
                    li.classList.add('flex', 'justify-between', 'items-center', 'py-1');
                    li.innerHTML = `
                        <span>${date}</span>
                        <button type="button" class="text-red-500 hover:text-red-700 ml-4" data-date="${date}" aria-label="Remove public holiday ${date}">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    `;
                    publicHolidaysList.appendChild(li);
                    li.querySelector('button').addEventListener('click', (e) => {
                        removePublicHoliday(e.currentTarget.dataset.date);
                    });
                });
            }

            /**
             * Checks if a given date is a public holiday.
             * @param {string} date - The date string (YYYY-MM-DD) to check.
             * @returns {boolean} True if it's a public holiday, false otherwise.
             */
            function isPublicHoliday(date) {
                return publicHolidays.includes(date);
            }

            /**
             * Renders the OT multiplier input fields.
             */
            function renderOTMultiplierInputs() {
                otMultiplierInputsContainer.innerHTML = '';
                // Order for display
                const displayOrder = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday'
                ];

                displayOrder.forEach(type => {
                    const inputGroup = document.createElement('div');
                    inputGroup.classList.add('input-group');
                    inputGroup.innerHTML = `
                        <label for="multiplier-${type.replace(/[^a-zA-Z0-9]/g, '')}">${type} Multiplier</label>
                        <input type="number" id="multiplier-${type.replace(/[^a-zA-Z0-9]/g, '')}" value="${(CONFIG.OT_MULTIPLIERS[type] || 0).toFixed(2)}" min="0" step="0.1" class="shadow-sm">
                    `;
                    otMultiplierInputsContainer.appendChild(inputGroup);

                    // Add event listener to update CONFIG.OT_MULTIPLIERS on input change
                    inputGroup.querySelector('input').addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        if (!isNaN(value) && value >= 0) {
                            CONFIG.OT_MULTIPLIERS[type] = value;
                            calculateAndDisplayResults(); // Recalculate after multiplier change
                        }
                    });
                });
            }

            /**
             * Resets OT multipliers to their default values.
             */
            function resetMultipliersToDefault() {
                showMessageBox(
                    'Confirm Reset Multipliers',
                    'Are you sure you want to reset all OT multipliers to their default values?',
                    'confirm',
                    () => {
                        Object.assign(CONFIG.OT_MULTIPLIERS, DEFAULT_OT_MULTIPLIERS);
                        renderOTMultiplierInputs(); // Re-render to show default values
                        showMessageBox('Multipliers Reset', 'OT multipliers have been reset to their default values.');
                        calculateAndDisplayResults(); // Recalculate after resetting multipliers
                    }
                );
            }

            /**
             * Automatically allocates OT hours based on selected strategy.
             */
            async function autoAllocateHours() {
                autoAllocateLoading.classList.remove('hidden'); // Show loading indicator

                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = getTargetOTPayValue(); // Get value using new helper
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const selectedWorkloadPreset = workloadPresetSelect.value;
                const selectedAllocationStrategy = allocationStrategySelect.value;

                // Basic validation
                if (isNaN(basicSalary) || basicSalary <= 0) {
                    showMessageBox('Input Error', 'Please enter a valid Basic Monthly Salary for auto-allocation.');
                    autoAllocateLoading.classList.add('hidden');
                    return;
                }
                if (!startDate || !endDate) {
                    showMessageBox('Input Error', 'Please select both Start and End Dates for the planning range.');
                    autoAllocateLoading.classList.add('hidden');
                    return;
                }
                if (new Date(startDate) > new Date(endDate)) {
                    showMessageBox('Input Error', 'Start Date cannot be after End Date.');
                    autoAllocateLoading.classList.add('hidden');
                    return;
                }

                clearOTEntries(); // Clear existing entries before auto-allocating

                const hourlyRate = calculateHourlyRate(basicSalary);
                let currentAllocatedPay = 0;
                let currentAllocatedMonthlyHours = 0; // Track monthly hours during allocation

                const availableDays = initializePlanningDays(startDate, endDate);

                // Initialize a map to track hours allocated per day to enforce MAX_DAILY_OT_HOURS
                const hoursAllocatedPerDay = {};
                availableDays.forEach(day => { hoursAllocatedPerDay[day.date] = 0; });

                // Keep track of total 0.5x hours allocated per Sunday
                const sundayFirst8hAllocated = new Map();

                // Get the base allocation steps and apply preset overrides
                let currentAllocationSteps = JSON.parse(JSON.stringify(CONFIG.ALLOCATION_STEPS));
                currentAllocationSteps.forEach(step => {
                    const presetOverrides = CONFIG.WORKLOAD_PRESETS[selectedWorkloadPreset][step.type];
                    if (presetOverrides) {
                        step.minHours = presetOverrides.minHours;
                        step.maxHours = presetOverrides.maxHours;
                    }
                });

                const isTargetProvided = targetOTPay !== null && targetOTPay > 0;

                if (selectedAllocationStrategy === 'Target-Driven') {
                    if (!isTargetProvided) {
                        showMessageBox('Input Error', 'Please enter a valid Target OT Pay (> RM0) for Target-Driven allocation, or select "Workload-Driven" strategy.');
                        autoAllocateLoading.classList.add('hidden');
                        return;
                    }
                    // --- Target-based Allocation ---
                    currentAllocatedPay = performAllocationPass(availableDays, targetOTPay, currentAllocatedPay, hourlyRate, currentAllocationSteps, hoursAllocatedPerDay, sundayFirst8hAllocated);

                    // Phase 2: Fill remaining gap if target not met
                    if (currentAllocatedPay < targetOTPay - CONFIG.ALLOCATION_PRECISION) {
                        currentAllocatedPay = fillRemainingGap(availableDays, targetOTPay, currentAllocatedPay, hourlyRate, hoursAllocatedPerDay, sundayFirst8hAllocated);
                    }

                    // Monthly cap validation removed as per user request
                    // currentAllocatedMonthlyHours = otEntries.reduce((sum, entry) => sum + entry.hours, 0);
                    // if (currentAllocatedMonthlyHours > CONFIG.MAX_MONTHLY_OT_HOURS) {
                    //     showMessageBox('Monthly OT Limit Exceeded', `Auto-allocation resulted in ${currentAllocatedMonthlyHours.toFixed(1)} hours, exceeding the monthly limit of ${CONFIG.MAX_MONTHLY_OT_HOURS} hours. Please adjust manually.`);
                    // }

                    // Final Check: If target still not met, inform the user
                    if (currentAllocatedPay < targetOTPay - CONFIG.ALLOCATION_PRECISION) {
                        showMessageBox('Target Not Fully Met', `The target OT pay of ${formatCurrency(targetOTPay)} was not fully met (${formatCurrency(currentAllocatedPay)}). You may need to manually add more hours or increase the planning date range.`);
                    } else {
                        showMessageBox('Auto Allocation Complete', 'Overtime hours have been automatically allocated to reach your target pay, guided by the workload preset. Please review and adjust as needed.');
                    }
                } else if (selectedAllocationStrategy === 'Workload-Driven') {
                    // --- Workload-only Allocation (No Target) ---
                    availableDays.sort((a, b) => new Date(a.date) - new Date(b.date)); // Ensure sorted by date for consistent allocation

                    for (const day of availableDays) {
                        let maxHoursRemaining = CONFIG.MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date];
                        if (maxHoursRemaining <= 0) continue;

                        // Iterate through applicable steps for the current day
                        const applicableStepsForDay = currentAllocationSteps.filter(step => step.days.includes(day.dayOfWeek));

                        for (const step of applicableStepsForDay) {
                            if (maxHoursRemaining <= 0) break;

                            let hoursToAllocate = 0;
                            // Logic for Sunday 1st 8h and after 8h
                            if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                const current1st8h = sundayFirst8hAllocated.get(day.date) || 0;
                                const remainingFor1st8h = 8 - current1st8h;
                                hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                                hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining, remainingFor1st8h);
                            } else if (step.type === 'Rest Day (Sunday) — after 8h') {
                                const totalHoursOnSunday = hoursAllocatedPerDay[day.date];
                                if (totalHoursOnSunday < 8) {
                                    continue; // Skip 2.0x if 0.5x hasn't been fully allocated yet
                                }
                                hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                                hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                            } else if (step.hours !== undefined) { // Fixed hours (e.g., if we had any other fixed hours type)
                                hoursToAllocate = Math.min(step.hours - hoursAllocatedPerDay[day.date], maxHoursRemaining);
                            } else { // Range-based hours for other types
                                hoursToAllocate = getRandomHours(step.minHours, step.maxHours);
                                hoursToAllocate = Math.min(hoursToAllocate, maxHoursRemaining);
                            }

                            if (hoursToAllocate > 0) {
                                addOrUpdateOTEntry(day.date, hoursToAllocate, step.type);
                                hoursAllocatedPerDay[day.date] += hoursToAllocate;
                                if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                    sundayFirst8hAllocated.set(day.date, (sundayFirst8hAllocated.get(day.date) || 0) + hoursToAllocate);
                                }
                                maxHoursRemaining = CONFIG.MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date]; // Update remaining hours
                            }
                        }
                    }
                    // Monthly cap validation removed as per user request
                    // currentAllocatedMonthlyHours = otEntries.reduce((sum, entry) => sum + entry.hours, 0);
                    // if (currentAllocatedMonthlyHours > CONFIG.MAX_MONTHLY_OT_HOURS) {
                    //     showMessageBox('Monthly OT Limit Exceeded', `Auto-allocation resulted in ${currentAllocatedMonthlyHours.toFixed(1)} hours, exceeding the monthly limit of ${CONFIG.MAX_MONTHLY_OT_HOURS} hours. Please adjust manually.`);
                    // }
                    showMessageBox('Workload Allocated', 'Overtime hours have been allocated based on the selected workload preset for all days in the range.');
                }

                // Phase 3: Calculate and assign final start/end times for all entries
                calculateAndAssignTimes();

                // Clear all 'isNew' flags after auto-allocation
                otEntries.forEach(entry => {
                    delete entry.isNew;
                });

                renderOTEntries(); // Re-render the UI based on the sorted and time-calculated otEntries array
                calculateAndDisplayResults(); // Update results after auto-allocation
                autoAllocateLoading.classList.add('hidden'); // Hide loading indicator

                // Scroll to the results section
                // resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' }); // No longer needed with sticky
            }


            /**
             * Exports the summary to a text file.
             */
            function exportSummary() {
                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = getTargetOTPayValue(); // Get value using new helper
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const hourlyRate = calculateHourlyRate(basicSalary);

                let summaryText = `--- OT Calculation Summary ---\n\n`;
                summaryText += `Employee Settings:\n`;
                summaryText += `  Basic Monthly Salary: ${formatCurrency(basicSalary)}\n`;
                summaryText += `  Hourly Rate: RM ${hourlyRate.toFixed(2)}/hour\n\n`;

                summaryText += `OT Planning Period: ${startDate} to ${endDate}\n`;
                summaryText += `Target OT Pay: ${targetOTPay === null ? 'N/A' : formatCurrency(targetOTPay)}\n\n`;

                summaryText += `OT Multipliers Used:\n`;
                for (const type in CONFIG.OT_MULTIPLIERS) {
                    summaryText += `  ${type}: ${CONFIG.OT_MULTIPLIERS[type].toFixed(2)}x\n`;
                }
                summaryText += `\n`;

                summaryText += `Daily OT Entries:\n`;
                if (otEntries.length === 0) {
                    summaryText += `  No entries recorded.\n`;
                } else {
                    // Entries are already sorted by date in otEntries array after auto-allocation/manual updates
                    otEntries.forEach(entry => {
                        summaryText += `  Date: ${entry.date}, Hours: ${entry.hours.toFixed(1)}h, Type: ${entry.type}`;
                        if (isPublicHoliday(entry.date)) {
                            summaryText += ` (Public Holiday)`;
                        }
                        summaryText += `\n`;
                        if (entry.startTime && entry.endTime) {
                            summaryText += `  Suggested Time: ${entry.startTime} - ${entry.endTime}\n`;
                        }
                    });
                }
                summaryText += `\n`;

                // Recalculate for export to ensure consistency
                let totalHoursByType = {};
                let totalPayByCategory = {};
                let combinedOTPay = 0;
                let totalMonthlyOTHours = 0;

                // Initialize categories including Public Holiday
                for (const type in CONFIG.OT_MULTIPLIERS) {
                    totalHoursByType[type] = 0;
                    totalPayByCategory[type] = 0;
                }
                if (!totalHoursByType['Public Holiday']) {
                    totalHoursByType['Public Holiday'] = 0;
                    totalPayByCategory['Public Holiday'] = 0;
                }

                otEntries.forEach(entry => {
                    const hours = parseFloat(entry.hours);
                    const type = entry.type;
                    const date = entry.date;
                    if (isNaN(hours) || hours <= 0) return;

                    // Determine the category for summing hours and pay in the summary
                    const categoryForSumming = isPublicHoliday(date) ? 'Public Holiday' : type;

                    const multiplier = isPublicHoliday(date) ? CONFIG.OT_MULTIPLIERS['Public Holiday'] : CONFIG.OT_MULTIPLIERS[type];
                    if (multiplier === undefined) return;

                    const dailyOTPay = calculateOT(hourlyRate, hours, type, date);

                    totalHoursByType[categoryForSumming] += hours;
                    totalPayByCategory[categoryForSumming] += dailyOTPay;
                    combinedOTPay += dailyOTPay;
                    totalMonthlyOTHours += hours;
                });

                const expectedSalaryPay = basicSalary + combinedOTPay; // Calculate for export

                summaryText += `Total OT Hours by Type:\n`;
                let hoursSummaryExport = [];
                const displayOrderForSummaryExport = [
                    'Normal OT (Weekdays)',
                    'Off Day (Saturday)',
                    'Rest Day (Sunday) — 1st 8h',
                    'Rest Day (Sunday) — after 8h',
                    'Public Holiday'
                ];
                displayOrderForSummaryExport.forEach(type => {
                    if (totalHoursByType[type] > 0) {
                        hoursSummaryExport.push(`${type}: ${totalHoursByType[type].toFixed(1)}h`);
                    }
                });
                summaryText += `  ${hoursSummaryExport.join(', ')}\n`;
                summaryText += `\n`;

                summaryText += `Total Pay per OT Category:\n`;
                let paySummaryExport = [];
                displayOrderForSummaryExport.forEach(type => {
                    if (totalPayByCategory[type] > 0) {
                        totalPayByCategory[type] = parseFloat(totalPayByCategory[type].toFixed(2)); // Round to 2 decimal places for display
                        paySummaryExport.push(`${type}: ${formatCurrency(totalPayByCategory[type])}`);
                    }
                });
                summaryText += `  ${paySummaryExport.join(', ')}\n`;
                summaryText += `\n`;

                summaryText += `Combined OT Pay: ${formatCurrency(combinedOTPay)}\n`;
                const difference = combinedOTPay - (targetOTPay === null ? 0 : targetOTPay);
                summaryText += `Difference from Target: ${targetOTPay === null ? 'N/A (No target set)' : formatCurrency(difference)}\n`;
                summaryText += `Total Monthly OT Hours: ${totalMonthlyOTHours.toFixed(1)} hours (Max: ${CONFIG.MAX_MONTHLY_OT_HOURS} hours)\n`;
                summaryText += `Expected Salary Pay: ${formatCurrency(expectedSalaryPay)}\n`; // Add to export
                summaryText += `\n--- End of Summary ---`;

                const blob = new Blob([summaryText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ot_summary.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            /**
             * Saves the current application data to Firestore.
             */
            async function saveOTEntries() {
                if (!isAuthReady || !userId) {
                    showMessageBox('Save Error', 'Authentication not ready. Please try again in a moment.');
                    return;
                }

                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');

                    // Before saving, clear the 'isNew' flag for all entries
                    const cleanedOtEntries = otEntries.map(entry => {
                        const newEntry = { ...entry };
                        delete newEntry.isNew; // Remove the isNew flag
                        return newEntry;
                    });

                    const dataToSave = {
                        basicSalary: parseFloat(basicSalaryInput.value),
                        targetOTPay: getTargetOTPayValue(), // Save value using new helper
                        startDate: startDateInput.value,
                        endDate: endDateInput.value,
                        workloadPreset: workloadPresetSelect.value, // Save the selected preset
                        allocationStrategy: allocationStrategySelect.value, // Save the selected strategy
                        otEntries: JSON.stringify(cleanedOtEntries), // Stringify cleaned array
                        publicHolidays: JSON.stringify(publicHolidays), // Save public holidays
                        customMultipliers: JSON.stringify(CONFIG.OT_MULTIPLIERS) // Save custom multipliers
                    };

                    await setDoc(docRef, dataToSave);
                    // Update the local state to reflect that 'isNew' flags are cleared
                    otEntries = cleanedOtEntries;
                    renderOTEntries(); // Re-render to remove "New" badges
                    showMessageBox('Save Successful', 'Your OT data has been saved!');
                } catch (e) {
                    console.error("Error saving document: ", e);
                    showMessageBox('Save Error', 'Failed to save data. Please try again.');
                }
            }

            /**
             * Loads the application data from Firestore.
             */
            async function loadOTEntries() {
                if (!isAuthReady || !userId) {
                    console.warn("Authentication not ready for loading data.");
                    return;
                }

                try {
                    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                    const docRef = doc(db, `artifacts/${appId}/users/${userId}/ot_calculator_data`, 'user_data');
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists()) {
                        const loadedData = docSnap.data();
                        basicSalaryInput.value = loadedData.basicSalary;
                        
                        // Set targetOTPaySelect and customTargetOTPayInput values
                        const loadedTargetOTPay = loadedData.targetOTPay;
                        if (loadedTargetOTPay === null) {
                            targetOTPaySelect.value = ''; // "No Target"
                            customTargetOTPayInput.classList.add('hidden');
                            customTargetOTPayInput.value = '';
                        } else if (PREDEFINED_TARGET_PAYS.includes(loadedTargetOTPay)) {
                            targetOTPaySelect.value = loadedTargetOTPay.toFixed(2);
                            customTargetOTPayInput.classList.add('hidden');
                            customTargetOTPayInput.value = '';
                        } else {
                            targetOTPaySelect.value = 'custom'; // "Other (Enter Manually)"
                            customTargetOTPayInput.classList.remove('hidden');
                            customTargetOTPayInput.value = loadedTargetOTPay.toFixed(2);
                        }
                        
                        startDateInput.value = loadedData.startDate;
                        endDateInput.value = loadedData.endDate;
                        workloadPresetSelect.value = loadedData.workloadPreset || 'Moderate Workload'; // Load preset, default if not found
                        allocationStrategySelect.value = loadedData.allocationStrategy || 'Target-Driven'; // Load strategy, default if not found
                        otEntries = JSON.parse(loadedData.otEntries || '[]'); // Parse stringified array
                        publicHolidays = JSON.parse(loadedData.publicHolidays || '[]'); // Load public holidays
                        // Load custom multipliers, falling back to defaults if not present
                        Object.assign(CONFIG.OT_MULTIPLIERS, JSON.parse(loadedData.customMultipliers || '{}'));
                        // Ensure all default multipliers are present if not in loaded data
                        Object.assign(CONFIG.OT_MULTIPLIERS, { ...DEFAULT_OT_MULTIPLIERS, ...CONFIG.OT_MULTIPLIERS });


                        // Reset entryCounter to avoid ID conflicts if new entries are added later
                        entryCounter = otEntries.length > 0 ? Math.max(...otEntries.map(e => parseInt(e.id.split('-')[2]))) + 1 : 0;

                        calculateAndAssignTimes(); // Recalculate times for loaded entries
                        renderOTEntries(); // Render loaded entries
                        renderPublicHolidays(); // Render public holidays
                        renderOTMultiplierInputs(); // Render multiplier inputs with loaded values
                        calculateAndDisplayResults(); // Update results based on loaded data
                        showMessageBox('Load Successful', 'Your OT data has been loaded!');
                    } else {
                        console.log("No saved data found for this user.");
                        // If no data, initialize with default values for current month
                        const today = new Date();
                        const firstDayOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
                        const lastDayOfMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0);

                        startDateInput.value = firstDayOfMonth.toISOString().split('T')[0];
                        endDateInput.value = lastDayOfMonth.toISOString().split('T')[0];
                        workloadPresetSelect.value = 'Moderate Workload'; // Default preset
                        allocationStrategySelect.value = 'Target-Driven'; // Default strategy
                        targetOTPaySelect.value = ''; // Default to "No Target"
                        customTargetOTPayInput.classList.add('hidden'); // Ensure custom input is hidden
                        addNewManualOTEntry(); // Add one default entry
                        renderPublicHolidays(); // Render empty public holidays list
                        renderOTMultiplierInputs(); // Render default multipliers
                    }
                } catch (e) {
                    console.error("Error loading document: ", e);
                    showMessageBox('Load Error', 'Failed to load data. Please try again.');
                } finally {
                    // Ensure workload preset details are updated even if loading fails or no data is found
                    updateWorkloadPresetDetails();
                }
            }


            // --- Event Listeners ---
            basicSalaryInput.addEventListener('input', calculateAndDisplayResults); // Live update for basic salary
            customTargetOTPayInput.addEventListener('input', calculateAndDisplayResults); // Live update for custom target pay
            startDateInput.addEventListener('change', calculateAndDisplayResults); // Live update for start date
            endDateInput.addEventListener('change', calculateAndDisplayResults); // Live update for end date

            addOTEntryBtn.addEventListener('click', () => addNewManualOTEntry());
            autoAllocateBtn.addEventListener('click', autoAllocateHours);
            clearAllEntriesBtn.addEventListener('click', clearDailyOTEntries);
            calculateBtn.addEventListener('click', autoAllocateHours); // Changed to call autoAllocateHours
            exportSummaryBtn.addEventListener('click', exportSummary);
            saveDataBtn.addEventListener('click', saveOTEntries);
            loadDataBtn.addEventListener('click', loadOTEntries); 
            workloadPresetSelect.addEventListener('change', updateWorkloadPresetDetails); // Update details on change
            addPublicHolidayBtn.addEventListener('click', addPublicHoliday); // Add event listener for public holiday button
            resetMultipliersBtn.addEventListener('click', resetMultipliersToDefault); // Add event listener for reset multipliers
            targetOTPaySelect.addEventListener('change', handleTargetOTPayChange); // Re-added as custom input is back

            // "Today" button listeners
            setStartDateTodayBtn.addEventListener('click', () => {
                startDateInput.value = getTodayDateString();
                calculateAndDisplayResults();
            });
            setEndDateTodayBtn.addEventListener('click', () => {
                endDateInput.value = getTodayDateString();
                calculateAndDisplayResults();
            });
            setPublicHolidayTodayBtn.addEventListener('click', () => {
                publicHolidayDateInput.value = getTodayDateString();
            });

            // Collapsible section listeners
            collapsibleHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const targetId = header.dataset.target;
                    const targetContent = document.getElementById(targetId);
                    const icon = header.querySelector('.collapsible-icon');

                    if (targetContent.classList.contains('collapsed')) {
                        targetContent.classList.remove('collapsed');
                        targetContent.style.maxHeight = targetContent.scrollHeight + "px"; // Set max-height to scrollHeight
                        icon.classList.add('rotated');
                    } else {
                        targetContent.style.maxHeight = null; // Reset max-height to allow transition
                        targetContent.classList.add('collapsed');
                        icon.classList.remove('rotated');
                    }
                });
            });

            // Initial Setup
            populateTargetOTPayDropdown(); // Populate dropdown on load
            renderOTMultiplierInputs(); // Render default multipliers immediately
            // Data will be loaded via onAuthStateChanged, which will then call other render/update functions.
            // The `updateWorkloadPresetDetails()` is called in `loadOTEntries`'s finally block
            // to ensure it's always called after loading, or if loading fails.

            // Initialize collapsible sections to be collapsed by default
            document.getElementById('publicHolidaysContent').classList.add('collapsed');
            document.getElementById('otMultiplierContent').classList.add('collapsed');
        });
    </script>
</body>
</html>
