<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OT Calculator</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for Inter font and general body */
        body {
            font-family: "Inter", sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top to allow scrolling */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        .input-group label {
            font-weight: 600;
            color: #374151; /* Darker gray for labels */
            margin-bottom: 8px;
            display: block;
        }
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px;
            border: 1px solid #d1d5db; /* Light gray border */
            border-radius: 8px;
            font-size: 1rem;
            color: #4b5563; /* Medium gray for input text */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus border */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Light indigo shadow */
        }
        .btn {
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .btn-primary {
            background-color: #6366f1; /* Indigo */
            color: #ffffff;
        }
        .btn-primary:hover {
            background-color: #4f46e5; /* Darker indigo */
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #e0e7ff; /* Light indigo */
            color: #4f46e5; /* Darker indigo text */
        }
        .btn-secondary:hover {
            background-color: #c7d2fe; /* Even lighter indigo */
            transform: translateY(-1px);
        }
        .btn-danger {
            background-color: #ef4444; /* Red */
            color: #ffffff;
        }
        .btn-danger:hover {
            background-color: #dc2626; /* Darker red */
            transform: translateY(-1px);
        }
        .results-section {
            background-color: #f9fafb; /* Very light gray */
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #e5e7eb; /* Subtle border */
        }
        .results-section h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937; /* Darkest gray */
            margin-bottom: 15px;
        }
        .results-section p {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #374151;
        }
        .results-section p strong {
            color: #111827; /* Even darker for emphasis */
        }
        .ot-entry-row {
            display: grid;
            grid-template-columns: 1fr 0.5fr 1fr 1fr 1fr 0.1fr; /* Date, Hours, Type, Start Time, End Time, Remove Button */
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f9fafb;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }
        .ot-entry-row .input-group {
            margin-bottom: 0; /* Override default margin for compact rows */
        }
        .ot-entry-row .input-group label {
            font-size: 0.85rem; /* Smaller labels for row items */
            margin-bottom: 4px;
        }
        .ot-entry-row input, .ot-entry-row select {
            padding: 8px;
            font-size: 0.9rem;
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #fff;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
            min-width: 300px;
            max-width: 90%;
            border: 1px solid #d1d5db;
        }
        .message-box h4 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1f2937;
            margin-bottom: 15px;
        }
        .message-box p {
            font-size: 1.1rem;
            color: #4b5563;
            margin-bottom: 25px;
        }
        .message-box button {
            background-color: #6366f1;
            color: #ffffff;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out;
        }
        .message-box button:hover {
            background-color: #4f46e5;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            .ot-entry-row {
                grid-template-columns: 1fr; /* Stack columns on small screens */
            }
            .ot-entry-row .remove-btn-container {
                display: flex;
                justify-content: flex-end; /* Align remove button to the right */
                margin-top: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h2 class="text-3xl font-extrabold text-center text-gray-900 mb-6">OT Calculator</h2>

        <!-- Employee Settings -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Employee Settings</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                <div class="input-group">
                    <label for="basicSalary">Basic Monthly Salary (RM)</label>
                    <input type="number" id="basicSalary" value="3700" min="0" step="0.01" class="shadow-sm">
                </div>
                <div class="input-group">
                    <label for="targetOTPay">Target OT Pay (RM)</label>
                    <input type="number" id="targetOTPay" value="4000" min="0" step="0.01" class="shadow-sm">
                </div>
            </div>
            <p class="text-sm text-gray-600 mt-4">
                Working Schedule: 5 days/week, Saturday: Off Day, Sunday: Rest Day.
                For payroll, employer uses 26 working days monthly.
            </p>
        </div>

        <!-- Date Range -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200">
            <h3 class="text-xl font-bold text-gray-800 mb-4">OT Planning Date Range</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                <div class="input-group">
                    <label for="startDate">Start Date</label>
                    <input type="date" id="startDate" class="shadow-sm">
                </div>
                <div class="input-group">
                    <label for="endDate">End Date</label>
                    <input type="date" id="endDate" class="shadow-sm">
                </div>
            </div>
        </div>

        <!-- Daily OT Entries -->
        <div class="bg-gray-50 p-6 rounded-xl border border-gray-200">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Daily Overtime Entries</h3>
            <div id="otEntriesContainer">
                <!-- OT entry rows will be added here by JavaScript -->
            </div>
            <div class="flex flex-col sm:flex-row gap-4 mt-4">
                <button id="addOTEntryBtn" class="btn btn-secondary flex-grow">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 5a1 1 0 011 1v3h3a1 1 0 110 2h-3v3a1 1 0 11-2 0v-3H6a1 1 0 110-2h3V6a1 1 0 011-1z" clip-rule="evenodd" />
                    </svg>
                    Add OT Entry
                </button>
                <button id="autoAllocateBtn" class="btn btn-secondary flex-grow">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm-7-8a1 1 0 011-1h3a1 1 0 110 2H4a1 1 0 01-1-1zm11 0a1 1 0 011-1h3a1 1 0 110 2h-3a1 1 0 01-1-1z" clip-rule="evenodd" />
                    </svg>
                    Auto Allocate Hours
                </button>
                <button id="clearAllEntriesBtn" class="btn btn-danger flex-grow">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                    </svg>
                    Clear All Entries
                </button>
            </div>
        </div>

        <button id="calculateBtn" class="btn btn-primary w-full mt-4">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path d="M2 11a1 1 0 011-1h14a1 1 0 011 1v4a1 1 0 01-1 1H3a1 1 0 01-1-1v-4z" />
                <path fill-rule="evenodd" d="M14.5 4.5a3 3 0 11-6 0 3 3 0 016 0zm-6.293 3.293a1 1 0 011.414 0L10 8.586l.293-.293a1 1 0 011.414 0l.707.707a1 1 0 010 1.414L10 11.414l-.293.293a1 1 0 01-1.414 0l-.707-.707a1 1 0 010-1.414L9.414 9l-.293-.293a1 1 0 010-1.414z" clip-rule="evenodd" />
            </svg>
            Calculate OT
        </button>

        <!-- Results Section -->
        <div id="results" class="results-section hidden mt-6">
            <h3 class="text-2xl font-bold text-gray-900 mb-4">Calculation Summary</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <p><strong>Total OT Hours by Type:</strong></p>
                    <ul id="totalHoursByType" class="list-disc list-inside ml-4 text-gray-700"></ul>
                </div>
                <div>
                    <p><strong>Total Pay per OT Category:</strong></p>
                    <ul id="totalPayByCategory" class="list-disc list-inside ml-4 text-gray-700"></ul>
                </div>
            </div>
            <p class="text-xl font-bold text-gray-900 mt-6">Combined OT Pay: <span id="combinedOTPay" class="text-indigo-600">RM 0.00</span></p>
            <p class="text-xl font-bold text-gray-900 mt-2">Target OT Pay: <span id="targetOTPayDisplay" class="text-green-600">RM 4000.00</span></p>
            <p class="text-xl font-bold mt-2">Difference from Target: <span id="differenceFromTarget">RM 0.00</span></p>
            <button id="exportSummaryBtn" class="btn btn-secondary mt-6">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                    <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zm3.293-7.707a1 1 0 011.414 0L10 11.586l2.293-2.293a1 1 0 111.414 1.414l-3 3a1 1 0 01-1.414 0l-3-3a1 1 0 010-1.414z" clip-rule="evenodd" />
                </svg>
                Export Summary
            </button>
        </div>
    </div>

    <!-- Message Box HTML -->
    <div id="messageBox" class="message-box hidden">
        <h4 id="messageBoxTitle"></h4>
        <p id="messageBoxContent"></p>
        <button id="messageBoxCloseBtn">OK</button>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const basicSalaryInput = document.getElementById('basicSalary');
            const targetOTPayInput = document.getElementById('targetOTPay');
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            const otEntriesContainer = document.getElementById('otEntriesContainer');
            const addOTEntryBtn = document.getElementById('addOTEntryBtn');
            const autoAllocateBtn = document.getElementById('autoAllocateBtn');
            const clearAllEntriesBtn = document.getElementById('clearAllEntriesBtn');
            const calculateBtn = document.getElementById('calculateBtn');
            const resultsSection = document.getElementById('results');
            const totalHoursByTypeElem = document.getElementById('totalHoursByType');
            const totalPayByCategoryElem = document.getElementById('totalPayByCategory');
            const combinedOTPayElem = document.getElementById('combinedOTPay');
            const targetOTPayDisplayElem = document.getElementById('targetOTPayDisplay');
            const differenceFromTargetElem = document.getElementById('differenceFromTarget');
            const exportSummaryBtn = document.getElementById('exportSummaryBtn');

            const messageBox = document.getElementById('messageBox');
            const messageBoxTitle = document.getElementById('messageBoxTitle');
            const messageBoxContent = document.getElementById('messageBoxContent');
            const messageBoxCloseBtn = document.getElementById('messageBoxCloseBtn');

            // --- Constants and Rates ---
            const WORKING_DAYS_MONTHLY = 26;
            const STANDARD_WORK_HOURS_DAILY = 8;
            const MAX_DAILY_OT_HOURS = 8; // Max 8 hours OT per day as per typical regulations

            const OT_MULTIPLIERS = {
                'Normal OT (Weekdays)': 1.5,
                'Off Day (Saturday)': 1.5,
                'Rest Day (Sunday) — 1st 8h': 0.5,
                'Rest Day (Sunday) — after 8h': 2.0,
                'Public Holiday': 2.0
            };

            // --- State Variables ---
            let otEntries = []; // Stores objects like { id, date, hours, type, startTime, endTime }
            let entryCounter = 0; // To generate unique IDs for each entry row

            // --- Utility Functions ---

            /**
             * Displays a custom message box.
             * @param {string} title - The title of the message box.
             * @param {string} message - The content message.
             */
            function showMessageBox(title, message) {
                messageBoxTitle.textContent = title;
                messageBoxContent.textContent = message;
                messageBox.classList.remove('hidden');
            }

            // Close message box
            messageBoxCloseBtn.addEventListener('click', () => {
                messageBox.classList.add('hidden');
            });

            /**
             * Calculates the basic hourly rate.
             * @param {number} monthlySalary - The employee's basic monthly salary.
             * @returns {number} The calculated basic hourly rate.
             */
            function calculateHourlyRate(monthlySalary) {
                if (monthlySalary <= 0) return 0;
                return monthlySalary / WORKING_DAYS_MONTHLY / STANDARD_WORK_HOURS_DAILY;
            }

            /**
             * Calculates the OT pay for a given entry.
             * @param {number} hourlyRate - The basic hourly rate.
             * @param {number} hours - The number of OT hours.
             * @param {number} multiplier - The OT rate multiplier.
             * @returns {number} The calculated OT pay.
             */
            function calculateOT(hourlyRate, hours, multiplier) {
                return hourlyRate * multiplier * hours;
            }

            /**
             * Formats a number to RM currency string.
             * @param {number} amount - The amount to format.
             * @returns {string} Formatted currency string (e.g., "RM 123.45").
             */
            function formatCurrency(amount) {
                return `RM ${amount.toFixed(2)}`;
            }

            /**
             * Gets the current date in YYYY-MM-DD format.
             * @returns {string} The current date string.
             */
            function getTodayDateString() {
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            /**
             * Generates a random time (HH:MM) within a given hour range, at 15-minute intervals.
             * @param {number} minHour - The minimum hour (inclusive).
             * @param {number} maxHour - The maximum hour (exclusive).
             * @returns {string} The random time in "HH:MM" format.
             */
            function getRandomTime(minHour, maxHour) {
                const hours = Math.floor(Math.random() * (maxHour - minHour)) + minHour;
                const minutesOptions = [0, 15, 30, 45];
                const minutes = minutesOptions[Math.floor(Math.random() * minutesOptions.length)];
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
            }

            /**
             * Adds hours to a given time string (HH:MM) and returns a new time string.
             * Handles crossing midnight (though for OT, typically hours reset per day).
             * @param {string} startTimeStr - The start time in "HH:MM" format.
             * @param {number} hoursToAdd - The hours to add (can be decimal like 3.5).
             * @returns {string} The new time in "HH:MM" format.
             */
            function addHoursToTime(startTimeStr, hoursToAdd) {
                if (!startTimeStr) return ''; // Handle cases where start time is not set
                const [startHour, startMinute] = startTimeStr.split(':').map(Number);
                let totalMinutes = startHour * 60 + startMinute + (hoursToAdd * 60);

                let newHour = Math.floor(totalMinutes / 60) % 24; // % 24 to handle midnight crossing
                let newMinute = Math.round(totalMinutes % 60);

                // Handle cases like 59.9 minutes becoming 60, or 60.1 minutes becoming 60.
                if (newMinute === 60) {
                    newMinute = 0;
                    newHour = (newHour + 1) % 24;
                }

                return `${String(newHour).padStart(2, '0')}:${String(newMinute).padStart(2, '0')}`;
            }

            /**
             * Calculates and updates the suggested start and end times for a given OT entry.
             * This function modifies the entry object directly.
             * @param {Object} entry - The OT entry object to update.
             * @param {string} [prevEndTimeForDay] - Optional: The end time of a previous OT entry on the same day, for chaining.
             */
            function calculateSuggestedTimes(entry, prevEndTimeForDay = null) {
                let suggestedStartTime = '';

                if (entry.type === 'Normal OT (Weekdays)') {
                    // Start anytime after 6 PM (18:00)
                    suggestedStartTime = getRandomTime(18, 20); // Random between 6 PM and 7:45 PM
                } else if (entry.type === 'Off Day (Saturday)' || entry.type === 'Public Holiday' || entry.type === 'Rest Day (Sunday) — 1st 8h') {
                    // Start anytime after 9 AM (09:00)
                    suggestedStartTime = getRandomTime(9, 11); // Random between 9 AM and 10:45 AM
                } else if (entry.type === 'Rest Day (Sunday) — after 8h') {
                    // If there's a preceding entry for the same day, use its end time
                    if (prevEndTimeForDay) {
                        suggestedStartTime = prevEndTimeForDay;
                    } else {
                        // Otherwise, start anytime after 5 PM (17:00)
                        suggestedStartTime = getRandomTime(17, 19); // Random between 5 PM and 6:45 PM
                    }
                }

                entry.startTime = suggestedStartTime;
                entry.endTime = addHoursToTime(entry.startTime, entry.hours);
            }


            /**
             * Clears all existing OT entry rows from the UI and the internal state.
             * This is a helper function used by `clearDailyOTEntries` and `autoAllocateHours`.
             */
            function clearOTEntries() {
                otEntries = [];
                otEntriesContainer.innerHTML = '';
                entryCounter = 0; // Reset counter when clearing
            }

            /**
             * Renders the OT entries from the `otEntries` array to the UI.
             * This function is responsible for updating the display, not modifying the `otEntries` array itself.
             */
            function renderOTEntries() {
                otEntriesContainer.innerHTML = ''; // Clear current UI
                otEntries.forEach(entry => {
                    const entryId = entry.id; // Use the existing ID from the entry object
                    const newRow = document.createElement('div');
                    newRow.classList.add('ot-entry-row');
                    newRow.setAttribute('data-id', entryId);

                    newRow.innerHTML = `
                        <div class="input-group">
                            <label for="${entryId}-date">Date</label>
                            <input type="date" id="${entryId}-date" value="${entry.date}" class="shadow-sm">
                        </div>
                        <div class="input-group">
                            <label for="${entryId}-hours">Hours</label>
                            <input type="number" id="${entryId}-hours" value="${entry.hours.toFixed(1)}" min="0" step="0.5" class="shadow-sm">
                        </div>
                        <div class="input-group">
                            <label for="${entryId}-type">OT Type</label>
                            <select id="${entryId}-type" class="shadow-sm">
                                ${Object.keys(OT_MULTIPLIERS).map(type => `
                                    <option value="${type}" ${type === entry.type ? 'selected' : ''}>${type}</option>
                                `).join('')}
                            </select>
                        </div>
                        <div class="input-group">
                            <label for="${entryId}-start-time">Start Time</label>
                            <input type="time" id="${entryId}-start-time" value="${entry.startTime}" class="shadow-sm" readonly>
                        </div>
                        <div class="input-group">
                            <label for="${entryId}-end-time">End Time</label>
                            <input type="time" id="${entryId}-end-time" value="${entry.endTime}" class="shadow-sm" readonly>
                        </div>
                        <div class="remove-btn-container">
                            <button type="button" class="btn btn-danger btn-sm remove-ot-entry-btn" data-id="${entryId}">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 11-2 0v6a1 1 0 112 0V8z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        </div>
                    `;
                    otEntriesContainer.appendChild(newRow);

                    // Re-attach event listeners to the newly created elements
                    newRow.querySelector(`#${entryId}-date`).addEventListener('change', (e) => {
                        const updatedEntry = otEntries.find(entry => entry.id === entryId);
                        if (updatedEntry) {
                            updatedEntry.date = e.target.value;
                            // When date changes, recalculate times based on new day type (weekday/weekend) if needed
                            calculateSuggestedTimes(updatedEntry);
                            renderOTEntries();
                        }
                    });
                    newRow.querySelector(`#${entryId}-hours`).addEventListener('input', (e) => {
                        const updatedEntry = otEntries.find(entry => entry.id === entryId);
                        if (updatedEntry) {
                            updatedEntry.hours = parseFloat(e.target.value) || 0;
                            calculateSuggestedTimes(updatedEntry); // Recalculate end time
                            renderOTEntries(); // Re-render to update times
                        }
                    });
                    newRow.querySelector(`#${entryId}-type`).addEventListener('change', (e) => {
                        const updatedEntry = otEntries.find(entry => entry.id === entryId);
                        if (updatedEntry) {
                            updatedEntry.type = e.target.value;
                            calculateSuggestedTimes(updatedEntry); // Recalculate start/end times based on new type
                            renderOTEntries(); // Re-render to update times
                        }
                    });
                    newRow.querySelector(`.remove-ot-entry-btn`).addEventListener('click', () => removeOTEntryRow(entryId));
                });
            }


            /**
             * Adds a new OT entry to the `otEntries` array and then re-renders the UI.
             * This is for manual "Add OT Entry" button clicks.
             */
            function addNewManualOTEntry() {
                const newEntry = {
                    id: `ot-entry-${entryCounter++}`, // Generate a new unique ID
                    date: getTodayDateString(),
                    hours: 0,
                    type: 'Normal OT (Weekdays)',
                    startTime: '', // Will be calculated by calculateSuggestedTimes
                    endTime: ''    // Will be calculated by calculateSuggestedTimes
                };
                // Calculate initial times for the new entry
                calculateSuggestedTimes(newEntry);
                otEntries.push(newEntry);
                renderOTEntries(); // Re-render the entire list
            }

            /**
             * Updates an OT entry in the otEntries array.
             * @param {string} id - The ID of the entry to update.
             * @param {string} field - The field to update ('date', 'hours', 'type').
             * @param {*} value - The new value for the field.
             */
            function updateOTEntry(id, field, value) {
                const index = otEntries.findIndex(entry => entry.id === id);
                if (index !== -1) {
                    otEntries[index][field] = value;
                    calculateSuggestedTimes(otEntries[index]); // Recalculate times for the updated entry
                    renderOTEntries(); // Re-render to reflect changes
                }
            }

            /**
             * Removes an OT entry from the otEntries array and then re-renders the UI.
             * @param {string} id - The ID of the entry to remove.
             */
            function removeOTEntryRow(id) {
                otEntries = otEntries.filter(entry => entry.id !== id);
                renderOTEntries(); // Re-render the entire list
            }

            /**
             * Function to clear all daily OT entries and reset the results section.
             */
            function clearDailyOTEntries() {
                clearOTEntries(); // Use the helper function to clear all rows and state
                addNewManualOTEntry(); // Add back one empty row for convenience
                resultsSection.classList.add('hidden'); // Hide results section
                showMessageBox('Entries Cleared', 'All daily OT entries have been cleared.');
            }

            /**
             * Main function to calculate and display OT results.
             */
            function calculateAndDisplayResults() {
                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = parseFloat(targetOTPayInput.value);
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;

                // Basic validation
                if (isNaN(basicSalary) || basicSalary <= 0) {
                    showMessageBox('Input Error', 'Please enter a valid Basic Monthly Salary.');
                    return;
                }
                if (isNaN(targetOTPay) || targetOTPay < 0) {
                    showMessageBox('Input Error', 'Please enter a valid Target OT Pay.');
                    return;
                }
                if (!startDate || !endDate) {
                    showMessageBox('Input Error', 'Please select both Start and End Dates for the planning range.');
                    return;
                }
                if (new Date(startDate) > new Date(endDate)) {
                    showMessageBox('Input Error', 'Start Date cannot be after End Date.');
                    return;
                }
                if (otEntries.length === 0) {
                    showMessageBox('Input Error', 'Please add at least one OT entry, or use Auto Allocate Hours.');
                    return;
                }

                const hourlyRate = calculateHourlyRate(basicSalary);

                let totalHoursByType = {};
                let totalPayByCategory = {};
                let combinedOTPay = 0;

                // Initialize categories
                for (const type in OT_MULTIPLIERS) {
                    totalHoursByType[type] = 0;
                    totalPayByCategory[type] = 0;
                }

                otEntries.forEach(entry => {
                    const hours = parseFloat(entry.hours);
                    const type = entry.type;

                    if (isNaN(hours) || hours <= 0) {
                        // Skip invalid entries or show a warning if desired
                        return;
                    }

                    const multiplier = OT_MULTIPLIERS[type];
                    if (multiplier === undefined) {
                        console.warn(`Unknown OT type: ${type}`);
                        return; // Skip if type is not recognized
                    }

                    const dailyOTPay = calculateOT(hourlyRate, hours, multiplier);

                    totalHoursByType[type] += hours;
                    totalPayByCategory[type] += dailyOTPay;
                    combinedOTPay += dailyOTPay;
                });

                // Display Results
                totalHoursByTypeElem.innerHTML = '';
                for (const type in totalHoursByType) {
                    if (totalHoursByType[type] > 0) {
                        const li = document.createElement('li');
                        li.textContent = `${type}: ${totalHoursByType[type].toFixed(1)} hours`;
                        totalHoursByTypeElem.appendChild(li);
                    }
                }

                totalPayByCategoryElem.innerHTML = '';
                for (const type in totalPayByCategory) {
                    if (totalPayByCategory[type] > 0) {
                        const li = document.createElement('li');
                        li.textContent = `${type}: ${formatCurrency(totalPayByCategory[type])}`;
                        totalPayByCategoryElem.appendChild(li);
                    }
                }

                combinedOTPayElem.textContent = formatCurrency(combinedOTPay);
                targetOTPayDisplayElem.textContent = formatCurrency(targetOTPay);

                const difference = combinedOTPay - targetOTPay;
                differenceFromTargetElem.textContent = formatCurrency(difference);
                if (difference >= 0) {
                    differenceFromTargetElem.classList.remove('text-red-600');
                    differenceFromTargetElem.classList.add('text-green-600');
                } else {
                    differenceFromTargetElem.classList.remove('text-green-600');
                    differenceFromTargetElem.classList.add('text-red-600');
                }

                resultsSection.classList.remove('hidden'); // Show results section
            }

            /**
             * Generates a random number within a given range, rounded to the nearest 0.5.
             * @param {number} min - The minimum value.
             * @param {number} max - The maximum value.
             * @returns {number} The random number.
             */
            function getRandomHours(min, max) {
                const random = Math.random() * (max - min) + min;
                return Math.round(random * 2) / 2; // Round to nearest 0.5
            }

            /**
             * Adds or updates an OT entry in the otEntries array.
             * If an entry for the given date and type already exists, its hours are updated.
             * Otherwise, a new entry is added.
             * @param {string} date - The date of the OT entry.
             * @param {number} hours - The hours to add/set for the OT entry.
             * @param {string} type - The type of OT.
             */
            function addOrUpdateOTEntry(date, hours, type) {
                const existingEntry = otEntries.find(entry => entry.date === date && entry.type === type);

                if (existingEntry) {
                    // Update existing entry's hours
                    existingEntry.hours += hours;
                } else {
                    // Add new entry
                    otEntries.push({
                        id: `ot-entry-${entryCounter++}`,
                        date: date,
                        hours: hours,
                        type: type,
                        startTime: '', // Will be calculated later
                        endTime: ''    // Will be calculated later
                    });
                }
            }


            /**
             * Automatically allocates OT hours to reach the target pay, prioritizing certain days/types.
             */
            function autoAllocateHours() {
                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = parseFloat(targetOTPayInput.value);
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const includeTripleRate = false; // Triple rate checkbox removed, so always false

                // Basic validation
                if (isNaN(basicSalary) || basicSalary <= 0) {
                    showMessageBox('Input Error', 'Please enter a valid Basic Monthly Salary for auto-allocation.');
                    return;
                }
                if (isNaN(targetOTPay) || targetOTPay <= 0) {
                    showMessageBox('Input Error', 'Please enter a valid Target OT Pay (> RM0) for auto-allocation.');
                    return;
                }
                if (!startDate || !endDate) {
                    showMessageBox('Input Error', 'Please select both Start and End Dates for the planning range.');
                    return;
                }
                if (new Date(startDate) > new Date(endDate)) {
                    showMessageBox('Input Error', 'Start Date cannot be after End Date.');
                    return;
                }

                clearOTEntries(); // Clear existing entries before auto-allocating

                const hourlyRate = calculateHourlyRate(basicSalary);
                let currentAllocatedPay = 0;
                const allocationPrecision = 0.01; // Small value to handle floating point comparisons

                const availableDays = [];
                let currentDate = new Date(startDate);
                const endDateTime = new Date(endDate).getTime();

                while (currentDate.getTime() <= endDateTime) {
                    availableDays.push({
                        date: currentDate.toISOString().split('T')[0],
                        dayOfWeek: currentDate.getDay() // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
                    });
                    currentDate.setDate(currentDate.getDate() + 1);
                }

                // Shuffle days to distribute OT more evenly across the period, rather than front-loading
                availableDays.sort(() => Math.random() - 0.5);

                // Initialize a map to track hours allocated per day to enforce MAX_DAILY_OT_HOURS
                const hoursAllocatedPerDay = {};
                availableDays.forEach(day => { hoursAllocatedPerDay[day.date] = 0; });

                // Define allocation steps with preferred hours and types and their ranges
                const allocationSteps = [
                    { type: 'Normal OT (Weekdays)', minHours: 2, maxHours: 4, days: [1, 2, 3, 4, 5] }, // Mon-Fri
                    { type: 'Off Day (Saturday)', minHours: 3, maxHours: 5, days: [6] }, // Saturday
                    { type: 'Rest Day (Sunday) — 1st 8h', hours: 8, days: [0] }, // Sunday (fixed 8h for 0.5x)
                    { type: 'Rest Day (Sunday) — after 8h', minHours: 1, maxHours: 3, days: [0] }, // Sunday (1-3h for 2.0x)
                    // 'Public Holiday' is not in this primary allocation loop for simplicity
                ];

                // Keep track of Sundays that have received 0.5x hours
                const SundaysWithFirst8h = new Set();

                // --- Phase 1: Generate core entries (date, hours, type) ---
                for (const step of allocationSteps) {
                    if (currentAllocatedPay >= targetOTPay - allocationPrecision) break; // Target met

                    const multiplier = OT_MULTIPLIERS[step.type];
                    if (!multiplier) continue;

                    const relevantDays = availableDays.filter(day => step.days.includes(day.dayOfWeek));

                    for (const day of relevantDays) {
                        if (currentAllocatedPay >= targetOTPay - allocationPrecision) break;

                        const maxHoursForThisDay = MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date];
                        if (maxHoursForThisDay <= 0) continue; // Day is already full

                        let hoursToConsider = 0;
                        if (step.hours !== undefined) { // Fixed hours (e.g., Sunday 1st 8h)
                            hoursToConsider = Math.min(step.hours, maxHoursForThisDay);
                        } else { // Random range hours
                            const suggestedHours = getRandomHours(step.minHours, step.maxHours);
                            hoursToConsider = Math.min(suggestedHours, maxHoursForThisDay);
                        }

                        // Special handling for Sunday 2.0x: only apply if 0.5x was already applied
                        if (step.type === 'Rest Day (Sunday) — after 8h' && !SundaysWithFirst8h.has(day.date)) {
                            continue; // Skip if 0.5x hasn't been applied yet for this Sunday
                        }

                        const potentialPay = calculateOT(hourlyRate, hoursToConsider, multiplier);

                        if (currentAllocatedPay + potentialPay <= targetOTPay + allocationPrecision) {
                            addOrUpdateOTEntry(day.date, hoursToConsider, step.type); // Use the new function
                            currentAllocatedPay += potentialPay;
                            hoursAllocatedPerDay[day.date] += hoursToConsider;
                            if (step.type === 'Rest Day (Sunday) — 1st 8h') {
                                SundaysWithFirst8h.add(day.date);
                            }
                        } else {
                            // Add only what's needed to hit the target precisely
                            const remainingPayNeeded = targetOTPay - currentAllocatedPay;
                            const hoursToPreciselyAdd = remainingPayNeeded / (hourlyRate * multiplier);
                            hoursToConsider = Math.min(hoursToPreciselyAdd, maxHoursForThisDay);
                            if (hoursToConsider > 0) {
                                addOrUpdateOTEntry(day.date, hoursToConsider, step.type); // Use the new function
                                currentAllocatedPay = targetOTPay;
                                hoursAllocatedPerDay[day.date] += hoursToConsider;
                            }
                        }
                    }
                }

                // --- Phase 2: Fill remaining gap (without Triple Rate) ---
                // This phase will try to fill the remaining gap using existing OT types
                // It iterates through available days and tries to add more hours
                // prioritizing based on the current `hoursAllocatedPerDay` to spread it out.
                if (currentAllocatedPay < targetOTPay - allocationPrecision) {
                    const daysToFill = availableDays.slice().sort((a, b) => hoursAllocatedPerDay[a.date] - hoursAllocatedPerDay[b.date]);

                    for (const day of daysToFill) {
                        if (currentAllocatedPay >= targetOTPay - allocationPrecision) break;

                        const maxHoursForThisDay = MAX_DAILY_OT_HOURS - hoursAllocatedPerDay[day.date];
                        if (maxHoursForThisDay <= 0) continue;

                        let hoursToConsider = 0;
                        let typeToUse = '';
                        let currentMultiplier = 0;

                        // Prioritize higher-multiplier types if possible for efficiency
                        // Order of preference: Rest Day (Sunday) - after 8h (2.0x), Public Holiday (2.0x),
                        // Off Day (Saturday) (1.5x), Normal OT (Weekdays) (1.5x), Rest Day (Sunday) - 1st 8h (0.5x)
                        if (day.dayOfWeek === 0 && SundaysWithFirst8h.has(day.date) && hoursAllocatedPerDay[day.date] < 16) { // Sunday, after 8h, and not yet full
                            typeToUse = 'Rest Day (Sunday) — after 8h';
                            currentMultiplier = OT_MULTIPLIERS[typeToUse];
                            hoursToConsider = getRandomHours(1, Math.min(3, maxHoursForThisDay)); // Max 3 hours per random chunk
                        } else if (day.dayOfWeek === 6) { // Saturday
                            typeToUse = 'Off Day (Saturday)';
                            currentMultiplier = OT_MULTIPLIERS[typeToUse];
                            hoursToConsider = getRandomHours(1, Math.min(5, maxHoursForThisDay)); // Max 5 hours per random chunk
                        } else if (day.dayOfWeek >= 1 && day.dayOfWeek <= 5) { // Weekday
                            typeToUse = 'Normal OT (Weekdays)';
                            currentMultiplier = OT_MULTIPLIERS[typeToUse];
                            hoursToConsider = getRandomHours(1, Math.min(4, maxHoursForThisDay)); // Max 4 hours per random chunk
                        } else if (day.dayOfWeek === 0 && !SundaysWithFirst8h.has(day.date) && hoursAllocatedPerDay[day.date] < 8) { // Sunday, 1st 8h, not yet full
                            typeToUse = 'Rest Day (Sunday) — 1st 8h';
                            currentMultiplier = OT_MULTIPLIERS[typeToUse];
                            hoursToConsider = Math.min(8 - hoursAllocatedPerDay[day.date], maxHoursForThisDay); // Fill up to 8h for 0.5x
                        }
                        // Public Holiday is generally not randomized for auto-allocation as it's event-specific.

                        if (hoursToConsider > 0 && currentMultiplier > 0) {
                            const potentialPay = calculateOT(hourlyRate, hoursToConsider, currentMultiplier);
                            if (currentAllocatedPay + potentialPay <= targetOTPay + allocationPrecision) {
                                addOrUpdateOTEntry(day.date, hoursToConsider, typeToUse);
                                currentAllocatedPay += potentialPay;
                                hoursAllocatedPerDay[day.date] += hoursToConsider;
                                if (typeToUse === 'Rest Day (Sunday) — 1st 8h') {
                                    SundaysWithFirst8h.add(day.date);
                                }
                            } else {
                                const remainingPayNeeded = targetOTPay - currentAllocatedPay;
                                const hoursToPreciselyAdd = remainingPayNeeded / (hourlyRate * currentMultiplier);
                                const finalHoursToAdd = Math.min(hoursToPreciselyAdd, hoursToConsider);
                                if (finalHoursToAdd > 0) {
                                    addOrUpdateOTEntry(day.date, finalHoursToAdd, typeToUse);
                                    currentAllocatedPay = targetOTPay;
                                    hoursAllocatedPerDay[day.date] += finalHoursToAdd;
                                }
                            }
                        }
                    }
                }

                // --- Final Check: If target still not met, inform the user ---
                if (currentAllocatedPay < targetOTPay - allocationPrecision) {
                    showMessageBox('Target Not Fully Met', `The target OT pay of ${formatCurrency(targetOTPay)} was not fully met (${formatCurrency(currentAllocatedPay)}). You may need to manually add more hours or increase the planning date range.`);
                }

                // --- Phase 3: Sort entries and calculate/assign final start/end times ---
                otEntries.sort((a, b) => new Date(a.date) - new Date(b.date));

                const lastEndTimeOnDay = {}; // To track end time for chaining on the same day
                otEntries.forEach(entry => {
                    let prevEndTime = lastEndTimeOnDay[entry.date] || null;
                    calculateSuggestedTimes(entry, prevEndTime);
                    lastEndTimeOnDay[entry.date] = entry.endTime; // Update last end time for this day
                });

                renderOTEntries(); // Re-render the UI based on the sorted and time-calculated otEntries array

                calculateAndDisplayResults(); // Update results after auto-allocation
                if (currentAllocatedPay >= targetOTPay - allocationPrecision) {
                    showMessageBox('Auto Allocation Complete', 'Overtime hours have been automatically allocated to reach your target pay. Please review and adjust as needed.');
                }
            }


            /**
             * Exports the summary to a text file.
             */
            function exportSummary() {
                const basicSalary = parseFloat(basicSalaryInput.value);
                const targetOTPay = parseFloat(targetOTPayInput.value);
                const startDate = startDateInput.value;
                const endDate = endDateInput.value;
                const hourlyRate = calculateHourlyRate(basicSalary);

                let summaryText = `--- OT Calculation Summary ---\n\n`;
                summaryText += `Employee Settings:\n`;
            summaryText += `  Basic Monthly Salary: ${formatCurrency(basicSalary)}\n`;
                summaryText += `  Hourly Rate: RM ${hourlyRate.toFixed(2)}/hour\n\n`;

                summaryText += `OT Planning Period: ${startDate} to ${endDate}\n`;
        summaryText += `Target OT Pay: ${formatCurrency(targetOTPay)}\n\n`;

                summaryText += `Daily OT Entries:\n`;
                if (otEntries.length === 0) {
                    summaryText += `  No entries recorded.\n`;
                } else {
                    // Entries are already sorted by date in otEntries array after auto-allocation/manual updates
                    otEntries.forEach(entry => {
                        summaryText += `  Date: ${entry.date}, Hours: ${entry.hours.toFixed(1)}h, Type: ${entry.type}\n`;
                        if (entry.startTime && entry.endTime) {
                            summaryText += `  Suggested Time: ${entry.startTime} - ${entry.endTime}\n`;
                        }
                    });
                }
                summaryText += `\n`;

                // Recalculate for export to ensure consistency
                let totalHoursByType = {};
                let totalPayByCategory = {};
                let combinedOTPay = 0;

                for (const type in OT_MULTIPLIERS) {
                    totalHoursByType[type] = 0;
                    totalPayByCategory[type] = 0;
                }

                otEntries.forEach(entry => {
                    const hours = parseFloat(entry.hours);
                    const type = entry.type;
                    if (isNaN(hours) || hours <= 0) return;

                    const multiplier = OT_MULTIPLIERS[type];
                    if (multiplier === undefined) return;

                    const dailyOTPay = calculateOT(hourlyRate, hours, multiplier);

                    totalHoursByType[type] += hours;
                    totalPayByCategory[type] += dailyOTPay;
                    combinedOTPay += dailyOTPay;
                });

                summaryText += `Total OT Hours by Type:\n`;
                let hasHours = false;
                for (const type in totalHoursByType) {
                    if (totalHoursByType[type] > 0) {
                        summaryText += `  ${type}: ${totalHoursByType[type].toFixed(1)} hours\n`;
                        hasHours = true;
                    }
                }
                if (!hasHours) summaryText += `  N/A\n`;
                summaryText += `\n`;

                summaryText += `Total Pay per OT Category:\n`;
                let hasPay = false;
                for (const type in totalPayByCategory) {
                    if (totalPayByCategory[type] > 0) {
                        summaryText += `  ${type}: ${formatCurrency(totalPayByCategory[type])}\n`;
                        hasPay = true;
                    }
                }
                if (!hasPay) summaryText += `  N/A\n`;
                summaryText += `\n`;

                summaryText += `Combined OT Pay: ${formatCurrency(combinedOTPay)}\n`;
                summaryText += `Difference from Target: ${formatCurrency(combinedOTPay - targetOTPay)}\n`;
                summaryText += `\n--- End of Summary ---`;

                const blob = new Blob([summaryText], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ot_summary.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- Event Listeners ---
            addOTEntryBtn.addEventListener('click', () => addNewManualOTEntry()); // Call the new function
            autoAllocateBtn.addEventListener('click', autoAllocateHours);
            clearAllEntriesBtn.addEventListener('click', clearDailyOTEntries);
            calculateBtn.addEventListener('click', calculateAndDisplayResults);
            exportSummaryBtn.addEventListener('click', exportSummary);

            // --- Initial Setup ---
            const today = new Date();
            const oneMonthBefore = new Date();
            oneMonthBefore.setDate(today.getDate() - 30); // Set to 30 days before today

            startDateInput.value = oneMonthBefore.toISOString().split('T')[0]; // Start date is one month before
            endDateInput.value = today.toISOString().split('T')[0]; // End date is today

            // Add an initial empty OT entry row for user convenience
            addNewManualOTEntry();
        });
    </script>
</body>
</html>
